{
  "django__django-11790": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11790",
    "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex a0cfed0995..a65a6f5369 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -188,7 +188,7 @@ class AuthenticationForm(forms.Form):\n         self.request = request\n         self.user_cache = None\n         super().__init__(*args, **kwargs)\n-\n+        username = self.fields.get('username')\\n        if username:\\n            max_len = getattr(username, 'max_length', None)\\n            if max_len:\\n                max_len_str = str(max_len)\\n                if username.widget.attrs.get('maxlength') != max_len_str:\\n                    username.widget.attrs['maxlength'] = max_len_str\\n\n         # Set the max length and label for the \"username\" field.\n         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n         self.fields['username'].max_length = self.username_field.max_length or 254\ndiff --git a/testbed/edge_authform_maxlength_test.py b/testbed/edge_authform_maxlength_test.py\nnew file mode 100644\nindex 0000000000..52bf13a5fd\n--- /dev/null\n+++ b/testbed/edge_authform_maxlength_test.py\n@@ -0,0 +1,26 @@\n+\n+def edge_test_authform_username_maxlength_patch():\n+    class FakeWidget:\n+        def __init__(self):\n+            self.attrs = {}\n+    class FakeField:\n+        def __init__(self, max_length):\n+            self.max_length = max_length\n+            self.widget = FakeWidget()\n+    class FakeForm:\n+        def __init__(self):\n+            self.fields = {'username': FakeField(150)}\n+            username = self.fields.get('username')\n+            if username:\n+                max_len = getattr(username, 'max_length', None)\n+                if max_len:\n+                    max_len_str = str(max_len)\n+                    if username.widget.attrs.get('maxlength') != max_len_str:\n+                        username.widget.attrs['maxlength'] = max_len_str\n+    f = FakeForm()\n+    username = f.fields['username']\n+    assert username.widget.attrs['maxlength'] == str(username.max_length)\n+    print(\"EDGE_TEST_PASSED\")\n+\n+if __name__ == \"__main__\":\n+    edge_test_authform_username_maxlength_patch()\n\n"
  },
  "django__django-11815": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11815",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..2b51d4c668 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,220 +120,6 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n-\n-\n-class FloatSerializer(BaseSimpleSerializer):\n-    def serialize(self):\n-        if math.isnan(self.value) or math.isinf(self.value):\n-            return 'float(\"{}\")'.format(self.value), set()\n-        return super().serialize()\n-\n-\n-class FrozensetSerializer(BaseSequenceSerializer):\n-    def _format(self):\n-        return \"frozenset([%s])\"\n-\n-\n-class FunctionTypeSerializer(BaseSerializer):\n-    def serialize(self):\n-        if getattr(self.value, \"__self__\", None) and isinstance(self.value.__self__, type):\n-            klass = self.value.__self__\n-            module = klass.__module__\n-            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\"import %s\" % module}\n-        # Further error checking\n-        if self.value.__name__ == '<lambda>':\n-            raise ValueError(\"Cannot serialize function: lambda\")\n-        if self.value.__module__ is None:\n-            raise ValueError(\"Cannot serialize function %r: No module\" % self.value)\n-\n-        module_name = self.value.__module__\n-\n-        if '<' not in self.value.__qualname__:  # Qualname can include <locals>\n-            return '%s.%s' % (module_name, self.value.__qualname__), {'import %s' % self.value.__module__}\n-\n-        raise ValueError(\n-            'Could not find function %s in %s.\\n' % (self.value.__name__, module_name)\n-        )\n-\n-\n-class FunctoolsPartialSerializer(BaseSerializer):\n-    def serialize(self):\n-        # Serialize functools.partial() arguments\n-        func_string, func_imports = serializer_factory(self.value.func).serialize()\n-        args_string, args_imports = serializer_factory(self.value.args).serialize()\n-        keywords_string, keywords_imports = serializer_factory(self.value.keywords).serialize()\n-        # Add any imports needed by arguments\n-        imports = {'import functools', *func_imports, *args_imports, *keywords_imports}\n-        return (\n-            'functools.%s(%s, *%s, **%s)' % (\n-                self.value.__class__.__name__,\n-                func_string,\n-                args_string,\n-                keywords_string,\n-            ),\n-            imports,\n-        )\n-\n-\n-class IterableSerializer(BaseSerializer):\n-    def serialize(self):\n-        imports = set()\n-        strings = []\n-        for item in self.value:\n-            item_string, item_imports = serializer_factory(item).serialize()\n-            imports.update(item_imports)\n-            strings.append(item_string)\n-        # When len(strings)==0, the empty iterable should be serialized as\n-        # \"()\", not \"(,)\" because (,) is invalid Python syntax.\n-        value = \"(%s)\" if len(strings) != 1 else \"(%s,)\"\n-        return value % (\", \".join(strings)), imports\n-\n-\n-class ModelFieldSerializer(DeconstructableSerializer):\n-    def serialize(self):\n-        attr_name, path, args, kwargs = self.value.deconstruct()\n-        return self.serialize_deconstructed(path, args, kwargs)\n-\n-\n-class ModelManagerSerializer(DeconstructableSerializer):\n-    def serialize(self):\n-        as_manager, manager_path, qs_path, args, kwargs = self.value.deconstruct()\n-        if as_manager:\n-            name, imports = self._serialize_path(qs_path)\n-            return \"%s.as_manager()\" % name, imports\n-        else:\n-            return self.serialize_deconstructed(manager_path, args, kwargs)\n-\n-\n-class OperationSerializer(BaseSerializer):\n-    def serialize(self):\n-        from django.db.migrations.writer import OperationWriter\n-        string, imports = OperationWriter(self.value, indentation=0).serialize()\n-        # Nested operation, trailing comma is handled in upper OperationWriter._write()\n-        return string.rstrip(','), imports\n-\n-\n-class RegexSerializer(BaseSerializer):\n-    def serialize(self):\n-        regex_pattern, pattern_imports = serializer_factory(self.value.pattern).serialize()\n-        # Turn off default implicit flags (e.g. re.U) because regexes with the\n-        # same implicit and explicit flags aren't equal.\n-        flags = self.value.flags ^ re.compile('').flags\n-        regex_flags, flag_imports = serializer_factory(flags).serialize()\n-        imports = {'import re', *pattern_imports, *flag_imports}\n-        args = [regex_pattern]\n-        if flags:\n-            args.append(regex_flags)\n-        return \"re.compile(%s)\" % ', '.join(args), imports\n-\n-\n-class SequenceSerializer(BaseSequenceSerializer):\n-    def _format(self):\n-        return \"[%s]\"\n-\n-\n-class SetSerializer(BaseSequenceSerializer):\n-    def _format(self):\n-        # Serialize as a set literal except when value is empty because {}\n-        # is an empty dict.\n-        return '{%s}' if self.value else 'set(%s)'\n-\n-\n-class SettingsReferenceSerializer(BaseSerializer):\n-    def serialize(self):\n-        return \"settings.%s\" % self.value.setting_name, {\"from django.conf import settings\"}\n-\n-\n-class TupleSerializer(BaseSequenceSerializer):\n-    def _format(self):\n-        # When len(value)==0, the empty tuple should be serialized as \"()\",\n-        # not \"(,)\" because (,) is invalid Python syntax.\n-        return \"(%s)\" if len(self.value) != 1 else \"(%s,)\"\n-\n-\n-class TypeSerializer(BaseSerializer):\n-    def serialize(self):\n-        special_cases = [\n-            (models.Model, \"models.Model\", []),\n-            (type(None), 'type(None)', []),\n-        ]\n-        for case, string, imports in special_cases:\n-            if case is self.value:\n-                return string, set(imports)\n-        if hasattr(self.value, \"__module__\"):\n-            module = self.value.__module__\n-            if module == builtins.__name__:\n-                return self.value.__name__, set()\n-            else:\n-                return \"%s.%s\" % (module, self.value.__name__), {\"import %s\" % module}\n-\n-\n-class UUIDSerializer(BaseSerializer):\n-    def serialize(self):\n-        return \"uuid.%s\" % repr(self.value), {\"import uuid\"}\n-\n-\n-class Serializer:\n-    _registry = {\n-        # Some of these are order-dependent.\n-        frozenset: FrozensetSerializer,\n-        list: SequenceSerializer,\n-        set: SetSerializer,\n-        tuple: TupleSerializer,\n-        dict: DictionarySerializer,\n-        models.Choices: ChoicesSerializer,\n-        enum.Enum: EnumSerializer,\n-        datetime.datetime: DatetimeDatetimeSerializer,\n-        (datetime.date, datetime.timedelta, datetime.time): DateTimeSerializer,\n-        SettingsReference: SettingsReferenceSerializer,\n-        float: FloatSerializer,\n-        (bool, int, type(None), bytes, str, range): BaseSimpleSerializer,\n-        decimal.Decimal: DecimalSerializer,\n-        (functools.partial, functools.partialmethod): FunctoolsPartialSerializer,\n-        (types.FunctionType, types.BuiltinFunctionType, types.MethodType): FunctionTypeSerializer,\n-        collections.abc.Iterable: IterableSerializer,\n-        (COMPILED_REGEX_TYPE, RegexObject): RegexSerializer,\n-        uuid.UUID: UUIDSerializer,\n-    }\n-\n-    @classmethod\n-    def register(cls, type_, serializer):\n-        if not issubclass(serializer, BaseSerializer):\n-            raise ValueError(\"'%s' must inherit from 'BaseSerializer'.\" % serializer.__name__)\n-        cls._registry[type_] = serializer\n-\n-    @classmethod\n-    def unregister(cls, type_):\n-        cls._registry.pop(type_)\n-\n-\n-def serializer_factory(value):\n-    if isinstance(value, Promise):\n-        value = str(value)\n-    elif isinstance(value, LazyObject):\n-        # The unwrapped value is returned as the first item of the arguments\n-        # tuple.\n-        value = value.__reduce__()[1][0]\n-\n-    if isinstance(value, models.Field):\n-        return ModelFieldSerializer(value)\n-    if isinstance(value, models.manager.BaseManager):\n-        return ModelManagerSerializer(value)\n-    if isinstance(value, Operation):\n-        return OperationSerializer(value)\n-    if isinstance(value, type):\n-        return TypeSerializer(value)\n-    # Anything that knows how to deconstruct itself.\n-    if hasattr(value, 'deconstruct'):\n-        return DeconstructableSerializer(value)\n-    for type_, serializer_cls in Serializer._registry.items():\n-        if isinstance(value, type_):\n-            return serializer_cls(value)\n-    raise ValueError(\n-        \"Cannot serialize: %r\\nThere are some values Django cannot serialize into \"\n-        \"migration files.\\nFor more, see https://docs.djangoproject.com/en/%s/\"\n-        \"topics/migrations/#migration-serializing\" % (value, get_docs_version())\n-    )\n+        name = self.value.name\n+        imports = {'import %s' % module}\n+        return \"%s.%s['%s']\" % (module, enum_class.__name__, name), imports\ndiff --git a/repro_direct_enumserializer.py b/repro_direct_enumserializer.py\nnew file mode 100644\nindex 0000000000..23d3c92126\n--- /dev/null\n+++ b/repro_direct_enumserializer.py\n@@ -0,0 +1,17 @@\n+\n+from enum import Enum\n+from django.db.migrations.serializer import EnumSerializer\n+\n+class Status(Enum):\n+    GOOD = 'Good'\n+    BAD = 'Bad'\n+\n+def test():\n+    val = Status.GOOD\n+    ser = EnumSerializer(val)\n+    s, imports = ser.serialize()\n+    print(\"SERIAL:\", s)\n+    print(\"IMPORTS:\", sorted(list(imports)))\n+\n+if __name__ == '__main__':\n+    test()\ndiff --git a/repro_enum_serializer.py b/repro_enum_serializer.py\nnew file mode 100644\nindex 0000000000..bf294577e5\n--- /dev/null\n+++ b/repro_enum_serializer.py\n@@ -0,0 +1,17 @@\n+\n+from enum import Enum\n+\n+class Status(Enum):\n+    GOOD = Good\n+    BAD = Bad\n+\n+def test():\n+    val = Status.GOOD\n+    from django.db.migrations.serializer import serializer_factory\n+    ser = serializer_factory(val)\n+    s, imports = ser.serialize()\n+    print(s)\n+\n+if __name__ == __main__:\n+    test()\n+\n\n"
  },
  "django__django-11848": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11848",
    "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..efebf601a2 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,11 +176,14 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n+            now_year = datetime.datetime.utcnow().year\n+            year_guess = (now_year // 100) * 100 + year\n+            if year_guess > now_year + 50:\n+                year = year_guess - 100\n             else:\n-                year += 1900\n+                year = year_guess\n         month = MONTHS.index(m.group('mon').lower()) + 1\n+        month = MONTHS.index(m.group('mon').lower()) + 1\\n\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n         min = int(m.group('min'))\n\n"
  },
  "django__django-11880": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11880",
    "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 03cd8af8d7..18007accab 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -199,6 +199,7 @@ class Field:\n         result = copy.copy(self)\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n+        result.error_messages = copy.deepcopy(self.error_messages, memo)\n         result.validators = self.validators[:]\n         return result\n \ndiff --git a/test_repro_field_deepcopy.py b/test_repro_field_deepcopy.py\nnew file mode 100644\nindex 0000000000..b1297b69ef\n--- /dev/null\n+++ b/test_repro_field_deepcopy.py\n@@ -0,0 +1,19 @@\n+\n+import copy\n+\n+try:\n+    from django.forms import fields\n+except Exception as e:\n+    print(\"IMPORT_FAIL\", e)\n+    raise SystemExit(1)\n+\n+field1 = fields.CharField(error_messages={'required': 'Please fill this field.'})\n+field2 = copy.deepcopy(field1)\n+\n+print('ids_different', id(field1.error_messages) != id(field2.error_messages))\n+\n+# mutate in one instance\n+field1.error_messages['required'] = 'Please fill out this field.'\n+\n+print('field2_unchanged', field2.error_messages['required'] == 'Please fill this field.')\n+print('field1_changed', field1.error_messages['required'])\n\n"
  },
  "django__django-11885": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11885",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..650876a0dd 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -310,10 +310,18 @@ class Collector:\n                     )\n \n             # fast deletes\n+            # fast deletes: batch by model to minimize queries\n+            from collections import defaultdict\n+            pk_lists = defaultdict(set)\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n-\n+                pks = list(qs.values_list('pk', flat=True))\n+                pk_lists[qs.model].update(pks)\n+            for model, pks in pk_lists.items():\n+                if not pks:\n+                    continue\n+                pk_list = list(pks)\n+                count = sql.DeleteQuery(model).delete_batch(pk_list, self.using)\n+                deleted_counter[model._meta.label] += count\n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n                 for (field, value), instances in instances_for_fieldvalues.items():\n\n"
  },
  "django__django-11951": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11951",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 794e0faae7..3511c66bf4 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -471,6 +471,9 @@ class QuerySet:\n         fields = opts.concrete_fields\n         objs = list(objs)\n         self._populate_pk_values(objs)\n+\n+        max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n+        batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n         with transaction.atomic(using=self.db, savepoint=False):\n             objs_with_pk, objs_without_pk = partition(lambda o: o.pk is None, objs)\n             if objs_with_pk:\ndiff --git a/test_repro_bulk_create_batch_size_logic.py b/test_repro_bulk_create_batch_size_logic.py\nnew file mode 100644\nindex 0000000000..a4d30f94a8\n--- /dev/null\n+++ b/test_repro_bulk_create_batch_size_logic.py\n@@ -0,0 +1,17 @@\n+\n+def compute_batch_size(batch_size, max_batch_size):\n+    return (min(batch_size, max_batch_size) if batch_size else max_batch_size)\n+\n+def main():\n+    cases = [\n+        (None, 20),\n+        (5, 20),\n+        (25, 20),\n+        (10, 7),\n+        (0, 15),\n+    ]\n+    for batch_size, max_batch_size in cases:\n+        print(f\"batch_size={batch_size}, max_batch_size={max_batch_size} -> result={compute_batch_size(batch_size, max_batch_size)}\")\n+\n+if __name__ == '__main__':\n+    main()\n\n"
  },
  "django__django-11964": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11964",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..d7e5a6eb2c 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -64,11 +64,15 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n \n \n class IntegerChoices(int, Choices):\n+    def __str__(self):\n+        return str(self.value)\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\n \n \n class TextChoices(str, Choices):\n+    def __str__(self):\n+        return self.value\n     \"\"\"Class for creating enumerated string choices.\"\"\"\n \n     def _generate_next_value_(name, start, count, last_values):\n\n"
  },
  "django__django-11999": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-11999",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..ef91e71d54 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,9 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            attr_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, attr_name):\n+                setattr(cls, attr_name, partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\ndiff --git a/test_repro_patch.py b/test_repro_patch.py\nnew file mode 100644\nindex 0000000000..b908307bdf\n--- /dev/null\n+++ b/test_repro_patch.py\n@@ -0,0 +1,38 @@\n+\n+class FakeField:\n+    def __init__(self, name, choices=None):\n+        self.name = name\n+        self.choices = choices\n+        self.attname = name\n+        self.descriptor_class = lambda cls: None\n+    def _get_FIELD_display(self, field):\n+        return f\"DISPLAY-{field.name}\"\n+\n+class M1:\n+    def _get_FIELD_display(self, field):\n+        return f\"DISPLAY-{field.name}\"\n+\n+def patch_simulation(cls, field):\n+    attr_name = 'get_%s_display' % field.name\n+    if not hasattr(cls, attr_name):\n+        from functools import partialmethod\n+        setattr(cls, attr_name, partialmethod(cls._get_FIELD_display, field=field))\n+    return getattr(cls, attr_name, None)\n+\n+field = FakeField('foo_bar', choices=[(1, 'foo'), (2, 'bar')])\n+\n+# Case 1: No user override - should inject default get_foo_bar_display\n+display1 = patch_simulation(M1, field)\n+print(\"Case1: has get_foo_bar_display after patch?\", hasattr(M1, 'get_foo_bar_display'))\n+print(\"Case1: display1 callable?\", callable(display1))\n+\n+# Case 2: User override exists - patch should NOT override it\n+class M2:\n+    def _get_FIELD_display(self, field):\n+        return f\"DISPLAY-{field.name}\"\n+    def get_foo_bar_display(self):\n+        return \"CUSTOM\"\n+\n+display2 = patch_simulation(M2, field)\n+print(\"Case2: has get_foo_bar_display after patch?\", hasattr(M2, 'get_foo_bar_display'))\n+print(\"Case2: display2 present?\", display2 is not None)\n\n"
  },
  "django__django-12039": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12039",
    "model_patch": "diff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex 44e49806f8..4558bd9446 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -110,18 +110,17 @@ class IndexColumns(Columns):\n \n     def __str__(self):\n         def col_str(column, idx):\n-            # Index.__init__() guarantees that self.opclasses is the same\n-            # length as self.columns.\n             col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n             try:\n-                col = '{} {}'.format(col, self.col_suffixes[idx])\n+                suffix = self.col_suffixes[idx]\n             except IndexError:\n-                pass\n+                suffix = ''\n+            if suffix:\n+                col = '{} {}'.format(col, suffix)\n             return col\n \n         return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n \n-\n class ForeignKeyName(TableColumns):\n     \"\"\"Hold a reference to a foreign key name.\"\"\"\n \n\n"
  },
  "django__django-12050": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12050",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ea51912e8b..ea3a570059 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,10 @@ class Query(BaseExpression):\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            if isinstance(value, list):\n+                value = resolved_values\n+            else:\n+                value = tuple(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\ndiff --git a/testbed/reproduce_resolve_lookup_value_type.py b/testbed/reproduce_resolve_lookup_value_type.py\nnew file mode 100644\nindex 0000000000..653835332d\n--- /dev/null\n+++ b/testbed/reproduce_resolve_lookup_value_type.py\n@@ -0,0 +1,14 @@\n+\n+def simulate(value):\n+    resolved_values = []\n+    for sub_value in value:\n+        resolved_values.append(sub_value)\n+    if isinstance(value, list):\n+        value = resolved_values\n+    else:\n+        value = tuple(resolved_values)\n+    return value\n+\n+if __name__ == \"__main__\":\n+    print(simulate([1, 2, 3]))\n+    print(simulate((1, 2, 3)))\n\n"
  },
  "django__django-12143": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12143",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 137e6faa0f..effc5e9296 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,7 @@ class ModelAdmin(BaseModelAdmin):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(self.model._meta.pk.name)))\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\ndiff --git a/edge_regex_test.py b/edge_regex_test.py\nnew file mode 100644\nindex 0000000000..7102f2297c\n--- /dev/null\n+++ b/edge_regex_test.py\n@@ -0,0 +1,23 @@\n+\n+import re\n+\n+def test_pattern_with_prefix(prefix, pk='id'):\n+    pat = r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(pk))\n+    rx = re.compile(pat)\n+    tests = [\n+        f\"{prefix}-123-{pk}\",\n+        f\"{prefix}-001-{pk}\",\n+        f\"{prefix}-abc-{pk}\",\n+        f\"{prefix}x-123-{pk}\",\n+        f\"not{prefix}-123-{pk}\",\n+    ]\n+    return [(s, bool(rx.match(s))) for s in tests]\n+\n+def main():\n+    prefixes = ['a+b', 'foo.bar', 'baz[qux]', 'name(with)parens', 'simple']\n+    for p in prefixes:\n+        results = test_pattern_with_prefix(p)\n+        print(p, results)\n+\n+if __name__ == '__main__':\n+    main()\ndiff --git a/repro_escape_fix.py b/repro_escape_fix.py\nnew file mode 100644\nindex 0000000000..b09199f5ed\n--- /dev/null\n+++ b/repro_escape_fix.py\n@@ -0,0 +1,22 @@\n+\n+import re\n+\n+def test_unsafe_vs_safe():\n+    prefix = \"a+b\"\n+    pk = \"id\"\n+    input_str = \"ab-123-id\"\n+\n+    unsafe_pattern = r'{}-\\d+-{}$'.format(prefix, pk)\n+    safe_pattern = r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(pk))\n+\n+    p_unsafe = re.compile(unsafe_pattern)\n+    p_safe = re.compile(safe_pattern)\n+\n+    r1 = bool(p_unsafe.match(input_str))\n+    r2 = bool(p_safe.match(input_str))\n+\n+    print('unsafe_match=' + str(r1))\n+    print('safe_match=' + str(r2))\n+\n+if __name__ == '__main__':\n+    test_unsafe_vs_safe()\n\n"
  },
  "django__django-12155": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12155",
    "model_patch": "diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 4c0e7e2a56..aa663ead5b 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,7 +34,7 @@ def trim_docstring(docstring):\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n+    indent = min((len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip()), default=0)\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \ndiff --git a/test_repro_trim_docstring.py b/test_repro_trim_docstring.py\nnew file mode 100644\nindex 0000000000..adeb98eb3e\n--- /dev/null\n+++ b/test_repro_trim_docstring.py\n@@ -0,0 +1,8 @@\n+def mimic_trim_docstring(docstring):\n+    lines = docstring.expandtabs().splitlines()\n+    indent = min((len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip()), default=0)\n+    trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n+    return \"\\n\".join(trimmed).strip()\n+\n+doc = \"first line\\n    second line\\n      third line\"\n+print(mimic_trim_docstring(doc))\n\\ No newline at end of file\n\n"
  },
  "django__django-12193": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12193",
    "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 6fe220bea7..522d8a439b 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -224,33 +224,13 @@ class Widget(metaclass=MediaDefiningClass):\n             return formats.localize_input(value)\n         return str(value)\n \n-    def get_context(self, name, value, attrs):\n-        context = {}\n-        context['widget'] = {\n-            'name': name,\n-            'is_hidden': self.is_hidden,\n-            'required': self.is_required,\n-            'value': self.format_value(value),\n-            'attrs': self.build_attrs(self.attrs, attrs),\n-            'template_name': self.template_name,\n-        }\n-        return context\n-\n-    def render(self, name, value, attrs=None, renderer=None):\n-        \"\"\"Render the widget as an HTML string.\"\"\"\n-        context = self.get_context(name, value, attrs)\n-        return self._render(self.template_name, context, renderer)\n+        def get_context(self, name, value, attrs):\n+    if self.check_test(value):\n+        attrs = {} if attrs is None else attrs.copy()\n+        attrs['checked'] = True\n+    return super().get_context(name, value, attrs)\n \n-    def _render(self, template_name, context, renderer=None):\n-        if renderer is None:\n-            renderer = get_default_renderer()\n-        return mark_safe(renderer.render(template_name, context))\n-\n-    def build_attrs(self, base_attrs, extra_attrs=None):\n-        \"\"\"Build an attribute dictionary.\"\"\"\n-        return {**base_attrs, **(extra_attrs or {})}\n-\n-    def value_from_datadict(self, data, files, name):\n+def value_from_datadict(self, data, files, name):\n         \"\"\"\n         Given a dictionary of data and this widget's name, return the value\n         of this widget or None if it's not provided.\n@@ -510,8 +490,6 @@ class CheckboxInput(Input):\n \n     def __init__(self, attrs=None, check_test=None):\n         super().__init__(attrs)\n-        # check_test is a callable that takes a value and returns True\n-        # if the checkbox should be checked for that value.\n         self.check_test = boolean_check if check_test is None else check_test\n \n     def format_value(self, value):\n@@ -522,26 +500,20 @@ class CheckboxInput(Input):\n \n     def get_context(self, name, value, attrs):\n         if self.check_test(value):\n-            if attrs is None:\n-                attrs = {}\n+            attrs = {} if attrs is None else attrs.copy()\n             attrs['checked'] = True\n         return super().get_context(name, value, attrs)\n \n     def value_from_datadict(self, data, files, name):\n         if name not in data:\n-            # A missing value means False because HTML form submission does not\n-            # send results for unselected checkboxes.\n             return False\n         value = data.get(name)\n-        # Translate true and false strings to boolean values.\n         values = {'true': True, 'false': False}\n         if isinstance(value, str):\n             value = values.get(value.lower(), value)\n         return bool(value)\n \n     def value_omitted_from_data(self, data, files, name):\n-        # HTML checkboxes don't appear in POST data if not checked, so it's\n-        # never known if the value is actually omitted.\n         return False\n \n \n\n"
  },
  "django__django-12209": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12209",
    "model_patch": "diff --git a/dyn_apps/myapp/__init__.py b/dyn_apps/myapp/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/dyn_apps/myapp/apps.py b/dyn_apps/myapp/apps.py\nnew file mode 100644\nindex 0000000000..b130217533\n--- /dev/null\n+++ b/dyn_apps/myapp/apps.py\n@@ -0,0 +1,4 @@\n+from django.apps import AppConfig\n+class MyAppConfig(AppConfig):\n+    name = 'myapp'\n+    label = 'myapp'\ndiff --git a/dyn_apps/myapp/models.py b/dyn_apps/myapp/models.py\nnew file mode 100644\nindex 0000000000..0217dc853a\n--- /dev/null\n+++ b/dyn_apps/myapp/models.py\n@@ -0,0 +1,8 @@\n+from django.db import models\n+import uuid\n+\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n+    name = models.CharField(blank=True, max_length=100)\n+    class Meta:\n+        app_label = 'myapp'\ndiff --git a/reproduce_dynamic_django_app.py b/reproduce_dynamic_django_app.py\nnew file mode 100644\nindex 0000000000..121543ea76\n--- /dev/null\n+++ b/reproduce_dynamic_django_app.py\n@@ -0,0 +1,86 @@\n+\n+import sys, uuid\n+import types\n+from textwrap import dedent\n+\n+# Build dynamic Django app modules: myapp and myapp.models\n+myapp = types.ModuleType(\"myapp\")\n+myapp.__path__ = []  # mark as package\n+myapp_models = types.ModuleType(\"myapp.models\")\n+\n+# Minimal Django model\n+from django.db import models\n+\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = \"myapp\"\n+\n+myapp_models.Sample = Sample\n+\n+# App config for the dynamic app\n+myapp_apps = types.ModuleType(\"myapp.apps\")\n+from django.apps import AppConfig\n+class MyAppConfig(AppConfig):\n+    name = \"myapp\"\n+    label = \"myapp\"\n+myapp_apps.MyAppConfig = MyAppConfig\n+\n+import sys\n+sys.modules[\"myapp\"] = myapp\n+sys.modules[\"myapp.models\"] = myapp_models\n+sys.modules[\"myapp.apps\"] = myapp_apps\n+\n+# Django settings for an isolated in-memory DB\n+from django.conf import settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        SECRET_KEY=\"test-secret\",\n+        INSTALLED_APPS=[\"myapp\"],\n+        DATABASES={\n+            \"default\": {\n+                \"ENGINE\": \"django.db.backends.sqlite3\",\n+                \"NAME\": \":memory:\",\n+            }\n+        },\n+        MIDDLEWARE=[],\n+        USE_TZ=True,\n+        TIME_ZONE=\"UTC\",\n+    )\n+\n+# Initialize Django\n+import django\n+django.setup()\n+\n+# Access the dynamically defined model\n+SampleDynamic = myapp_models.Sample\n+\n+# Create the table for the dynamically defined model\n+from django.db import connection\n+with connection.schema_editor() as editor:\n+    editor.create_model(SampleDynamic)\n+\n+# Reproduce the sequence:\n+# 1) s0 = Sample.objects.create()\n+s0 = SampleDynamic.objects.create()\n+# 2) s1 = Sample(pk=s0.pk, name='Test 1')\n+s1 = SampleDynamic(pk=s0.pk, name=\"Test 1\")\n+# 3) s1.save()\n+try:\n+    s1.save()\n+    save_result = \"save_succeeded\"\n+except Exception as e:\n+    save_result = f\"save_failed: {type(e).__name__}: {e}\"\n+\n+# Inspect resulting rows\n+rows = list(SampleDynamic.objects.values(\"id\", \"name\"))\n+row_count = SampleDynamic.objects.count()\n+\n+print(\"s0.pk:\", s0.pk)\n+print(\"s1.pk:\", s1.pk)\n+print(\"save_result:\", save_result)\n+print(\"row_count:\", row_count)\n+print(\"rows:\", rows)\ndiff --git a/reproduce_dynamic_django_app_fixed.py b/reproduce_dynamic_django_app_fixed.py\nnew file mode 100644\nindex 0000000000..2f6f951417\n--- /dev/null\n+++ b/reproduce_dynamic_django_app_fixed.py\n@@ -0,0 +1,74 @@\n+\n+import sys, uuid\n+import types\n+from textwrap import dedent\n+\n+# Configure Django settings before any Django import\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY=\"test-secret\",\n+    INSTALLED_APPS=[\"myapp\"],\n+    DATABASES={\n+        \"default\": {\n+            \"ENGINE\": \"django.db.backends.sqlite3\",\n+            \"NAME\": \":memory:\",\n+        }\n+    },\n+    MIDDLEWARE=[],\n+    USE_TZ=True,\n+    TIME_ZONE=\"UTC\",\n+)\n+\n+import django\n+django.setup()\n+\n+# Build dynamic Django app modules: myapp and myapp.models\n+myapp = types.ModuleType(\"myapp\")\n+myapp.__path__ = []  # mark as package\n+myapp_models = types.ModuleType(\"myapp.models\")\n+\n+# Define a minimal model in a dynamic context\n+from django.db import models\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n+    name = models.CharField(blank=True, max_length=100)\n+    class Meta:\n+        app_label = \"myapp\"\n+\n+myapp_models.Sample = Sample\n+\n+# App config for the dynamic app\n+myapp_apps = types.ModuleType(\"myapp.apps\")\n+from django.apps import AppConfig\n+class MyAppConfig(AppConfig):\n+    name = \"myapp\"\n+    label = \"myapp\"\n+myapp_apps.MyAppConfig = MyAppConfig\n+\n+sys.modules[\"myapp\"] = myapp\n+sys.modules[\"myapp.models\"] = myapp_models\n+sys.modules[\"myapp.apps\"] = myapp_apps\n+\n+# Create the database table\n+from django.db import connection\n+with connection.schema_editor() as editor:\n+    editor.create_model(Sample)\n+\n+# Reproduce the sequence:\n+s0 = Sample.objects.create()\n+s1 = Sample(pk=s0.pk, name=\"Test 1\")\n+try:\n+    s1.save()\n+    save_result = \"save_succeeded\"\n+except Exception as e:\n+    save_result = f\"save_failed: {type(e).__name__}: {e}\"\n+\n+rows = list(Sample.objects.values(\"id\", \"name\"))\n+row_count = Sample.objects.count()\n+\n+print(\"s0.pk:\", s0.pk)\n+print(\"s1.pk:\", s1.pk)\n+print(\"save_result:\", save_result)\n+print(\"row_count:\", row_count)\n+print(\"rows:\", rows)\ndiff --git a/reproduce_dynamic_django_app_fixed2.py b/reproduce_dynamic_django_app_fixed2.py\nnew file mode 100644\nindex 0000000000..944b01b41f\n--- /dev/null\n+++ b/reproduce_dynamic_django_app_fixed2.py\n@@ -0,0 +1,80 @@\n+\n+import os, sys, uuid\n+\n+# Create dynamic app path and package\n+BASE = \"/testbed/dyn_apps\"\n+APP_PACKAGE_PATH = os.path.join(BASE, \"myapp\")\n+os.makedirs(APP_PACKAGE_PATH, exist_ok=True)\n+\n+# __init__.py for package\n+with open(os.path.join(APP_PACKAGE_PATH, \"__init__.py\"), \"w\") as f:\n+    f.write(\"\")\n+\n+# apps.py defining AppConfig\n+with open(os.path.join(APP_PACKAGE_PATH, \"apps.py\"), \"w\") as f:\n+    f.write(\n+        \"from django.apps import AppConfig\\n\"\n+        \"class MyAppConfig(AppConfig):\\n\"\n+        \"    name = 'myapp'\\n\"\n+        \"    label = 'myapp'\\n\"\n+    )\n+\n+# models.py with Sample model\n+with open(os.path.join(APP_PACKAGE_PATH, \"models.py\"), \"w\") as f:\n+    f.write(\n+        \"from django.db import models\\\\n\"\n+        \"import uuid\\\\n\"\n+        \"class Sample(models.Model):\\\\n\"\n+        \"    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\\\\n\"\n+        \"    name = models.CharField(blank=True, max_length=100)\\\\n\"\n+        \"    class Meta:\\\\n\"\n+        \"        app_label = 'myapp'\\\\n\"\n+    )\n+\n+# Ensure the new package is importable\n+sys.path.insert(0, BASE)\n+\n+# Django setup\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY=\"test-secret\",\n+    INSTALLED_APPS=[\"myapp\"],\n+    DATABASES={\n+        \"default\": {\n+            \"ENGINE\": \"django.db.backends.sqlite3\",\n+            \"NAME\": \":memory:\",\n+        }\n+    },\n+    MIDDLEWARE=[],\n+    USE_TZ=True,\n+    TIME_ZONE=\"UTC\",\n+)\n+import django\n+django.setup()\n+\n+# Import model after setup\n+from myapp.models import Sample\n+\n+# Create table for the dynamic model\n+from django.db import connection\n+with connection.schema_editor() as editor:\n+    editor.create_model(Sample)\n+\n+# Reproduce the sequence\n+s0 = Sample.objects.create()\n+s1 = Sample(pk=s0.pk, name=\"Test 1\")\n+try:\n+    s1.save()\n+    save_result = \"save_succeeded\"\n+except Exception as e:\n+    save_result = f\"save_failed: {type(e).__name__}: {e}\"\n+\n+rows = list(Sample.objects.values(\"id\", \"name\"))\n+row_count = Sample.objects.count()\n+\n+print(\"s0.pk:\", s0.pk)\n+print(\"s1.pk:\", s1.pk)\n+print(\"save_result:\", save_result)\n+print(\"row_count:\", row_count)\n+print(\"rows:\", rows)\ndiff --git a/reproduce_dynamic_django_app_fixed4.py b/reproduce_dynamic_django_app_fixed4.py\nnew file mode 100644\nindex 0000000000..81a78b6bb9\n--- /dev/null\n+++ b/reproduce_dynamic_django_app_fixed4.py\n@@ -0,0 +1,80 @@\n+\n+import os, sys, uuid\n+\n+# Create dynamic app path and package\n+BASE = \"/testbed/dyn_apps\"\n+APP_PATH = os.path.join(BASE, \"myapp\")\n+os.makedirs(APP_PATH, exist_ok=True)\n+\n+# __init__.py for package\n+with open(os.path.join(APP_PATH, \"__init__.py\"), \"w\") as f:\n+    f.write(\"\")\n+\n+# apps.py defining AppConfig\n+with open(os.path.join(APP_PATH, \"apps.py\"), \"w\") as f:\n+    f.write(\n+        \"from django.apps import AppConfig\\n\"\n+        \"class MyAppConfig(AppConfig):\\n\"\n+        \"    name = 'myapp'\\n\"\n+        \"    label = 'myapp'\\n\"\n+    )\n+\n+# models.py with Sample model\n+with open(os.path.join(APP_PATH, \"models.py\"), \"w\") as f:\n+    f.write(\n+        \"from django.db import models\\n\"\n+        \"import uuid\\n\\n\"\n+        \"class Sample(models.Model):\\n\"\n+        \"    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\\n\"\n+        \"    name = models.CharField(blank=True, max_length=100)\\n\"\n+        \"    class Meta:\\n\"\n+        \"        app_label = 'myapp'\\n\"\n+    )\n+\n+# Ensure the new package is importable\n+sys.path.insert(0, \"/testbed/dyn_apps\")\n+\n+# Django setup\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY=\"test-secret\",\n+    INSTALLED_APPS=[\"myapp\"],\n+    DATABASES={\n+        \"default\": {\n+            \"ENGINE\": \"django.db.backends.sqlite3\",\n+            \"NAME\": \":memory:\",\n+        }\n+    },\n+    MIDDLEWARE=[],\n+    USE_TZ=True,\n+    TIME_ZONE=\"UTC\",\n+)\n+import django\n+django.setup()\n+\n+# Import model after setup\n+from myapp.models import Sample\n+\n+# Create the database table\n+from django.db import connection\n+with connection.schema_editor() as editor:\n+    editor.create_model(Sample)\n+\n+# Reproduce the sequence\n+s0 = Sample.objects.create()\n+s1 = Sample(pk=s0.pk, name=\"Test 1\")\n+try:\n+    s1.save()\n+    save_result = \"save_succeeded\"\n+except Exception as e:\n+    save_result = f\"save_failed: {type(e).__name__}: {e}\"\n+\n+rows = list(Sample.objects.values(\"id\", \"name\"))\n+row_count = Sample.objects.count()\n+\n+print(\"s0.pk:\", s0.pk)\n+print(\"s1.pk:\", s1.pk)\n+print(\"save_result:\", save_result)\n+print(\"row_count:\", row_count)\n+print(\"rows:\", rows)\n\n"
  },
  "django__django-12262": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12262",
    "model_patch": "diff --git a/django/template/library.py b/django/template/library.py\nindex 20bc86dac8..2f74556268 100644\n--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -261,7 +261,7 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n         if kwarg:\n             # The kwarg was successfully extracted\n             param, value = kwarg.popitem()\n-            if param not in params and param not in unhandled_kwargs and varkw is None:\n+            if param not in params and param not in kwonly and varkw is None:\n                 # An unexpected keyword argument was supplied\n                 raise TemplateSyntaxError(\n                     \"'%s' received unexpected keyword argument '%s'\" %\ndiff --git a/test_repro_kwonly.py b/test_repro_kwonly.py\nnew file mode 100644\nindex 0000000000..76651db3dd\n--- /dev/null\n+++ b/test_repro_kwonly.py\n@@ -0,0 +1,17 @@\n+# Reproduction script for keyword-only args with defaults in template-tag style\n+from django.template import Library\n+\n+register = Library()\n+\n+@register.simple_tag\n+def hello(*, greeting='hello'):\n+    return f'{greeting} world'\n+\n+# Minimal usage printout (note: this does not render through the full template engine here)\n+# Intended to demonstrate that the function signature includes a keyword-only arg with default.\n+try:\n+    import inspect\n+    sig = inspect.signature(hello)\n+    print(\"hello parameters:\", [p.name for p in sig.parameters.values()])\n+except Exception as e:\n+    print(\"Reproduction quick-check failed:\", e)\n\n"
  },
  "django__django-12273": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12273",
    "model_patch": ""
  },
  "django__django-12276": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12276",
    "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 338d54d72f..c99d90402d 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -381,15 +381,14 @@ class FileInput(Input):\n         return\n \n     def value_from_datadict(self, data, files, name):\n-        \"File widgets take data from FILES, not POST\"\n+        # File widgets take data from FILES, not POST\n         return files.get(name)\n \n     def value_omitted_from_data(self, data, files, name):\n         return name not in files\n \n-\n-FILE_INPUT_CONTRADICTION = object()\n-\n+    def use_required_attribute(self, initial):\n+        return not initial\n \n class ClearableFileInput(FileInput):\n     clear_checkbox_label = _('Clear')\n@@ -452,7 +451,7 @@ class ClearableFileInput(FileInput):\n         return upload\n \n     def use_required_attribute(self, initial):\n-        return super().use_required_attribute(initial) and not initial\n+    return super().use_required_attribute(initial)\n \n     def value_omitted_from_data(self, data, files, name):\n         return (\n\n"
  },
  "django__django-12304": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12304",
    "model_patch": "diff --git a/django/conf/__init__.py b/django/conf/__init__.py\nindex ec7efadf46..dc35d9e58c 100644\n--- a/django/conf/__init__.py\n+++ b/django/conf/__init__.py\n@@ -47,21 +47,15 @@ class LazySettings(LazyObject):\n     Django uses the settings module pointed to by DJANGO_SETTINGS_MODULE.\n     \"\"\"\n     def _setup(self, name=None):\n-        \"\"\"\n-        Load the settings module pointed to by the environment variable. This\n-        is used the first time settings are needed, if the user hasn't\n-        configured settings manually.\n-        \"\"\"\n-        settings_module = os.environ.get(ENVIRONMENT_VARIABLE)\n-        if not settings_module:\n-            desc = (\"setting %s\" % name) if name else \"settings\"\n-            raise ImproperlyConfigured(\n-                \"Requested %s, but settings are not configured. \"\n-                \"You must either define the environment variable %s \"\n-                \"or call settings.configure() before accessing settings.\"\n-                % (desc, ENVIRONMENT_VARIABLE))\n-\n-        self._wrapped = Settings(settings_module)\n+    settings_module = os.environ.get(ENVIRONMENT_VARIABLE)\n+    if not settings_module:\n+        desc = (\"setting %s\" % name) if name else \"settings\"\n+        raise ImproperlyConfigured(\n+            \"Requested %s, but settings are not configured. \"\n+            \"You must either define the environment variable %s \"\n+            \"or call settings.configure() before accessing settings.\" %\n+            (desc, ENVIRONMENT_VARIABLE))\n+    self._wrapped = Settings(settings_module)\n \n     def __repr__(self):\n         # Hardcode the class name as otherwise it yields 'Settings'.\ndiff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex f48143ddaf..4e13147b89 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -61,6 +61,7 @@ class ChoicesMeta(enum.EnumMeta):\n class Choices(enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated choices.\"\"\"\n \n+    do_not_call_in_templates = True\n     def __str__(self):\n         \"\"\"\n         Use value when cast to str, so that Choices set as model instance\ndiff --git a/sitecustomize.py b/sitecustomize.py\nnew file mode 100644\nindex 0000000000..0783d8cb60\n--- /dev/null\n+++ b/sitecustomize.py\n@@ -0,0 +1,20 @@\n+import os\n+import sys\n+import types\n+\n+if not os.environ.get('DJANGO_SETTINGS_MODULE'):\n+    os.environ['DJANGO_SETTINGS_MODULE'] = 'default_settings'\n+if 'default_settings' not in sys.modules:\n+    mod = types.ModuleType('default_settings')\n+    mod.SECRET_KEY = 'dummy'\n+    mod.DEBUG = True\n+    mod.ALLOWED_HOSTS = ['*']\n+    mod.USE_I18N = False\n+    mod.USE_L10N = False\n+    mod.USE_TZ = True\n+    mod.TIME_ZONE = 'UTC'\n+    mod.LANGUAGE_CODE = 'en-us'\n+    mod.INSTALLED_APPS = []\n+    mod.MIDDLEWARE = []\n+    mod.TEMPLATES = []\n+    sys.modules['default_settings'] = mod\n\n"
  },
  "django__django-12308": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12308",
    "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex e4ddc8f017..fd4e42c56f 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -1,5 +1,4 @@\n-import datetime\n-import decimal\n+    from django.db.models import JSONField as _JSONField\\n    if _JSONField is not None and isinstance(field, _JSONField):\\n        try:\\n            prepared = field.prepare_value(value)\\n            if prepared is not None:\\n                return prepared\\n        except Exception:\\n            pass\\nimport decimal\n from collections import defaultdict\n \n from django.core.exceptions import FieldDoesNotExist\n\n"
  },
  "django__django-12325": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12325",
    "model_patch": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..d03315760a 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -237,14 +237,18 @@ class Options:\n                 model.add_to_class('_order', OrderWrt())\n         else:\n             self.order_with_respect_to = None\n-\n         if self.pk is None:\n             if self.parents:\n                 # Promote the first parent link in lieu of adding yet another\n                 # field.\n-                field = next(iter(self.parents.values()))\n-                # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                field = None\n+                        for f in self.parents.values():\n+                    if getattr(f.remote_field, 'parent_link', False):\n+                        field = f\n+                        break\n+                if field is None and len(self.parents) == 1:\n+                    field = next(iter(self.parents.values()))\n+                # Look for a local field with the same name as the first parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n@@ -258,6 +262,9 @@ class Options:\n             else:\n                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                 model.add_to_class('id', auto)\n+            else:\n+                auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+                model.add_to_class('id', auto)\n \n     def add_manager(self, manager):\n         self.local_managers.append(manager)\ndiff --git a/fix_indent_mti.py b/fix_indent_mti.py\nnew file mode 100644\nindex 0000000000..7b14cd5abe\n--- /dev/null\n+++ b/fix_indent_mti.py\n@@ -0,0 +1,15 @@\n+p = 'django/db/models/options.py'\n+with open(p, 'r', encoding='utf-8') as f:\n+    lines = f.readlines()\n+\n+for idx in range(len(lines) - 1):\n+    if 'field = None' in lines[idx] and 'for f in self.parents.values()' in lines[idx + 1]:\n+        lines[idx + 1] = lines[idx + 1].replace('        for f in self.parents.values():', '                for f in self.parents.values():', 1)\n+        break\n+else:\n+    print(\"pattern not found\")\n+    raise SystemExit(1)\n+\n+with open(p, 'w', encoding='utf-8') as f:\n+    f.writelines(lines)\n+print('patched')\ndiff --git a/patch_script.py b/patch_script.py\nnew file mode 100644\nindex 0000000000..2261a70983\n--- /dev/null\n+++ b/patch_script.py\n@@ -0,0 +1,17 @@\n+p = 'django/db/models/options.py'\n+with open(p, 'r', encoding='utf-8') as f:\n+    s = f.read()\n+old = \"field = next(iter(self.parents.values()))\"\n+replacement = (\n+\"field = None\\n\"\n+\"        for f in self.parents.values():\\n\"\n+\"            if getattr(f.remote_field, 'parent_link', False):\\n\"\n+\"                field = f\\n\"\n+\"                break\\n\"\n+\"        if field is None and len(self.parents) == 1:\\n\"\n+\"            field = next(iter(self.parents.values()))\"\n+)\n+s = s.replace(old, replacement)\n+with open(p, 'w', encoding='utf-8') as f:\n+    f.write(s)\n+print('patched')\n\n"
  },
  "django__django-12406": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12406",
    "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex dafc11f995..4b39ba8373 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1146,7 +1146,7 @@ class ModelChoiceIterator:\n         self.queryset = field.queryset\n \n     def __iter__(self):\n-        if self.field.empty_label is not None:\n+        if self.field.empty_label is not None and not self.field.required:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n         # Can't use iterator() when queryset uses prefetch_related()\ndiff --git a/patch_modelchoiceiterator.py b/patch_modelchoiceiterator.py\nnew file mode 100644\nindex 0000000000..2a138fac88\n--- /dev/null\n+++ b/patch_modelchoiceiterator.py\n@@ -0,0 +1,14 @@\n+\n+p = \"django/forms/models.py\"\n+import io,sys\n+with open(p, \"r\") as f:\n+    lines = f.readlines()\n+for i, line in enumerate(lines):\n+    if \"if self.field.empty_label is not None:\" in line:\n+        lines[i] = line.replace(\"if self.field.empty_label is not None:\", \"if self.field.empty_label is not None and not self.field.required:\")\n+        break\n+else:\n+    raise SystemExit(\"target line not found\")\n+with open(p, \"w\") as f:\n+    f.writelines(lines)\n+print(\"patched\")\ndiff --git a/verify_repro_radioselect.py b/verify_repro_radioselect.py\nnew file mode 100644\nindex 0000000000..295dedfd55\n--- /dev/null\n+++ b/verify_repro_radioselect.py\n@@ -0,0 +1,49 @@\n+\n+class FakeObj:\n+    def __init__(self, id, name):\n+        self.id = id\n+        self.name = name\n+\n+class FakeQuerySet:\n+    def __init__(self, items):\n+        self._items = items\n+        self._prefetch_related_lookups = False\n+    def __iter__(self):\n+        for o in self._items:\n+            yield o\n+    def iterator(self):\n+        for o in self._items:\n+            yield o\n+    def count(self):\n+        return len(self._items)\n+    @property\n+    def exists(self):\n+        return bool(self._items)\n+\n+class FakeField:\n+    def __init__(self, queryset, required, empty_label):\n+        self.queryset = queryset\n+        self.required = required\n+        self.empty_label = empty_label\n+    def prepare_value(self, obj):\n+        return obj.id\n+    def label_from_instance(self, obj):\n+        return obj.name\n+\n+from django.forms.models import ModelChoiceIterator\n+\n+def run_case(required, empty_label):\n+    items = [FakeObj(1, \"First\"), FakeObj(2, \"Second\")]\n+    field = FakeField(FakeQuerySet(items), required=required, empty_label=empty_label)\n+    it = ModelChoiceIterator(field)\n+    for val, label in it:\n+        print(\"VAL:\", val, \"LABEL:\", label)\n+\n+print(\"CASE: required=True, empty_label present\")\n+run_case(True, \"---------\")\n+\n+print(\"CASE: required=False, empty_label present\")\n+run_case(False, \"---------\")\n+\n+print(\"CASE: required=False, empty_label=None\")\n+run_case(False, None)\n\n"
  },
  "django__django-12708": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12708",
    "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..7486bc9dc9 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,13 +407,7 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                if len(constraint_names) != 1:\\n            if len(constraint_names) == 0:\\n                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\\n                    len(constraint_names),\\n                    model._meta.db_table,\\n                    \", \".join(columns),\\n                ))\\n            constraint_names = [constraint_names[0]]\\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\ndiff --git a/test_delete_composed_index_harness.py b/test_delete_composed_index_harness.py\nnew file mode 100644\nindex 0000000000..fd08c0e1d3\n--- /dev/null\n+++ b/test_delete_composed_index_harness.py\n@@ -0,0 +1 @@\n+print('HARNESS_OK')\n\n"
  },
  "django__django-12713": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12713",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 69a5fbf389..3fa9a1216c 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -224,7 +224,7 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         if 'widget' not in kwargs:\n             if db_field.name in self.get_autocomplete_fields(request):\n                 kwargs['widget'] = AutocompleteSelect(db_field.remote_field, self.admin_site, using=db)\n-            elif db_field.name in self.raw_id_fields:\n+            elif 'widget' not in kwargs and db_field.name in self.raw_id_fields:\n                 kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n             elif db_field.name in self.radio_fields:\n                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n@@ -250,11 +250,11 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         db = kwargs.get('using')\n \n         autocomplete_fields = self.get_autocomplete_fields(request)\n-        if db_field.name in autocomplete_fields:\n+        if 'widget' not in kwargs and db_field.name in autocomplete_fields:\n             kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in self.raw_id_fields:\n+        elif 'widget' not in kwargs and db_field.name in self.raw_id_fields:\n             kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n+        elif 'widget' not in kwargs and db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n             kwargs['widget'] = widgets.FilteredSelectMultiple(\n                 db_field.verbose_name,\n                 db_field.name in self.filter_vertical\n\n"
  },
  "django__django-12774": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-12774",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex d9c9b0db04..e1379807f8 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -689,8 +689,13 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\n-        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n-            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+        if field_name != 'pk':\n+            field = self.model._meta.get_field(field_name)\n+            is_unique_field = getattr(field, 'unique', False)\n+            constraints = getattr(self.model._meta, 'constraints', [])\n+            has_unique_constraint = any(isinstance(c, models.UniqueConstraint) and field_name in getattr(c, 'fields', []) for c in constraints)\n+            if not is_unique_field and not has_unique_constraint:\n+                raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\n\n"
  },
  "django__django-9296": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "django__django-9296",
    "model_patch": "diff --git a/django/core/paginator.py b/django/core/paginator.py\nindex 1f92da5d4f..27cc31b0e3 100644\n--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -105,6 +105,10 @@ class Paginator:\n         a template for loop.\n         \"\"\"\n         return range(1, self.num_pages + 1)\n+    def __iter__(self):\n+        for page_num in self.page_range:\n+            yield self.page(page_num)\n+\n \n     def _check_object_list_is_ordered(self):\n         \"\"\"\n\n"
  },
  "sphinx-doc__sphinx-10323": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-10323",
    "model_patch": "\n"
  },
  "sphinx-doc__sphinx-10435": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-10435",
    "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex e0c7d56f8..b8179f39f 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -721,10 +721,12 @@ class LaTeXTranslator(SphinxTranslator):\n         pass\n \n     def visit_desc_inline(self, node: Element) -> None:\n-        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+        self.in_desc_inline = True\n+        self.body.append(r'\\\\sphinxcode{\\\\sphinxupquote{')\n \n     def depart_desc_inline(self, node: Element) -> None:\n         self.body.append('}}')\n+        self.in_desc_inline = False\n \n     # Nodes for high-level structure in signatures\n     ##############################################\n@@ -1987,7 +1989,13 @@ class LaTeXTranslator(SphinxTranslator):\n             replace(r'\\textquotesingle{}', \"'\")\n \n     def visit_Text(self, node: Text) -> None:\n-        text = self.encode(node.astext())\n+        text = node.astext()\n+        if getattr(self, 'in_desc_inline', False):\n+            if text.startswith(' '):\n+                text = text[1:]\n+            if text.endswith(' '):\n+                text = text[:-1]\n+        text = self.encode(text)\n         self.body.append(text)\n \n     def depart_Text(self, node: Text) -> None:\n\n"
  },
  "sphinx-doc__sphinx-10466": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-10466",
    "model_patch": "diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py\nindex e8bc547b7..0a9a51bf6 100644\n--- a/sphinx/builders/gettext.py\n+++ b/sphinx/builders/gettext.py\n@@ -32,9 +32,17 @@ class Message:\n     \"\"\"An entry of translatable message.\"\"\"\n     def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n         self.text = text\n-        self.locations = locations\n+        self.locations = self.uniqueLocation(locations)\n         self.uuids = uuids\n \n+    def uniqueLocation(self, locations: List[Tuple[str, int]]):\n+        seen = set()\n+        uniq = []\n+        for loc in locations:\n+            if loc not in seen:\n+                uniq.append(loc)\n+                seen.add(loc)\n+        return uniq\n \n class Catalog:\n     \"\"\"Catalog of translatable messages.\"\"\"\n\n"
  },
  "sphinx-doc__sphinx-10673": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-10673",
    "model_patch": "diff --git a/sphinx/environment/adapters/toctree.py b/sphinx/environment/adapters/toctree.py\nindex 9678e3c7c..2642398e8 100644\n--- a/sphinx/environment/adapters/toctree.py\n+++ b/sphinx/environment/adapters/toctree.py\n@@ -172,7 +172,10 @@ class TocTree:\n                     else:\n                         message = __('toctree contains reference to nonexisting document %r')\n \n-                    logger.warning(message, ref, location=toctreenode)\n+                    if ref in ('genindex','modindex','search'):\n+    pass\n+else:\n+    logger.warning(message, ref, location=toctreenode)\n                 else:\n                     # if titles_only is given, only keep the main title and\n                     # sub-toctrees\n\n"
  },
  "sphinx-doc__sphinx-11510": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-11510",
    "model_patch": "diff --git a/conf.py b/conf.py\nnew file mode 100644\nindex 000000000..d065bd6ad\n--- /dev/null\n+++ b/conf.py\n@@ -0,0 +1,5 @@\n+import sys\n+import os\n+sys.path.insert(0, os.path.abspath('.'))\n+\n+extensions = ['my-extension']\ndiff --git a/index.rst b/index.rst\nnew file mode 100644\nindex 000000000..b6c28ca02\n--- /dev/null\n+++ b/index.rst\n@@ -0,0 +1,6 @@\n+This is a test\n+===============\n+\n+.. include:: something-to-include.rst\n+\n+&REPLACE_ME;\ndiff --git a/my-extension.py b/my-extension.py\nnew file mode 100644\nindex 000000000..b351f2c74\n--- /dev/null\n+++ b/my-extension.py\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env python3\n+\n+from sphinx.application import Sphinx\n+\n+__version__ = '1.0'\n+\n+def subst_vars_replace(app, docname, source):\n+    result = source[0]\n+    result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+    source[0] = result\n+\n+def setup(app):\n+    app.connect('source-read', subst_vars_replace)\n+    return dict(\n+        version=__version__,\n+        parallel_read_safe=True,\n+        parallel_write_safe=True\n+    )\ndiff --git a/something-to-include.rst b/something-to-include.rst\nnew file mode 100644\nindex 000000000..e63253568\n--- /dev/null\n+++ b/something-to-include.rst\n@@ -0,0 +1,4 @@\n+Testing\n+=======\n+\n+&REPLACE_ME;\ndiff --git a/sphinx/directives/other.py b/sphinx/directives/other.py\nindex 19f7c0a8d..09164cf5c 100644\n--- a/sphinx/directives/other.py\n+++ b/sphinx/directives/other.py\n@@ -376,6 +376,23 @@ class Include(BaseInclude, SphinxDirective):\n         rel_filename, filename = self.env.relfn2path(self.arguments[0])\n         self.arguments[0] = filename\n         self.env.note_included(filename)\n+        try:\n+            with open(filename, 'rb') as f:\n+                data = f.read()\n+            encoding = getattr(self.env.config, 'source_encoding', 'utf-8')\n+            try:\n+                text = data.decode(encoding)\n+            except Exception:\n+                text = data.decode('utf-8', errors='replace')\n+            included_source = text.splitlines(True)\n+            docname_for_included = filename\n+            app = getattr(getattr(self.env, 'docwriter', None), 'app', None)\n+            if app is None:\n+                app = getattr(self.env, 'app', None)\n+            if app is not None:\n+                app.emit('source-read', docname_for_included, included_source)\n+        except Exception:\n+            pass\n         return super().run()\n \n \n\n"
  },
  "sphinx-doc__sphinx-7590": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-7590",
    "model_patch": "diff --git a/patch_udl.py b/patch_udl.py\nnew file mode 100644\nindex 000000000..37d8149da\n--- /dev/null\n+++ b/patch_udl.py\n@@ -0,0 +1,8 @@\n+from pathlib import Path\n+p = Path('sphinx/domains/cpp.py')\n+text = p.read_text()\n+old = \"    def get_id(self, version: int) -> str:\\n        if version == 1:\\n            raise NoOldIdError()\\n        else:\\n            return 'li' + self.identifier.get_id(version)\\n\"\n+new = \"    def get_id(self, version: int) -> str:\\n        if version == 1:\\n            return 'operator\\\\\"\\\\\"' + self.identifier.get_id(version)\\n        else:\\n            return 'li' + self.identifier.get_id(version)\\n\"\n+text2 = text.replace(old, new)\n+p.write_text(text2)\n+print('patched' if text != text2 else 'nochange')\ndiff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..93351d767 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -1584,7 +1584,7 @@ class ASTOperatorLiteral(ASTOperator):\n \n     def get_id(self, version: int) -> str:\n         if version == 1:\n-            raise NoOldIdError()\n+            return 'operator' + self.identifier.get_id(version)\n         else:\n             return 'li' + self.identifier.get_id(version)\n \n\n"
  },
  "sphinx-doc__sphinx-7748": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-7748",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..ddf4c62fe 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -404,6 +404,24 @@ class Documenter:\n         return self.format_args()\n \n     def format_signature(self, **kwargs: Any) -> str:\n+        lines_map = getattr(self, '_new_docstrings', None)\n+        if isinstance(lines_map, dict):\n+            sigs = []\n+            for lines in lines_map.values():\n+                if not lines:\n+                    continue\n+                first_line = lines[0] if isinstance(lines, (list, tuple)) else str(lines).splitlines()[0]\n+                if '(' in first_line and ')' in first_line:\n+                    sigs.append(first_line.strip())\n+            if sigs:\n+                seen = set()\n+                uniq = []\n+                for s in sigs:\n+                    if s not in seen:\n+                        seen.add(s)\n+                        uniq.append(s)\n+                self._overload_signature_string = ' | '.join(uniq)\n+                return self._overload_signature_string\n         \"\"\"Format the signature (arguments and return annotation) of the object.\n \n         Let the user process it via the ``autodoc-process-signature`` event.\n\n"
  },
  "sphinx-doc__sphinx-7757": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-7757",
    "model_patch": "\n"
  },
  "sphinx-doc__sphinx-7985": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-7985",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..fc84710e8 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -142,6 +142,26 @@ class CheckExternalLinksBuilder(Builder):\n             else:\n                 req_url = uri\n                 anchor = None\n+            # Local link check: handle local files without network access\n+            if not (req_url.startswith('http://') or req_url.startswith('https://') or req_url.startswith('//')):\n+                base_dir = getattr(self.app, 'srcdir', '')\n+                local_path = path.join(base_dir, req_url) if base_dir else req_url\n+                if path.exists(local_path):\n+                    if anchor:\n+                        try:\n+                            with open(local_path, 'r', encoding='utf-8', errors='ignore') as f:\n+                                content = f.read()\n+                        except Exception:\n+                            content = ''\n+                        ap = AnchorCheckParser(anchor)\n+                        ap.feed(content)\n+                        ap.close()\n+                        if ap.found:\n+                            return (uri, 'local anchor OK', 200)\n+                        else:\n+                            return (uri, 'local anchor not found', 404)\n+                    else:\n+                        return (uri, 'local file exists', 200)\n \n             # handle non-ASCII URIs\n             try:\n\n"
  },
  "sphinx-doc__sphinx-8035": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8035",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 8c3509c3b..4fea4fd85 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -74,12 +74,15 @@ SLOTSATTR = object()\n \n \n def members_option(arg: Any) -> Union[object, List[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n-    if arg is None or arg is True:\n-        return ALL\n-    return [x.strip() for x in arg.split(',') if x.strip()]\n-\n-\n+    if isinstance(arg, (list, tuple)):\n+        return list(arg)\n+    if isinstance(arg, str):\n+        import re\n+        items = [s.strip() for s in re.split(r\"[,\\s]+\", arg) if s.strip()]\n+        return items\n+    if arg is None:\n+        return []\n+    return arg\n def members_set_option(arg: Any) -> Union[object, Set[str]]:\n     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n     if arg is None:\n@@ -859,7 +862,7 @@ class ModuleDocumenter(Documenter):\n         'show-inheritance': bool_option, 'synopsis': identity,\n         'platform': identity, 'deprecated': bool_option,\n         'member-order': member_order_option, 'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n         'imported-members': bool_option, 'ignore-module-all': bool_option\n     }  # type: Dict[str, Callable]\n \n@@ -1279,7 +1282,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         'noindex': bool_option, 'inherited-members': inherited_members_option,\n         'show-inheritance': bool_option, 'member-order': member_order_option,\n         'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n     }  # type: Dict[str, Callable]\n \n     _signature_class = None  # type: Any\n\n"
  },
  "sphinx-doc__sphinx-8056": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8056",
    "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex b3daa06f1..c3118cff9 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -404,33 +404,40 @@ class GoogleDocstring:\n         return lines + ['']\n \n     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n-        _desc = self._strip_empty(_desc)\n-        has_desc = any(_desc)\n-        separator = ' -- ' if has_desc else ''\n-        if _name:\n-            if _type:\n-                if '`' in _type:\n-                    field = '**%s** (%s)%s' % (_name, _type, separator)\n-                else:\n-                    field = '**%s** (*%s*)%s' % (_name, _type, separator)\n-            else:\n-                field = '**%s**%s' % (_name, separator)\n-        elif _type:\n+    _desc = self._strip_empty(_desc)\n+    has_desc = any(_desc)\n+    separator = ' -- ' if has_desc else ''\n+    if _name:\n+        if _type:\n             if '`' in _type:\n-                field = '%s%s' % (_type, separator)\n+                field = '**%s** (%s)%s' % (_name, _type, separator)\n             else:\n-                field = '*%s*%s' % (_type, separator)\n+                field = '**%s** (*%s*)%s' % (_name, _type, separator)\n         else:\n-            field = ''\n-\n-        if has_desc:\n-            _desc = self._fix_field_desc(_desc)\n-            if _desc[0]:\n-                return [field + _desc[0]] + _desc[1:]\n+            field = '**%s**%s' % (_name, separator)\n+    elif _type:\n+        if '`' in _type:\n+            field = '%s%s' % (_type, separator)\n+        else:\n+            field = '*%s*%s' % (_type, separator)\n+    else:\n+        field = ''\n+\n+    if has_desc:\n+        _desc = self._fix_field_desc(_desc)\n+        if _desc[0]:\n+            if ',' in _name:\n+                first = _desc[0]\n+                if not first.strip().startswith('-') and not first.strip().startswith('\u2014'):\n+                    first = ' - ' + first\n+                return [field + first] + _desc[1:]\n             else:\n-                return [field] + _desc\n+                return [field + _desc[0]] + _desc[1:]\n         else:\n-            return [field]\n+            return [field] + _desc\n+    else:\n+        return [field]\n+\n \n     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]\n                        ) -> List[str]:\ndiff --git a/test_repro_format_field.py b/test_repro_format_field.py\nnew file mode 100644\nindex 000000000..458173d57\n--- /dev/null\n+++ b/test_repro_format_field.py\n@@ -0,0 +1,47 @@\n+\n+def _format_field_patch(name: str, type_str: str, desc: list) -> list:\n+    desc = [d for d in desc if d is not None]\n+    has_desc = any(desc)\n+    separator = ' -- ' if has_desc else ''\n+    if name:\n+        if type_str:\n+            if '`' in type_str:\n+                field = '**%s** (%s)%s' % (name, type_str, separator)\n+            else:\n+                field = '**%s** (*%s*)%s' % (name, type_str, separator)\n+        else:\n+            field = '**%s**%s' % (name, separator)\n+    elif type_str:\n+        if '`' in type_str:\n+            field = '%s%s' % (type_str, separator)\n+        else:\n+            field = '*%s*%s' % (type_str, separator)\n+    else:\n+        field = ''\n+\n+    if has_desc:\n+        first = desc[0] if desc else ''\n+        if ',' in name:\n+            if not first.strip().startswith('-') and not first.strip().startswith('\u2014'):\n+                first = ' - ' + first\n+            return [field + first] + desc[1:]\n+        else:\n+            return [field + first] + desc[1:]\n+    else:\n+        return [field]\n+\n+def run_case(name, typ, desc):\n+    out = _format_field_patch(name, typ, desc)\n+    print(\"Input -> name:\", repr(name), \"type:\", repr(typ), \"desc:\", desc)\n+    print(\"Output:\")\n+    for line in out:\n+        print(line)\n+    print('-' * 40)\n+\n+def main():\n+    run_case(\"x1, x2\", \"array_like\", [\"Input arrays, description of `x1`, `x2`.\"])\n+    run_case(\"x1\", \"array_like\", [\"Single input.\"])\n+    run_case(\"x1, x2\", None, [\"Description for two names.\"])\n+    run_case(\"param1, param2\", \"int\", [\"First and second parameters.\"])\n+if __name__ == \"__main__\":\n+    main()\ndiff --git a/test_repro_format_field_more.py b/test_repro_format_field_more.py\nnew file mode 100644\nindex 000000000..d5552ae9a\n--- /dev/null\n+++ b/test_repro_format_field_more.py\n@@ -0,0 +1,48 @@\n+\n+def _format_field_py(name: str, type_str: str, desc: list) -> list:\n+    desc = [d for d in desc if d]\n+    has_desc = any(desc)\n+    separator = ' -- ' if has_desc else ''\n+    if name:\n+        if type_str:\n+            if '`' in type_str:\n+                field = '**%s** (%s)%s' % (name, type_str, separator)\n+            else:\n+                field = '**%s** (*%s*)%s' % (name, type_str, separator)\n+        else:\n+            field = '**%s**%s' % (name, separator)\n+    elif type_str:\n+        if '`' in type_str:\n+            field = '%s%s' % (type_str, separator)\n+        else:\n+            field = '*%s*%s' % (type_str, separator)\n+    else:\n+        field = ''\n+\n+    if has_desc:\n+        first = desc[0]\n+        if ',' in name:\n+            if not first.strip().startswith('-') and not first.strip().startswith('\u2014'):\n+                first = ' - ' + first\n+            return [field + first] + desc[1:]\n+        else:\n+            return [field + first] + desc[1:]\n+    else:\n+        return [field]\n+\n+def run_case2(name, typ, desc):\n+    out = _format_field_py(name, typ, desc)\n+    print(\"Input -> name:\", repr(name), \"type:\", repr(typ), \"desc:\", desc)\n+    print(\"Output:\")\n+    for line in out:\n+        print(line)\n+    print('-' * 40)\n+\n+def main():\n+    run_case2(\"alpha, beta\", \"int\", [\"First beta description.\"])\n+    run_case2(\"alpha, beta, gamma\", \"str\", [\"Line one.\", \"Line two.\"])\n+    run_case2(\"gamma\", None, [\"Only one name with no type.\"])\n+    run_case2(\"delta, epsilon\", None, [\"Desc only.\"])\n+    run_case2(\"\", \"float\", [\"Type only.\"])\n+if __name__ == \"__main__\":\n+    main()\n\n"
  },
  "sphinx-doc__sphinx-8265": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8265",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 378174993..48cea3ce3 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -93,497 +93,7 @@ def getargspec(func: Callable) -> Any:\n             args.append(name)\n         elif kind is Parameter.POSITIONAL_OR_KEYWORD:\n             args.append(name)\n-            if param.default is not param.empty:\n-                defaults += (param.default,)  # type: ignore\n-        elif kind is Parameter.VAR_POSITIONAL:\n-            varargs = name\n-        elif kind is Parameter.KEYWORD_ONLY:\n-            kwonlyargs.append(name)\n-            if param.default is not param.empty:\n-                kwdefaults[name] = param.default\n-        elif kind is Parameter.VAR_KEYWORD:\n-            varkw = name\n-\n-        if param.annotation is not param.empty:\n-            annotations[name] = param.annotation\n-\n-    if not kwdefaults:\n-        # compatibility with 'func.__kwdefaults__'\n-        kwdefaults = None\n-\n-    if not defaults:\n-        # compatibility with 'func.__defaults__'\n-        defaults = None\n-\n-    return inspect.FullArgSpec(args, varargs, varkw, defaults,\n-                               kwonlyargs, kwdefaults, annotations)\n-\n-\n-def unwrap(obj: Any) -> Any:\n-    \"\"\"Get an original object from wrapped object (wrapped functions).\"\"\"\n-    try:\n-        return inspect.unwrap(obj)\n-    except ValueError:\n-        # might be a mock object\n-        return obj\n-\n-\n-def unwrap_all(obj: Any, *, stop: Callable = None) -> Any:\n-    \"\"\"\n-    Get an original object from wrapped object (unwrapping partials, wrapped\n-    functions, and other decorators).\n-    \"\"\"\n-    while True:\n-        if stop and stop(obj):\n-            return obj\n-        elif ispartial(obj):\n-            obj = obj.func\n-        elif inspect.isroutine(obj) and hasattr(obj, '__wrapped__'):\n-            obj = obj.__wrapped__\n-        elif isclassmethod(obj):\n-            obj = obj.__func__\n-        elif isstaticmethod(obj):\n-            obj = obj.__func__\n-        else:\n-            return obj\n-\n-\n-def isenumclass(x: Any) -> bool:\n-    \"\"\"Check if the object is subclass of enum.\"\"\"\n-    return inspect.isclass(x) and issubclass(x, enum.Enum)\n-\n-\n-def isenumattribute(x: Any) -> bool:\n-    \"\"\"Check if the object is attribute of enum.\"\"\"\n-    return isinstance(x, enum.Enum)\n-\n-\n-def unpartial(obj: Any) -> Any:\n-    \"\"\"Get an original object from partial object.\n-\n-    This returns given object itself if not partial.\n-    \"\"\"\n-    while ispartial(obj):\n-        obj = obj.func\n-\n-    return obj\n-\n-\n-def ispartial(obj: Any) -> bool:\n-    \"\"\"Check if the object is partial.\"\"\"\n-    return isinstance(obj, (partial, partialmethod))\n-\n-\n-def isclassmethod(obj: Any) -> bool:\n-    \"\"\"Check if the object is classmethod.\"\"\"\n-    if isinstance(obj, classmethod):\n-        return True\n-    elif inspect.ismethod(obj) and obj.__self__ is not None and isclass(obj.__self__):\n-        return True\n-\n-    return False\n-\n-\n-def isstaticmethod(obj: Any, cls: Any = None, name: str = None) -> bool:\n-    \"\"\"Check if the object is staticmethod.\"\"\"\n-    if isinstance(obj, staticmethod):\n-        return True\n-    elif cls and name:\n-        # trace __mro__ if the method is defined in parent class\n-        #\n-        # .. note:: This only works well with new style classes.\n-        for basecls in getattr(cls, '__mro__', [cls]):\n-            meth = basecls.__dict__.get(name)\n-            if meth:\n-                if isinstance(meth, staticmethod):\n-                    return True\n-                else:\n-                    return False\n-\n-    return False\n-\n-\n-def isdescriptor(x: Any) -> bool:\n-    \"\"\"Check if the object is some kind of descriptor.\"\"\"\n-    for item in '__get__', '__set__', '__delete__':\n-        if hasattr(safe_getattr(x, item, None), '__call__'):\n-            return True\n-    return False\n-\n-\n-def isabstractmethod(obj: Any) -> bool:\n-    \"\"\"Check if the object is an abstractmethod.\"\"\"\n-    return safe_getattr(obj, '__isabstractmethod__', False) is True\n-\n-\n-def is_cython_function_or_method(obj: Any) -> bool:\n-    \"\"\"Check if the object is a function or method in cython.\"\"\"\n-    try:\n-        return obj.__class__.__name__ == 'cython_function_or_method'\n-    except AttributeError:\n-        return False\n-\n-\n-def isattributedescriptor(obj: Any) -> bool:\n-    \"\"\"Check if the object is an attribute like descriptor.\"\"\"\n-    if inspect.isdatadescriptor(obj):\n-        # data descriptor is kind of attribute\n-        return True\n-    elif isdescriptor(obj):\n-        # non data descriptor\n-        unwrapped = unwrap(obj)\n-        if isfunction(unwrapped) or isbuiltin(unwrapped) or inspect.ismethod(unwrapped):\n-            # attribute must not be either function, builtin and method\n-            return False\n-        elif is_cython_function_or_method(unwrapped):\n-            # attribute must not be either function and method (for cython)\n-            return False\n-        elif inspect.isclass(unwrapped):\n-            # attribute must not be a class\n-            return False\n-        elif isinstance(unwrapped, (ClassMethodDescriptorType,\n-                                    MethodDescriptorType,\n-                                    WrapperDescriptorType)):\n-            # attribute must not be a method descriptor\n-            return False\n-        elif type(unwrapped).__name__ == \"instancemethod\":\n-            # attribute must not be an instancemethod (C-API)\n-            return False\n-        else:\n-            return True\n-    else:\n-        return False\n-\n-\n-def is_singledispatch_function(obj: Any) -> bool:\n-    \"\"\"Check if the object is singledispatch function.\"\"\"\n-    if (inspect.isfunction(obj) and\n-            hasattr(obj, 'dispatch') and\n-            hasattr(obj, 'register') and\n-            obj.dispatch.__module__ == 'functools'):\n-        return True\n-    else:\n-        return False\n-\n-\n-def is_singledispatch_method(obj: Any) -> bool:\n-    \"\"\"Check if the object is singledispatch method.\"\"\"\n-    try:\n-        from functools import singledispatchmethod  # type: ignore\n-        return isinstance(obj, singledispatchmethod)\n-    except ImportError:  # py35-37\n-        return False\n-\n-\n-def isfunction(obj: Any) -> bool:\n-    \"\"\"Check if the object is function.\"\"\"\n-    return inspect.isfunction(unwrap_all(obj))\n-\n-\n-def isbuiltin(obj: Any) -> bool:\n-    \"\"\"Check if the object is builtin.\"\"\"\n-    return inspect.isbuiltin(unwrap_all(obj))\n-\n-\n-def isroutine(obj: Any) -> bool:\n-    \"\"\"Check is any kind of function or method.\"\"\"\n-    return inspect.isroutine(unwrap_all(obj))\n-\n-\n-def iscoroutinefunction(obj: Any) -> bool:\n-    \"\"\"Check if the object is coroutine-function.\"\"\"\n-    # unwrap staticmethod, classmethod and partial (except wrappers)\n-    obj = unwrap_all(obj, stop=lambda o: hasattr(o, '__wrapped__'))\n-    if hasattr(obj, '__code__') and inspect.iscoroutinefunction(obj):\n-        # check obj.__code__ because iscoroutinefunction() crashes for custom method-like\n-        # objects (see https://github.com/sphinx-doc/sphinx/issues/6605)\n-        return True\n-    else:\n-        return False\n-\n-\n-def isproperty(obj: Any) -> bool:\n-    \"\"\"Check if the object is property.\"\"\"\n-    if sys.version_info > (3, 8):\n-        from functools import cached_property  # cached_property is available since py3.8\n-        if isinstance(obj, cached_property):\n-            return True\n-\n-    return isinstance(obj, property)\n-\n-\n-def isgenericalias(obj: Any) -> bool:\n-    \"\"\"Check if the object is GenericAlias.\"\"\"\n-    if (hasattr(typing, '_GenericAlias') and  # only for py37+\n-            isinstance(obj, typing._GenericAlias)):  # type: ignore\n-        return True\n-    elif (hasattr(types, 'GenericAlias') and  # only for py39+\n-          isinstance(obj, types.GenericAlias)):  # type: ignore\n-        return True\n-    else:\n-        return False\n-\n-\n-def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n-    \"\"\"A getattr() that turns all exceptions into AttributeErrors.\"\"\"\n-    try:\n-        return getattr(obj, name, *defargs)\n-    except Exception as exc:\n-        # sometimes accessing a property raises an exception (e.g.\n-        # NotImplementedError), so let's try to read the attribute directly\n-        try:\n-            # In case the object does weird things with attribute access\n-            # such that accessing `obj.__dict__` may raise an exception\n-            return obj.__dict__[name]\n-        except Exception:\n-            pass\n-\n-        # this is a catch-all for all the weird things that some modules do\n-        # with attribute access\n-        if defargs:\n-            return defargs[0]\n-\n-        raise AttributeError(name) from exc\n-\n-\n-def safe_getmembers(object: Any, predicate: Callable[[str], bool] = None,\n-                    attr_getter: Callable = safe_getattr) -> List[Tuple[str, Any]]:\n-    \"\"\"A version of inspect.getmembers() that uses safe_getattr().\"\"\"\n-    warnings.warn('safe_getmembers() is deprecated', RemovedInSphinx40Warning, stacklevel=2)\n-\n-    results = []  # type: List[Tuple[str, Any]]\n-    for key in dir(object):\n-        try:\n-            value = attr_getter(object, key, None)\n-        except AttributeError:\n-            continue\n-        if not predicate or predicate(value):\n-            results.append((key, value))\n-    results.sort()\n-    return results\n-\n-\n-def object_description(object: Any) -> str:\n-    \"\"\"A repr() implementation that returns text safe to use in reST context.\"\"\"\n-    if isinstance(object, dict):\n-        try:\n-            sorted_keys = sorted(object)\n-        except Exception:\n-            pass  # Cannot sort dict keys, fall back to generic repr\n-        else:\n-            items = (\"%s: %s\" %\n-                     (object_description(key), object_description(object[key]))\n-                     for key in sorted_keys)\n-            return \"{%s}\" % \", \".join(items)\n-    if isinstance(object, set):\n-        try:\n-            sorted_values = sorted(object)\n-        except TypeError:\n-            pass  # Cannot sort set values, fall back to generic repr\n-        else:\n-            return \"{%s}\" % \", \".join(object_description(x) for x in sorted_values)\n-    if isinstance(object, frozenset):\n-        try:\n-            sorted_values = sorted(object)\n-        except TypeError:\n-            pass  # Cannot sort frozenset values, fall back to generic repr\n-        else:\n-            return \"frozenset({%s})\" % \", \".join(object_description(x)\n-                                                 for x in sorted_values)\n-    try:\n-        s = repr(object)\n-    except Exception as exc:\n-        raise ValueError from exc\n-    # Strip non-deterministic memory addresses such as\n-    # ``<__main__.A at 0x7f68cb685710>``\n-    s = memory_address_re.sub('', s)\n-    return s.replace('\\n', ' ')\n-\n-\n-def is_builtin_class_method(obj: Any, attr_name: str) -> bool:\n-    \"\"\"If attr_name is implemented at builtin class, return True.\n-\n-        >>> is_builtin_class_method(int, '__init__')\n-        True\n-\n-    Why this function needed? CPython implements int.__init__ by Descriptor\n-    but PyPy implements it by pure Python code.\n-    \"\"\"\n-    try:\n-        mro = inspect.getmro(obj)\n-    except AttributeError:\n-        # no __mro__, assume the object has no methods as we know them\n-        return False\n-\n-    try:\n-        cls = next(c for c in mro if attr_name in safe_getattr(c, '__dict__', {}))\n-    except StopIteration:\n-        return False\n-\n-    try:\n-        name = safe_getattr(cls, '__name__')\n-    except AttributeError:\n-        return False\n-\n-    return getattr(builtins, name, None) is cls\n-\n-\n-def _should_unwrap(subject: Callable) -> bool:\n-    \"\"\"Check the function should be unwrapped on getting signature.\"\"\"\n-    if (safe_getattr(subject, '__globals__', None) and\n-            subject.__globals__.get('__name__') == 'contextlib' and  # type: ignore\n-            subject.__globals__.get('__file__') == contextlib.__file__):  # type: ignore\n-        # contextmanger should be unwrapped\n-        return True\n-\n-    return False\n-\n-\n-def signature(subject: Callable, bound_method: bool = False, follow_wrapped: bool = False,\n-              type_aliases: Dict = {}) -> inspect.Signature:\n-    \"\"\"Return a Signature object for the given *subject*.\n-\n-    :param bound_method: Specify *subject* is a bound method or not\n-    :param follow_wrapped: Same as ``inspect.signature()``.\n-                           Defaults to ``False`` (get a signature of *subject*).\n-    \"\"\"\n-    try:\n-        try:\n-            if _should_unwrap(subject):\n-                signature = inspect.signature(subject)\n-            else:\n-                signature = inspect.signature(subject, follow_wrapped=follow_wrapped)\n-        except ValueError:\n-            # follow built-in wrappers up (ex. functools.lru_cache)\n-            signature = inspect.signature(subject)\n-        parameters = list(signature.parameters.values())\n-        return_annotation = signature.return_annotation\n-    except IndexError:\n-        # Until python 3.6.4, cpython has been crashed on inspection for\n-        # partialmethods not having any arguments.\n-        # https://bugs.python.org/issue33009\n-        if hasattr(subject, '_partialmethod'):\n-            parameters = []\n-            return_annotation = Parameter.empty\n-        else:\n-            raise\n-\n-    try:\n-        # Update unresolved annotations using ``get_type_hints()``.\n-        annotations = typing.get_type_hints(subject, None, type_aliases)\n-        for i, param in enumerate(parameters):\n-            if isinstance(param.annotation, str) and param.name in annotations:\n-                parameters[i] = param.replace(annotation=annotations[param.name])\n-        if 'return' in annotations:\n-            return_annotation = annotations['return']\n-    except Exception:\n-        # ``get_type_hints()`` does not support some kind of objects like partial,\n-        # ForwardRef and so on.\n-        pass\n-\n-    if bound_method:\n-        if inspect.ismethod(subject):\n-            # ``inspect.signature()`` considers the subject is a bound method and removes\n-            # first argument from signature.  Therefore no skips are needed here.\n-            pass\n-        else:\n-            if len(parameters) > 0:\n-                parameters.pop(0)\n-\n-    # To allow to create signature object correctly for pure python functions,\n-    # pass an internal parameter __validate_parameters__=False to Signature\n-    #\n-    # For example, this helps a function having a default value `inspect._empty`.\n-    # refs: https://github.com/sphinx-doc/sphinx/issues/7935\n-    return inspect.Signature(parameters, return_annotation=return_annotation,  # type: ignore\n-                             __validate_parameters__=False)\n-\n-\n-def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: Dict = None\n-                       ) -> inspect.Signature:\n-    \"\"\"Evaluate unresolved type annotations in a signature object.\"\"\"\n-    def evaluate_forwardref(ref: ForwardRef, globalns: Dict, localns: Dict) -> Any:\n-        \"\"\"Evaluate a forward reference.\"\"\"\n-        if sys.version_info > (3, 9):\n-            return ref._evaluate(globalns, localns, frozenset())\n-        else:\n-            return ref._evaluate(globalns, localns)\n-\n-    def evaluate(annotation: Any, globalns: Dict, localns: Dict) -> Any:\n-        \"\"\"Evaluate unresolved type annotation.\"\"\"\n-        try:\n-            if isinstance(annotation, str):\n-                ref = ForwardRef(annotation, True)\n-                annotation = evaluate_forwardref(ref, globalns, localns)\n-\n-                if isinstance(annotation, ForwardRef):\n-                    annotation = evaluate_forwardref(ref, globalns, localns)\n-                elif isinstance(annotation, str):\n-                    # might be a ForwardRef'ed annotation in overloaded functions\n-                    ref = ForwardRef(annotation, True)\n-                    annotation = evaluate_forwardref(ref, globalns, localns)\n-        except (NameError, TypeError):\n-            # failed to evaluate type. skipped.\n-            pass\n-\n-        return annotation\n-\n-    if globalns is None:\n-        globalns = {}\n-    if localns is None:\n-        localns = globalns\n-\n-    parameters = list(sig.parameters.values())\n-    for i, param in enumerate(parameters):\n-        if param.annotation:\n-            annotation = evaluate(param.annotation, globalns, localns)\n-            parameters[i] = param.replace(annotation=annotation)\n-\n-    return_annotation = sig.return_annotation\n-    if return_annotation:\n-        return_annotation = evaluate(return_annotation, globalns, localns)\n-\n-    return sig.replace(parameters=parameters, return_annotation=return_annotation)\n-\n-\n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n-\n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n+        if param.default is not param.empty:\\n            if show_annotation and param.annotation is not param.empty:\\n                arg.write(' = ')\\n            else:\\n                arg.write('=')\\n            default = param.default\\n            default_desc = object_description(default)\\n            if not isinstance(default_desc, str):\\n                default_desc = str(default_desc)\\n            if isinstance(default, tuple) and not default_desc.strip().startswith('('):\\n                default_desc = '(' + default_desc + ')'\\n            arg.write(default_desc)\\n        last_kind = param.kind\n \n     if last_kind == Parameter.POSITIONAL_ONLY:\n         # PEP-570: Separator for Positional Only Parameter: /\n@@ -765,28 +275,7 @@ class Signature:\n                 if show_annotation and param.annotation is not param.empty:\n                     arg.write(': ')\n                     arg.write(stringify_annotation(get_annotation(param)))\n-                if param.default is not param.empty:\n-                    if param.annotation is param.empty or show_annotation is False:\n-                        arg.write('=')\n-                        arg.write(object_description(param.default))\n-                    else:\n-                        arg.write(' = ')\n-                        arg.write(object_description(param.default))\n-            elif param.kind == param.VAR_POSITIONAL:\n-                arg.write('*')\n-                arg.write(param.name)\n-                if show_annotation and param.annotation is not param.empty:\n-                    arg.write(': ')\n-                    arg.write(stringify_annotation(get_annotation(param)))\n-            elif param.kind == param.VAR_KEYWORD:\n-                arg.write('**')\n-                arg.write(param.name)\n-                if show_annotation and param.annotation is not param.empty:\n-                    arg.write(': ')\n-                    arg.write(stringify_annotation(get_annotation(param)))\n-\n-            args.append(arg.getvalue())\n-            last_kind = param.kind\n+        if param.default is not param.empty:\\n            if show_annotation and param.annotation is not param.empty:\\n                arg.write(' = ')\\n            else:\\n                arg.write('=')\\n            default = param.default\\n            default_desc = object_description(default)\\n            if not isinstance(default_desc, str):\\n                default_desc = str(default_desc)\\n            if isinstance(default, tuple) and not default_desc.strip().startswith('('):\\n                default_desc = '(' + default_desc + ')'\\n            arg.write(default_desc)\\n            last_kind = param.kind\n \n         if self.return_annotation is Parameter.empty or show_annotation is False:\n             return '(%s)' % ', '.join(args)\n@@ -838,3 +327,6 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                         break\n \n     return doc\n+  break\n+\n+    return doc\n\n"
  },
  "sphinx-doc__sphinx-8269": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8269",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 9b54afc7c..1083e82ec 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -166,6 +166,7 @@ class CheckExternalLinksBuilder(Builder):\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n+                    response.raise_for_status()\n                     found = check_anchor(response, unquote(anchor))\n \n                     if not found:\ndiff --git a/test_linkcheck_http_error.py b/test_linkcheck_http_error.py\nnew file mode 100644\nindex 000000000..a8edb6a7f\n--- /dev/null\n+++ b/test_linkcheck_http_error.py\n@@ -0,0 +1,14 @@\n+import requests\n+\n+def test_404_reporting():\n+    url = \"https://httpbin.org/status/404\"\n+    try:\n+        resp = requests.get(url, stream=True, timeout=5)\n+        resp.raise_for_status()\n+    except requests.exceptions.HTTPError as err:\n+        print(str(err))\n+    else:\n+        print(\"no error, status:\", resp.status_code)\n+\n+if __name__ == \"__main__\":\n+    test_404_reporting()\ndiff --git a/tests/test_linkcheck_anchor_http_error.py b/tests/test_linkcheck_anchor_http_error.py\nnew file mode 100644\nindex 000000000..39d1808c1\n--- /dev/null\n+++ b/tests/test_linkcheck_anchor_http_error.py\n@@ -0,0 +1,26 @@\n+import requests\n+from unittest.mock import patch\n+\n+class FakeResponse:\n+    def __init__(self, status_code=404, url=\"http://example/test\"):\n+        self.status_code = status_code\n+        self.url = url\n+    def iter_content(self, chunk_size=4096, decode_unicode=True):\n+        yield \"<html id='test'></html>\"\n+    def raise_for_status(self):\n+        if self.status_code >= 400:\n+            import requests\n+            raise requests.exceptions.HTTPError(f\"{self.status_code} Client Error: Not Found for url: {self.url}\", response=self)\n+\n+def test_anchor_http_error_propagation():\n+    with patch('requests.get', return_value=FakeResponse(404, \"http://example/test\")):\n+        try:\n+            resp = requests.get(\"http://example/test\", stream=True)\n+            resp.raise_for_status()\n+        except Exception as err:\n+            print(f\"HTTPError: {err}\")\n+            return\n+        print(\"No HTTPError\")\n+\n+if __name__ == \"__main__\":\n+    test_anchor_http_error_propagation()\n\n"
  },
  "sphinx-doc__sphinx-8475": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8475",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 1dc0337c3..32ce23112 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -154,9 +154,8 @@ class CheckExternalLinksBuilder(Builder):\n             # update request headers for the URL\n             kwargs['headers'] = get_request_headers()\n \n-            try:\n+                        try:\n                 if anchor and self.app.config.linkcheck_anchors:\n-                    # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n                     response.raise_for_status()\n@@ -166,24 +165,25 @@ class CheckExternalLinksBuilder(Builder):\n                         raise Exception(__(\"Anchor '%s' not found\") % anchor)\n                 else:\n                     try:\n-                        # try a HEAD request first, which should be easier on\n-                        # the server and the network\n                         response = requests.head(req_url, allow_redirects=True,\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\n                     except HTTPError:\n-                        # retry with GET request if that fails, some servers\n-                        # don't like HEAD requests.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n                                                 auth=auth_info, **kwargs)\n                         response.raise_for_status()\n+                    except Exception as err:\n+                        if err.__class__.__name__ == \"TooManyRedirects\":\n+                            response = requests.get(req_url, stream=True, config=self.app.config,\n+                                                    auth=auth_info, **kwargs)\n+                            response.raise_for_status()\n+                        else:\n+                            raise\n             except HTTPError as err:\n                 if err.response.status_code == 401:\n-                    # We'll take \"Unauthorized\" as working.\n                     return 'working', ' - unauthorized', 0\n                 elif err.response.status_code == 503:\n-                    # We'll take \"Service Unavailable\" as ignored.\n                     return 'ignored', str(err), 0\n                 else:\n                     return 'broken', str(err), 0\n@@ -195,13 +195,13 @@ class CheckExternalLinksBuilder(Builder):\n                 new_url = response.url\n                 if anchor:\n                     new_url += '#' + anchor\n-                # history contains any redirects, get last\n                 if response.history:\n                     code = response.history[-1].status_code\n                     return 'redirected', new_url, code\n                 else:\n                     return 'redirected', new_url, 0\n \n+\n         def check(docname: str) -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n@@ -377,4 +377,4 @@ def setup(app: Sphinx) -> Dict[str, Any]:\n         'version': 'builtin',\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n-    }\n+    }\n\\ No newline at end of file\ndiff --git a/tests/verify_toomanyredirects_patch.py b/tests/verify_toomanyredirects_patch.py\nnew file mode 100644\nindex 000000000..311c33ebe\n--- /dev/null\n+++ b/tests/verify_toomanyredirects_patch.py\n@@ -0,0 +1,11 @@\n+\n+import sys\n+p = 'sphinx/builders/linkcheck.py'\n+with open(p, 'r', encoding='utf-8') as f:\n+    s = f.read()\n+if 'except (HTTPError, requests.exceptions.TooManyRedirects):' in s:\n+    print(\"patch_present\")\n+    sys.exit(0)\n+else:\n+    print(\"patch_missing\")\n+    sys.exit(1)\n\n"
  },
  "sphinx-doc__sphinx-8548": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8548",
    "model_patch": "diff --git a/repro_autodoc_inherited_attr.py b/repro_autodoc_inherited_attr.py\nnew file mode 100644\nindex 000000000..8e2c4c8c3\n--- /dev/null\n+++ b/repro_autodoc_inherited_attr.py\n@@ -0,0 +1,24 @@\n+class A:\n+    x = 1\n+    y = 2\n+\n+class B(A):\n+    pass\n+\n+def simulate_lookup(obj, membername, attr_docs, namespace):\n+    import inspect\n+    base_namespaces = []\n+    if inspect.isclass(obj):\n+        for cls in obj.__mro__[1:]:\n+            cls_name = getattr(cls, '__name__', None)\n+            if cls_name:\n+                module = getattr(obj, '__module__', None)\n+                base_namespaces.append((module + '.' + cls_name) if module else cls_name)\n+    found = (namespace, membername) in attr_docs or any((bn, membername) in attr_docs for bn in base_namespaces)\n+    return base_namespaces, found\n+\n+attr_docs = {('__main__.A', 'x'): 'doc'}\n+ns = '__main__.B'\n+bases, ok = simulate_lookup(B, 'x', attr_docs, ns)\n+print('base_namespaces:', bases)\n+print('inherited_attr_doc_found:', ok)\ndiff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex ddfd2b365..73afc2a88 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -678,6 +678,13 @@ class Documenter:\n                         return False\n \n             return False\n+        base_namespaces = []\n+        if inspect.isclass(self.object):\n+            for cls in getattr(self.object, '__mro__', [])[1:]:\n+                cls_name = getattr(cls, '__name__', None)\n+                if cls_name:\n+                    cls_module = getattr(cls, '__module__', None)\n+                    base_namespaces.append((module + '.' + cls_name) if module else cls_name)\n \n         ret = []\n \n@@ -746,7 +753,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n+            elif (namespace, membername) in attr_docs or any((bn, membername) in attr_docs for bn in base_namespaces):\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n                         keep = False\n\nbash execution output:\n 681:        base_namespaces = []\n687:                    base_namespaces.append((module + '.' + cls_name) if module else cls_name)\n756:            elif (namespace, membername) in attr_docs or any((bn, membername) in attr_docs for bn in base_namespaces):\n\n"
  },
  "sphinx-doc__sphinx-8551": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8551",
    "model_patch": ""
  },
  "sphinx-doc__sphinx-8638": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8638",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f66852a34..6ccb16ad4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2348,6 +2348,11 @@ class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type:\n         elif (not isinstance(parent, ModuleDocumenter) and\n               not inspect.isroutine(member) and\n               not isinstance(member, type)):\n+            member_mod = getattr(member, '__module__', None)\n+            parent_mod = getattr(parent, '__module__', None)\n+            if member_mod and parent_mod and member_mod != parent_mod:\n+                return False\n+            return True\n             return True\n         else:\n             return False\n\n"
  },
  "sphinx-doc__sphinx-8721": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-8721",
    "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..863fc3d6d 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -180,6 +180,8 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n \n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n\n"
  },
  "sphinx-doc__sphinx-9229": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9229",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..7cb5316c3 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1724,10 +1724,12 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n                     ) -> None:\n         if self.doc_as_attr:\n-            try:\n-                more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n-            except AttributeError:\n-                pass  # Invalid class object is passed.\n+            # Only override content when no explicit docstring content is provided\n+            if more_content is None or len(more_content) == 0:\n+                try:\n+                    more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n+                except AttributeError:\n+                    pass  # Invalid class object is passed.\n \n         super().add_content(more_content)\n \n\n"
  },
  "sphinx-doc__sphinx-9230": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9230",
    "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex d8cb75a5f..09a0b7cae 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -1009,6 +1009,11 @@ def _token_type(token: str, location: str = None) -> str:\n \n \n def _convert_numpy_type_spec(_type: str, location: str = None, translations: dict = {}) -> str:\n+    stripped = _type.strip()\n+    if stripped.startswith(\"dict(\") and stripped.endswith(\")\"):\n+        inner = stripped[5:-1]\n+        inner_clean = inner.replace(\" \", \"\")\n+        return \"dict(\" + inner_clean + \")\"\n     def convert_obj(obj, translations, default_translation):\n         translation = translations.get(obj, obj)\n \n\n"
  },
  "sphinx-doc__sphinx-9281": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9281",
    "model_patch": "diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex f541ec0a9..63de7551b 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -161,8 +161,15 @@ class _UnparseVisitor(ast.NodeVisitor):\n         return \"%s(%s)\" % (self.visit(node.func), \", \".join(args))\n \n     def visit_Constant(self, node: ast.Constant) -> str:  # type: ignore\n+        # Normalize Enum members to ClassName.MemberName\n+        try:\n+            from enum import Enum as _Enum\n+            if isinstance(node.value, _Enum):\n+                return '{}.{}'.format(node.value.__class__.__name__, node.value.name)\n+        except Exception:\n+            pass\n         if node.value is Ellipsis:\n-            return \"...\"\n+            return '...'\n         elif isinstance(node.value, (int, float, complex)):\n             if self.code and sys.version_info > (3, 8):\n                 return ast.get_source_segment(self.code, node)  # type: ignore\n@@ -170,7 +177,6 @@ class _UnparseVisitor(ast.NodeVisitor):\n                 return repr(node.value)\n         else:\n             return repr(node.value)\n-\n     def visit_Dict(self, node: ast.Dict) -> str:\n         keys = (self.visit(k) for k in node.keys)\n         values = (self.visit(v) for v in node.values)\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex a415a7074..23ca08665 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -859,4 +859,12 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n         if doc is None:\n             doc = inspect.getdoc(obj)\n \n-    return doc\n+    return doc\\n\n+# Normalize Enum representations in autodoc signatures\n+import re as _re\n+_ENUM_SIGNATURE_RE = _re.compile(r\"<([A-Za-z_]\\w*)\\.([A-Za-z_]\\w*):\\s*\\d+>\")\n+\n+def _normalize_enum_signature(sig: str) -> str:\n+    def _rep(m):\n+        return f\"{m.group(1)}.{m.group(2)}\"\n+    return _ENUM_SIGNATURE_RE.sub(_rep, sig)\ndiff --git a/tests/test_enum_norm.py b/tests/test_enum_norm.py\nnew file mode 100644\nindex 000000000..2d6b44d59\n--- /dev/null\n+++ b/tests/test_enum_norm.py\n@@ -0,0 +1,9 @@\n+\n+import importlib.util\n+spec = importlib.util.spec_from_file_location(\"inspect_mod\", \"sphinx/pycode/ast.py\")\n+mod = importlib.util.module_from_spec(spec)\n+spec.loader.exec_module(mod)\n+assert hasattr(mod, \"_normalize_enum_signature\"), \"Normalization function missing\"\n+print(\"norm_result:\", mod._normalize_enum_signature(\"<MyEnum.ValueA: 10>\"))\n+assert mod._normalize_enum_signature(\"<MyEnum.ValueA: 10>\") == \"MyEnum.ValueA\"\n+print(\"OK\")\ndiff --git a/tests/test_enum_visit_constant.py b/tests/test_enum_visit_constant.py\nnew file mode 100644\nindex 000000000..5407ec268\n--- /dev/null\n+++ b/tests/test_enum_visit_constant.py\n@@ -0,0 +1,25 @@\n+\n+import importlib.util\n+import sys\n+from enum import Enum\n+\n+# Dynamically load the patched AST module\n+spec = importlib.util.spec_from_file_location(\"inspect_mod\", \"sphinx/pycode/ast.py\")\n+mod = importlib.util.module_from_spec(spec)\n+spec.loader.exec_module(mod)\n+\n+class MyEnum(Enum):\n+    ValueA = 1\n+\n+import ast as _ast\n+const_node = _ast.Constant(value=MyEnum.ValueA)\n+\n+# Instantiate the UnparseVisitor and test visit_Constant path\n+visitor = mod._UnparseVisitor(code='')\n+result = visitor.visit_Constant(const_node)\n+print(\"RESULT:\", result)\n+\n+if result != \"MyEnum.ValueA\":\n+    print(\"Test failed: unexpected normalization\", file=sys.stderr)\n+    sys.exit(2)\n+print(\"Test passed\")\n\n"
  },
  "sphinx-doc__sphinx-9320": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9320",
    "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex a40a21073..fc867ab83 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -98,6 +98,11 @@ def is_path(x: str) -> str:\n def allow_empty(x: str) -> str:\n     return x\n \n+def exit_on_empty_path(x: str) -> str:\n+    if not x:\n+        return x\n+    return is_path(x)\n+\n \n def nonempty(x: str) -> str:\n     if not x:\n@@ -222,8 +227,7 @@ def ask_user(d: Dict) -> None:\n                       'selected root path.')))\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n-        d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+        d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'), '', exit_on_empty_path)\n         if not d['path']:\n             sys.exit(1)\n \ndiff --git a/test_quickstart_exit_repro.py b/test_quickstart_exit_repro.py\nnew file mode 100644\nindex 000000000..b31a2071a\n--- /dev/null\n+++ b/test_quickstart_exit_repro.py\n@@ -0,0 +1,45 @@\n+\n+import os\n+import sys\n+import subprocess\n+import tempfile\n+\n+def main():\n+    # Create a temporary directory to act as the project root with an existing conf.py\n+    root = tempfile.mkdtemp(prefix=\"test_quickstart_exit_\")\n+    try:\n+        # Create conf.py to simulate an existing Sphinx project\n+        with open(os.path.join(root, \"conf.py\"), \"w\") as f:\n+            f.write(\"# dummy conf.py for testing\")\n+\n+        # Run sphinx.quickstart in a non-interactive way, feeding two empties (Enter)\n+        # First Enter for the root path prompt, second Enter to attempt exit when asked for a new root path\n+        env = os.environ.copy()\n+        # Ensure correct Python path uses the repository code\n+        py = sys.executable\n+        cmd = [py, \"-m\", \"sphinx.cmd.quickstart\"]\n+        proc = subprocess.Popen(cmd, cwd=root, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env)\n+        # Two empty lines to simulate pressing Enter twice\n+        out, _ = proc.communicate(input=\"\\n\\n\", timeout=20)\n+        code = proc.returncode\n+        print(\"OUTPUT_START\")\n+        print(out)\n+        print(\"OUTPUT_END\")\n+        print(\"EXIT_CODE:\", code)\n+        # No assertion, just print result for manual inspection in this environment\n+    except Exception as e:\n+        print(\"TEST_ERROR:\", type(e).__name__, e)\n+    finally:\n+        try:\n+            # Clean up\n+            for root_dir, dirs, files in os.walk(root, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root_dir, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root_dir, name))\n+            os.rmdir(root)\n+        except Exception:\n+            pass\n+\n+if __name__ == \"__main__\":\n+    main()\n\n"
  },
  "sphinx-doc__sphinx-9367": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9367",
    "model_patch": "diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex f541ec0a9..713f4426e 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -214,7 +214,10 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n         if node.elts:\n-            return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n+            if len(node.elts) == 1:\n+                return \"(\" + self.visit(node.elts[0]) + \",)\"\n+            else:\n+                return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n         else:\n             return \"()\"\n \ndiff --git a/tests_repro_verify_tuple.py b/tests_repro_verify_tuple.py\nnew file mode 100644\nindex 000000000..35a7d3385\n--- /dev/null\n+++ b/tests_repro_verify_tuple.py\n@@ -0,0 +1,10 @@\n+from sphinx.pycode import ast as sphinx_ast\n+def test_single_element_tuple():\n+    src = \"x = (1,)\"\n+    module = sphinx_ast.parse(src)\n+    tuple_node = module.body[0].value\n+    out = sphinx_ast.unparse(tuple_node)\n+    print(repr(out))\n+\n+if __name__ == \"__main__\":\n+    test_single_element_tuple()\n\n"
  },
  "sphinx-doc__sphinx-9461": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9461",
    "model_patch": "diff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 1a8ea0973..ffc7b5fea 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -28,6 +28,28 @@ if False:\n \n logger = logging.getLogger(__name__)\n \n+def unwrap_descriptor(obj):\n+    seen = set()\n+    while True:\n+        if obj is None:\n+            break\n+        inner = None\n+        if isinstance(obj, classmethod):\n+            inner = obj.__func__\n+        elif isinstance(obj, staticmethod):\n+            inner = obj.__func__\n+        elif isinstance(obj, property):\n+            inner = obj.fget\n+        else:\n+            break\n+        if inner is obj:\n+            break\n+        if id(inner) in seen:\n+            obj = inner\n+            break\n+        seen.add(id(inner))\n+        obj = inner\n+    return obj\n \n def mangle(subject: Any, name: str) -> str:\n     \"\"\"mangle the given name.\"\"\"\n@@ -277,6 +299,8 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n             value = attrgetter(subject, name)\n             if ismock(value):\n                 value = undecorate(value)\n+value = unwrap_descriptor(value)\n+value = unwrap_classmethod_property(value)\n \n             unmangled = unmangle(subject, name)\n             if unmangled and unmangled not in members:\n@@ -322,3 +346,47 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n         pass\n \n     return members\n+\n+def unwrap_classmethod_property(obj):\n+    seen = set()\n+    while True:\n+        if obj is None:\n+            break\n+        if isinstance(obj, classmethod):\n+            inner = obj.__func__ if hasattr(obj, __func__) else obj\n+            if isinstance(inner, property):\n+                obj = inner.fget\n+            else:\n+                obj = inner\n+        elif isinstance(obj, staticmethod):\n+            inner = obj.__func__\n+            obj = inner\n+        elif isinstance(obj, property):\n+            obj = obj.fget\n+        else:\n+            break\n+        if id(obj) in seen:\n+            break\n+        seen.add(id(obj))\n+    return objdef unwrap_descriptor(obj):\n+    seen = set()\n+    while True:\n+        if obj is None:\n+            break\n+        inner = None\n+        if isinstance(obj, classmethod):\n+            inner = obj.__func__\n+        elif isinstance(obj, staticmethod):\n+            inner = obj.__func__\n+        elif isinstance(obj, property):\n+            inner = obj.fget\n+        else:\n+            break\n+        if inner is obj:\n+            break\n+        if id(inner) in seen:\n+            obj = inner\n+            break\n+        seen.add(id(inner))\n+        obj = inner\n+    return obj\n\n"
  },
  "sphinx-doc__sphinx-9698": {
    "model_name_or_path": "openai/gpt-5-nano",
    "instance_id": "sphinx-doc__sphinx-9698",
    "model_patch": "diff --git a/sphinx/ext/intersphinx.py b/sphinx/ext/intersphinx.py\nindex 4795d1ae2..9a0af5f5b 100644\n--- a/sphinx/ext/intersphinx.py\n+++ b/sphinx/ext/intersphinx.py\n@@ -284,8 +284,10 @@ def missing_reference(app: Sphinx, env: BuildEnvironment, node: pending_xref,\n         objtypes.append('std:option')\n     if 'py:attribute' in objtypes:\n         # Since Sphinx-2.1, properties are stored as py:method\n-        objtypes.append('py:method')\n+        objtypes.append('py:property')\n \n+    if 'py:property' in objtypes and 'py:method' in objtypes:\n+        objtypes.remove('py:method')\n     to_try = [(inventories.main_inventory, target)]\n     if domain:\n         full_qualified_name = env.get_domain(domain).get_full_qualified_name(node)\ndiff --git a/test_intersphinx_patch_robust.py b/test_intersphinx_patch_robust.py\nnew file mode 100644\nindex 000000000..814d01a8f\n--- /dev/null\n+++ b/test_intersphinx_patch_robust.py\n@@ -0,0 +1,21 @@\n+\n+def test_case(objtypes, expected):\n+    t = list(objtypes)\n+    if 'py:property' in t and 'py:method' in t:\n+        t.remove('py:method')\n+    print('case', objtypes, '=>', t, 'expected', expected, 'OK' if t == expected else 'FAIL')\n+\n+def main():\n+    cases = [\n+        (['py:property','py:method','py:attribute'], ['py:property','py:attribute']),\n+        (['py:method','py:attribute'], ['py:method','py:attribute']),\n+        (['py:property','py:attribute'], ['py:property','py:attribute']),\n+        (['py:attribute'], ['py:attribute']),\n+        (['py:property'], ['py:property']),\n+        (['py:method'], ['py:method']),\n+    ]\n+    for objtypes, expected in cases:\n+        test_case(objtypes, expected)\n+\n+if __name__ == '__main__':\n+    main()\ndiff --git a/test_patch_verify.py b/test_patch_verify.py\nnew file mode 100644\nindex 000000000..ed23537af\n--- /dev/null\n+++ b/test_patch_verify.py\n@@ -0,0 +1,9 @@\n+\n+def test():\n+    objtypes = ['py:property','py:method','py:attribute']\n+    if 'py:property' in objtypes and 'py:method' in objtypes:\n+        objtypes.remove('py:method')\n+    print(objtypes)\n+\n+if __name__ == '__main__':\n+    test()\ndiff --git a/test_patch_verify2.py b/test_patch_verify2.py\nnew file mode 100644\nindex 000000000..c85b4d71c\n--- /dev/null\n+++ b/test_patch_verify2.py\n@@ -0,0 +1,9 @@\n+\n+def test():\n+    objtypes = ['py:method','py:attribute']\n+    if 'py:property' in objtypes and 'py:method' in objtypes:\n+        objtypes.remove('py:method')\n+    print(objtypes)\n+\n+if __name__ == '__main__':\n+    test()\n\n"
  }
}