{
  "django__django-11790": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11790",
    "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex a0cfed0995..bb4816ca08 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -62,11 +62,15 @@ class UsernameField(forms.CharField):\n         return unicodedata.normalize('NFKC', super().to_python(value))\n \n     def widget_attrs(self, widget):\n-        return {\n+        attrs = {\n             **super().widget_attrs(widget),\n-            'autocapitalize': 'none',\n-            'autocomplete': 'username',\n-        }\n+         'autocapitalize': 'none',\n+         'autocomplete': 'username',\n+         }\n+        max_length = getattr(self, 'max_length', None)\n+        if max_length is not None:\n+            attrs.setdefault('maxlength', str(max_length))\n+        return attrs\n \n \n class UserCreationForm(forms.ModelForm):\n"
  },
  "django__django-11815": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11815",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..10d34fb2f6 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,12 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        # Prefer referencing enum members by name to avoid depending on the runtime value\n+        # (which may be translated or otherwise non-unique). Use EnumClass['NAME'].\n+        name = self.value.name\n+        imports = {f\"import {module}\"}\n+        return \"%s.%s['%s']\" % (module, enum_class.__name__, name), imports\n+\n \n \n class FloatSerializer(BaseSimpleSerializer):\n@@ -336,4 +339,4 @@ def serializer_factory(value):\n         \"Cannot serialize: %r\\nThere are some values Django cannot serialize into \"\n         \"migration files.\\nFor more, see https://docs.djangoproject.com/en/%s/\"\n         \"topics/migrations/#migration-serializing\" % (value, get_docs_version())\n-    )\n+    )\n\\ No newline at end of file\n"
  },
  "django__django-11848": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11848",
    "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..54d2dd7de5 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,18 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n-            else:\n-                year += 1900\n+            # Two-digit years are interpreted per RFC7231:\n+            # If the year appears to be more than 50 years in the future,\n+            # it represents the most recent year in the past with the same\n+            # last two digits.\n+            cur_year = datetime.datetime.utcnow().year\n+            century_base = (cur_year // 100) * 100\n+            candidate = century_base + year\n+            if candidate - cur_year > 50:\n+                candidate -= 100\n+            elif cur_year - candidate > 50:\n+                candidate += 100\n+            year = candidate\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n"
  },
  "django__django-11880": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11880",
    "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 03cd8af8d7..59838376ab 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -200,6 +200,16 @@ class Field:\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n         result.validators = self.validators[:]\n+        # Ensure error messages dicts are deep-copied so that mutations on a\n+        # copied Field don't affect other Field instances.\n+        if hasattr(self, 'error_messages'):\n+            result.error_messages = copy.deepcopy(self.error_messages, memo)\n+        else:\n+            result.error_messages = {}\n+        if hasattr(self, 'default_error_messages'):\n+            result.default_error_messages = copy.deepcopy(self.default_error_messages, memo)\n+        else:\n+            result.default_error_messages = {}\n         return result\n \n \n"
  },
  "django__django-11885": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11885",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..6464edfb92 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,11 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+        # fast_deletes collects queryset-likes that can be deleted without\n+        # fetching the objects into memory. Use a dict to group deletions by\n+        # model and column set so they can be combined into a single query.\n+        # {(model, frozenset(column_names)): [queryset-like, ...]}\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -191,7 +193,15 @@ class Collector:\n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # objs is a queryset-like; determine model and involved columns.\n+            model = objs.model\n+            # infer the column names used in the filter by inspecting query where possible,\n+            # fallback to primary key if unknown.\n+            try:\n+                cols = frozenset(getattr(objs.query.where, 'columns', [model._meta.pk.attname]))\n+            except Exception:\n+                cols = frozenset([model._meta.pk.attname])\n+            self.fast_deletes.setdefault((model, cols), []).append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n"
  },
  "django__django-11951": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11951",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 794e0faae7..3ed66bd182 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1209,7 +1209,7 @@ class QuerySet:\n         if ignore_conflicts and not connections[self.db].features.supports_ignore_conflicts:\n             raise NotSupportedError('This database backend does not support ignoring conflicts.')\n         ops = connections[self.db].ops\n-        batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))\n+        batch_size = min(batch_size, max(ops.bulk_batch_size(fields, objs), 1)) if batch_size else max(ops.bulk_batch_size(fields, objs), 1)\n         inserted_rows = []\n         bulk_return = connections[self.db].features.can_return_rows_from_bulk_insert\n         for item in [objs[i:i + batch_size] for i in range(0, len(objs), batch_size)]:\n"
  },
  "django__django-11964": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11964",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..694fcb5802 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -60,7 +60,20 @@ class ChoicesMeta(enum.EnumMeta):\n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated choices.\"\"\"\n-    pass\n+    def __str__(self):\n+        # Ensure stringification of enum members returns the underlying value\n+        # (e.g. \"first\") rather than the qualified enum representation\n+        # (e.g. \"MyChoice.FIRST_CHOICE\"). If the value is not a string-like\n+        # object (for example an int), fall back to the default str().\n+        val = self.value\n+        try:\n+            # Prefer returning the value directly for string-like objects and\n+            # django lazy translation promises.\n+            if isinstance(val, (str, Promise)):\n+                return val\n+        except Exception:\n+            pass\n+        return str(val)\n \n \n class IntegerChoices(int, Choices):\n"
  },
  "django__django-11999": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11999",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..c8fd168200 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,14 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            # Only create a get_<field>_display helper if the class itself\n+            # doesn't define one. This allows user-defined methods on models\n+            # (or subclasses) to override the default implementation.\n+            method_name = 'get_%s_display' % self.name\n+            # Check cls.__dict__ to avoid overwriting inherited methods.\n+            if method_name not in cls.__dict__:\n+                setattr(cls, method_name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n"
  },
  "django__django-12039": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12039",
    "model_patch": "diff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex 44e49806f8..c67241a828 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -110,18 +110,22 @@ class IndexColumns(Columns):\n \n     def __str__(self):\n         def col_str(column, idx):\n-            # Index.__init__() guarantees that self.opclasses is the same\n-            # length as self.columns.\n-            col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n+            # Build column string only adding spaces when parts are non-empty\n+            col = self.quote_name(column)\n             try:\n-                col = '{} {}'.format(col, self.col_suffixes[idx])\n+                opclass = self.opclasses[idx]\n+                if opclass:\n+                    col += ' ' + opclass\n+            except IndexError:\n+                pass\n+            try:\n+                suffix = self.col_suffixes[idx]\n+                if suffix:\n+                    col += ' ' + suffix\n             except IndexError:\n                 pass\n             return col\n-\n         return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n-\n-\n class ForeignKeyName(TableColumns):\n     \"\"\"Hold a reference to a foreign key name.\"\"\"\n \ndiff --git a/django/db/backends/ddl_references.py.bak b/django/db/backends/ddl_references.py.bak\nnew file mode 100644\nindex 0000000000..44e49806f8\n--- /dev/null\n+++ b/django/db/backends/ddl_references.py.bak\n@@ -0,0 +1,194 @@\n+\"\"\"\n+Helpers to manipulate deferred DDL statements that might need to be adjusted or\n+discarded within when executing a migration.\n+\"\"\"\n+\n+\n+class Reference:\n+    \"\"\"Base class that defines the reference interface.\"\"\"\n+\n+    def references_table(self, table):\n+        \"\"\"\n+        Return whether or not this instance references the specified table.\n+        \"\"\"\n+        return False\n+\n+    def references_column(self, table, column):\n+        \"\"\"\n+        Return whether or not this instance references the specified column.\n+        \"\"\"\n+        return False\n+\n+    def rename_table_references(self, old_table, new_table):\n+        \"\"\"\n+        Rename all references to the old_name to the new_table.\n+        \"\"\"\n+        pass\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        \"\"\"\n+        Rename all references to the old_column to the new_column.\n+        \"\"\"\n+        pass\n+\n+    def __repr__(self):\n+        return '<%s %r>' % (self.__class__.__name__, str(self))\n+\n+    def __str__(self):\n+        raise NotImplementedError('Subclasses must define how they should be converted to string.')\n+\n+\n+class Table(Reference):\n+    \"\"\"Hold a reference to a table.\"\"\"\n+\n+    def __init__(self, table, quote_name):\n+        self.table = table\n+        self.quote_name = quote_name\n+\n+    def references_table(self, table):\n+        return self.table == table\n+\n+    def rename_table_references(self, old_table, new_table):\n+        if self.table == old_table:\n+            self.table = new_table\n+\n+    def __str__(self):\n+        return self.quote_name(self.table)\n+\n+\n+class TableColumns(Table):\n+    \"\"\"Base class for references to multiple columns of a table.\"\"\"\n+\n+    def __init__(self, table, columns):\n+        self.table = table\n+        self.columns = columns\n+\n+    def references_column(self, table, column):\n+        return self.table == table and column in self.columns\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        if self.table == table:\n+            for index, column in enumerate(self.columns):\n+                if column == old_column:\n+                    self.columns[index] = new_column\n+\n+\n+class Columns(TableColumns):\n+    \"\"\"Hold a reference to one or many columns.\"\"\"\n+\n+    def __init__(self, table, columns, quote_name, col_suffixes=()):\n+        self.quote_name = quote_name\n+        self.col_suffixes = col_suffixes\n+        super().__init__(table, columns)\n+\n+    def __str__(self):\n+        def col_str(column, idx):\n+            try:\n+                return self.quote_name(column) + self.col_suffixes[idx]\n+            except IndexError:\n+                return self.quote_name(column)\n+\n+        return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n+\n+\n+class IndexName(TableColumns):\n+    \"\"\"Hold a reference to an index name.\"\"\"\n+\n+    def __init__(self, table, columns, suffix, create_index_name):\n+        self.suffix = suffix\n+        self.create_index_name = create_index_name\n+        super().__init__(table, columns)\n+\n+    def __str__(self):\n+        return self.create_index_name(self.table, self.columns, self.suffix)\n+\n+\n+class IndexColumns(Columns):\n+    def __init__(self, table, columns, quote_name, col_suffixes=(), opclasses=()):\n+        self.opclasses = opclasses\n+        super().__init__(table, columns, quote_name, col_suffixes)\n+\n+    def __str__(self):\n+        def col_str(column, idx):\n+            # Index.__init__() guarantees that self.opclasses is the same\n+            # length as self.columns.\n+            col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n+            try:\n+                col = '{} {}'.format(col, self.col_suffixes[idx])\n+            except IndexError:\n+                pass\n+            return col\n+\n+        return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n+\n+\n+class ForeignKeyName(TableColumns):\n+    \"\"\"Hold a reference to a foreign key name.\"\"\"\n+\n+    def __init__(self, from_table, from_columns, to_table, to_columns, suffix_template, create_fk_name):\n+        self.to_reference = TableColumns(to_table, to_columns)\n+        self.suffix_template = suffix_template\n+        self.create_fk_name = create_fk_name\n+        super().__init__(from_table, from_columns,)\n+\n+    def references_table(self, table):\n+        return super().references_table(table) or self.to_reference.references_table(table)\n+\n+    def references_column(self, table, column):\n+        return (\n+            super().references_column(table, column) or\n+            self.to_reference.references_column(table, column)\n+        )\n+\n+    def rename_table_references(self, old_table, new_table):\n+        super().rename_table_references(old_table, new_table)\n+        self.to_reference.rename_table_references(old_table, new_table)\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        super().rename_column_references(table, old_column, new_column)\n+        self.to_reference.rename_column_references(table, old_column, new_column)\n+\n+    def __str__(self):\n+        suffix = self.suffix_template % {\n+            'to_table': self.to_reference.table,\n+            'to_column': self.to_reference.columns[0],\n+        }\n+        return self.create_fk_name(self.table, self.columns, suffix)\n+\n+\n+class Statement(Reference):\n+    \"\"\"\n+    Statement template and formatting parameters container.\n+\n+    Allows keeping a reference to a statement without interpolating identifiers\n+    that might have to be adjusted if they're referencing a table or column\n+    that is removed\n+    \"\"\"\n+    def __init__(self, template, **parts):\n+        self.template = template\n+        self.parts = parts\n+\n+    def references_table(self, table):\n+        return any(\n+            hasattr(part, 'references_table') and part.references_table(table)\n+            for part in self.parts.values()\n+        )\n+\n+    def references_column(self, table, column):\n+        return any(\n+            hasattr(part, 'references_column') and part.references_column(table, column)\n+            for part in self.parts.values()\n+        )\n+\n+    def rename_table_references(self, old_table, new_table):\n+        for part in self.parts.values():\n+            if hasattr(part, 'rename_table_references'):\n+                part.rename_table_references(old_table, new_table)\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        for part in self.parts.values():\n+            if hasattr(part, 'rename_column_references'):\n+                part.rename_column_references(table, old_column, new_column)\n+\n+    def __str__(self):\n+        return self.template % self.parts\ndiff --git a/django/db/backends/ddl_references.py.bak2 b/django/db/backends/ddl_references.py.bak2\nnew file mode 100644\nindex 0000000000..44e49806f8\n--- /dev/null\n+++ b/django/db/backends/ddl_references.py.bak2\n@@ -0,0 +1,194 @@\n+\"\"\"\n+Helpers to manipulate deferred DDL statements that might need to be adjusted or\n+discarded within when executing a migration.\n+\"\"\"\n+\n+\n+class Reference:\n+    \"\"\"Base class that defines the reference interface.\"\"\"\n+\n+    def references_table(self, table):\n+        \"\"\"\n+        Return whether or not this instance references the specified table.\n+        \"\"\"\n+        return False\n+\n+    def references_column(self, table, column):\n+        \"\"\"\n+        Return whether or not this instance references the specified column.\n+        \"\"\"\n+        return False\n+\n+    def rename_table_references(self, old_table, new_table):\n+        \"\"\"\n+        Rename all references to the old_name to the new_table.\n+        \"\"\"\n+        pass\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        \"\"\"\n+        Rename all references to the old_column to the new_column.\n+        \"\"\"\n+        pass\n+\n+    def __repr__(self):\n+        return '<%s %r>' % (self.__class__.__name__, str(self))\n+\n+    def __str__(self):\n+        raise NotImplementedError('Subclasses must define how they should be converted to string.')\n+\n+\n+class Table(Reference):\n+    \"\"\"Hold a reference to a table.\"\"\"\n+\n+    def __init__(self, table, quote_name):\n+        self.table = table\n+        self.quote_name = quote_name\n+\n+    def references_table(self, table):\n+        return self.table == table\n+\n+    def rename_table_references(self, old_table, new_table):\n+        if self.table == old_table:\n+            self.table = new_table\n+\n+    def __str__(self):\n+        return self.quote_name(self.table)\n+\n+\n+class TableColumns(Table):\n+    \"\"\"Base class for references to multiple columns of a table.\"\"\"\n+\n+    def __init__(self, table, columns):\n+        self.table = table\n+        self.columns = columns\n+\n+    def references_column(self, table, column):\n+        return self.table == table and column in self.columns\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        if self.table == table:\n+            for index, column in enumerate(self.columns):\n+                if column == old_column:\n+                    self.columns[index] = new_column\n+\n+\n+class Columns(TableColumns):\n+    \"\"\"Hold a reference to one or many columns.\"\"\"\n+\n+    def __init__(self, table, columns, quote_name, col_suffixes=()):\n+        self.quote_name = quote_name\n+        self.col_suffixes = col_suffixes\n+        super().__init__(table, columns)\n+\n+    def __str__(self):\n+        def col_str(column, idx):\n+            try:\n+                return self.quote_name(column) + self.col_suffixes[idx]\n+            except IndexError:\n+                return self.quote_name(column)\n+\n+        return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n+\n+\n+class IndexName(TableColumns):\n+    \"\"\"Hold a reference to an index name.\"\"\"\n+\n+    def __init__(self, table, columns, suffix, create_index_name):\n+        self.suffix = suffix\n+        self.create_index_name = create_index_name\n+        super().__init__(table, columns)\n+\n+    def __str__(self):\n+        return self.create_index_name(self.table, self.columns, self.suffix)\n+\n+\n+class IndexColumns(Columns):\n+    def __init__(self, table, columns, quote_name, col_suffixes=(), opclasses=()):\n+        self.opclasses = opclasses\n+        super().__init__(table, columns, quote_name, col_suffixes)\n+\n+    def __str__(self):\n+        def col_str(column, idx):\n+            # Index.__init__() guarantees that self.opclasses is the same\n+            # length as self.columns.\n+            col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n+            try:\n+                col = '{} {}'.format(col, self.col_suffixes[idx])\n+            except IndexError:\n+                pass\n+            return col\n+\n+        return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n+\n+\n+class ForeignKeyName(TableColumns):\n+    \"\"\"Hold a reference to a foreign key name.\"\"\"\n+\n+    def __init__(self, from_table, from_columns, to_table, to_columns, suffix_template, create_fk_name):\n+        self.to_reference = TableColumns(to_table, to_columns)\n+        self.suffix_template = suffix_template\n+        self.create_fk_name = create_fk_name\n+        super().__init__(from_table, from_columns,)\n+\n+    def references_table(self, table):\n+        return super().references_table(table) or self.to_reference.references_table(table)\n+\n+    def references_column(self, table, column):\n+        return (\n+            super().references_column(table, column) or\n+            self.to_reference.references_column(table, column)\n+        )\n+\n+    def rename_table_references(self, old_table, new_table):\n+        super().rename_table_references(old_table, new_table)\n+        self.to_reference.rename_table_references(old_table, new_table)\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        super().rename_column_references(table, old_column, new_column)\n+        self.to_reference.rename_column_references(table, old_column, new_column)\n+\n+    def __str__(self):\n+        suffix = self.suffix_template % {\n+            'to_table': self.to_reference.table,\n+            'to_column': self.to_reference.columns[0],\n+        }\n+        return self.create_fk_name(self.table, self.columns, suffix)\n+\n+\n+class Statement(Reference):\n+    \"\"\"\n+    Statement template and formatting parameters container.\n+\n+    Allows keeping a reference to a statement without interpolating identifiers\n+    that might have to be adjusted if they're referencing a table or column\n+    that is removed\n+    \"\"\"\n+    def __init__(self, template, **parts):\n+        self.template = template\n+        self.parts = parts\n+\n+    def references_table(self, table):\n+        return any(\n+            hasattr(part, 'references_table') and part.references_table(table)\n+            for part in self.parts.values()\n+        )\n+\n+    def references_column(self, table, column):\n+        return any(\n+            hasattr(part, 'references_column') and part.references_column(table, column)\n+            for part in self.parts.values()\n+        )\n+\n+    def rename_table_references(self, old_table, new_table):\n+        for part in self.parts.values():\n+            if hasattr(part, 'rename_table_references'):\n+                part.rename_table_references(old_table, new_table)\n+\n+    def rename_column_references(self, table, old_column, new_column):\n+        for part in self.parts.values():\n+            if hasattr(part, 'rename_column_references'):\n+                part.rename_column_references(table, old_column, new_column)\n+\n+    def __str__(self):\n+        return self.template % self.parts\ndiff --git a/test_index_columns.py b/test_index_columns.py\nnew file mode 100644\nindex 0000000000..122428d646\n--- /dev/null\n+++ b/test_index_columns.py\n@@ -0,0 +1,12 @@\n+from django.db.backends.ddl_references import IndexColumns\n+def quote_name(x): return '\"%s\"' % x\n+# Case: opclasses present, col_suffixes contains empty strings\n+cols = ['name']\n+opclasses = ['text_pattern_ops']\n+col_suffixes = ['']  # ascending implied\n+ic = IndexColumns('schema_author', cols, quote_name, col_suffixes=col_suffixes, opclasses=opclasses)\n+print(str(ic))\n+# Case: descending ordering provided\n+col_suffixes = ['DESC']\n+ic2 = IndexColumns('schema_author', cols, quote_name, col_suffixes=col_suffixes, opclasses=opclasses)\n+print(str(ic2))\n"
  },
  "django__django-12050": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12050",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ea51912e8b..c45da53422 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,14 @@ class Query(BaseExpression):\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            # Preserve the input iterable type: lists should remain lists,\n+            # tuples should remain tuples. This is important for fields\n+            # (e.g. PickledField) that depend on matching the exact input\n+            # type for lookups.\n+            if isinstance(value, list):\n+                value = resolved_values\n+            else:\n+                value = tuple(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
  },
  "django__django-12143": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12143",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 137e6faa0f..179cc3e27d 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,15 @@ class ModelAdmin(BaseModelAdmin):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+                # Escape dynamic values before inserting into the regex pattern to\n+        # avoid accidental regex metacharacter interpretation.\n+        # prefix can contain arbitrary characters (formset prefixes are not\n+        # restricted to identifier characters), and while pk.name is usually\n+        # a valid identifier, escape it as well for robustness.\n+        pk_pattern = re.compile(\n+            r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(self.model._meta.pk.name))\n+        )\n+\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\n"
  },
  "django__django-12155": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12155",
    "model_patch": "diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 4c0e7e2a56..38fc96927d 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,7 +34,7 @@ def trim_docstring(docstring):\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n+    indent = min(len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip()) if any(line.lstrip() for line in lines[1:]) else 0\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \n"
  },
  "django__django-12193": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12193",
    "model_patch": "diff --git a/django/contrib/postgres/forms/array.py b/django/contrib/postgres/forms/array.py\nindex 2e19cd574a..18cfccf39c 100644\n--- a/django/contrib/postgres/forms/array.py\n+++ b/django/contrib/postgres/forms/array.py\n@@ -147,7 +147,7 @@ class SplitArrayWidget(forms.Widget):\n             if id_:\n                 final_attrs = {**final_attrs, 'id': '%s_%s' % (id_, i)}\n             context['widget']['subwidgets'].append(\n-                self.widget.get_context(name + '_%s' % i, widget_value, final_attrs)['widget']\n+                self.widget.get_context(name + '_%s' % i, widget_value, final_attrs.copy())['widget']\n             )\n         return context\n \n"
  },
  "django__django-12209": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12209",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0..cd37868925 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -847,10 +847,12 @@ class Model(metaclass=ModelBase):\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n-        # Skip an UPDATE when adding an instance and primary key has a default.\n+        # Only force an INSERT when adding an instance and the primary\n+        # key has a default and no explicit pk value was set on the instance.\n         if (\n             not force_insert and\n             self._state.adding and\n+            not pk_set and\n             self._meta.pk.default and\n             self._meta.pk.default is not NOT_PROVIDED\n         ):\n"
  },
  "django__django-12262": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12262",
    "model_patch": "diff --git a/django/template/library.py b/django/template/library.py\nindex 20bc86dac8..394b3d840e 100644\n--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -301,6 +301,11 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n         # Consider the last n params handled, where n is the\n         # number of defaults.\n         unhandled_params = unhandled_params[:-len(defaults)]\n+        # Remove keyword-only args that have defaults from unhandled_kwargs\n+        if kwonly_defaults:\n+            for k in list(unhandled_kwargs):\n+                if k in kwonly_defaults:\n+                    unhandled_kwargs.remove(k)\n     if unhandled_params or unhandled_kwargs:\n         # Some positional arguments were not supplied\n         raise TemplateSyntaxError(\n"
  },
  "django__django-12273": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12273",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..89451ac712 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -839,10 +839,18 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+        # Respect an explicitly cleared primary key (set to None) on the\n+        # instance: don't auto-populate it from defaults/AutoField when the\n+        # user has intentionally reset it.\n         pk_val = self._get_pk_val(meta)\n         if pk_val is None:\n-            pk_val = meta.pk.get_pk_value_on_save(self)\n-            setattr(self, meta.pk.attname, pk_val)\n+            # Only attempt to get a PK value on save if the instance didn't\n+            # explicitly have its PK attribute set to None. Some code may\n+            # intentionally set the PK to None to signal \"create a new row\".\n+            current_attval = getattr(self, meta.pk.attname, None)\n+            if current_attval is not None:\n+                pk_val = meta.pk.get_pk_value_on_save(self)\n+                setattr(self, meta.pk.attname, pk_val)\n         pk_set = pk_val is not None\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n"
  },
  "django__django-12276": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12276",
    "model_patch": ""
  },
  "django__django-12304": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12304",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex f48143ddaf..2ed4740d55 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -6,6 +6,7 @@ __all__ = ['Choices', 'IntegerChoices', 'TextChoices']\n \n \n class ChoicesMeta(enum.EnumMeta):\n+    do_not_call_in_templates = True\n     \"\"\"A metaclass for creating a enum choices.\"\"\"\n \n     def __new__(metacls, classname, bases, classdict):\n@@ -59,6 +60,7 @@ class ChoicesMeta(enum.EnumMeta):\n \n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n+    do_not_call_in_templates = True\n     \"\"\"Class for creating enumerated choices.\"\"\"\n \n     def __str__(self):\n@@ -70,11 +72,13 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n \n \n class IntegerChoices(int, Choices):\n+    do_not_call_in_templates = True\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\n \n \n class TextChoices(str, Choices):\n+    do_not_call_in_templates = True\n     \"\"\"Class for creating enumerated string choices.\"\"\"\n \n     def _generate_next_value_(name, start, count, last_values):\n"
  },
  "django__django-12308": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12308",
    "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex e4ddc8f017..448f530abe 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -398,6 +398,17 @@ def display_for_field(value, field, empty_value_display):\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    # Special-case JSONField: use its prepare_value for readonly display\n+    elif (hasattr(models, 'JSONField') and isinstance(field, models.JSONField)) or field.__class__.__name__ == 'JSONField':\n+        try:\n+            return field.prepare_value(value)\n+        except Exception:\n+            return display_for_value(value, empty_value_display)\n+    elif (hasattr(field, 'get_internal_type') and field.get_internal_type() == 'JSONField'):\n+        try:\n+            return field.prepare_value(value)\n+        except Exception:\n+            return display_for_value(value, empty_value_display)\n     else:\n         return display_for_value(value, empty_value_display)\n \ndiff --git a/django/contrib/admin/utils.py.bak b/django/contrib/admin/utils.py.bak\nnew file mode 100644\nindex 0000000000..e4ddc8f017\n--- /dev/null\n+++ b/django/contrib/admin/utils.py.bak\n@@ -0,0 +1,545 @@\n+import datetime\n+import decimal\n+from collections import defaultdict\n+\n+from django.core.exceptions import FieldDoesNotExist\n+from django.db import models, router\n+from django.db.models.constants import LOOKUP_SEP\n+from django.db.models.deletion import Collector\n+from django.forms.utils import pretty_name\n+from django.urls import NoReverseMatch, reverse\n+from django.utils import formats, timezone\n+from django.utils.html import format_html\n+from django.utils.regex_helper import _lazy_re_compile\n+from django.utils.text import capfirst\n+from django.utils.translation import ngettext, override as translation_override\n+\n+QUOTE_MAP = {i: '_%02X' % i for i in b'\":/_#?;@&=+$,\"[]<>%\\n\\\\'}\n+UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}\n+UNQUOTE_RE = _lazy_re_compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))\n+\n+\n+class FieldIsAForeignKeyColumnName(Exception):\n+    \"\"\"A field is a foreign key attname, i.e. <FK>_id.\"\"\"\n+    pass\n+\n+\n+def lookup_needs_distinct(opts, lookup_path):\n+    \"\"\"\n+    Return True if 'distinct()' should be used to query the given lookup path.\n+    \"\"\"\n+    lookup_fields = lookup_path.split(LOOKUP_SEP)\n+    # Go through the fields (following all relations) and look for an m2m.\n+    for field_name in lookup_fields:\n+        if field_name == 'pk':\n+            field_name = opts.pk.name\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            # Ignore query lookups.\n+            continue\n+        else:\n+            if hasattr(field, 'get_path_info'):\n+                # This field is a relation; update opts to follow the relation.\n+                path_info = field.get_path_info()\n+                opts = path_info[-1].to_opts\n+                if any(path.m2m for path in path_info):\n+                    # This field is a m2m relation so distinct must be called.\n+                    return True\n+    return False\n+\n+\n+def prepare_lookup_value(key, value):\n+    \"\"\"\n+    Return a lookup value prepared to be used in queryset filtering.\n+    \"\"\"\n+    # if key ends with __in, split parameter into separate values\n+    if key.endswith('__in'):\n+        value = value.split(',')\n+    # if key ends with __isnull, special case '' and the string literals 'false' and '0'\n+    elif key.endswith('__isnull'):\n+        value = value.lower() not in ('', 'false', '0')\n+    return value\n+\n+\n+def quote(s):\n+    \"\"\"\n+    Ensure that primary key values do not confuse the admin URLs by escaping\n+    any '/', '_' and ':' and similarly problematic characters.\n+    Similar to urllib.parse.quote(), except that the quoting is slightly\n+    different so that it doesn't get automatically unquoted by the Web browser.\n+    \"\"\"\n+    return s.translate(QUOTE_MAP) if isinstance(s, str) else s\n+\n+\n+def unquote(s):\n+    \"\"\"Undo the effects of quote().\"\"\"\n+    return UNQUOTE_RE.sub(lambda m: UNQUOTE_MAP[m.group(0)], s)\n+\n+\n+def flatten(fields):\n+    \"\"\"\n+    Return a list which is a single level of flattening of the original list.\n+    \"\"\"\n+    flat = []\n+    for field in fields:\n+        if isinstance(field, (list, tuple)):\n+            flat.extend(field)\n+        else:\n+            flat.append(field)\n+    return flat\n+\n+\n+def flatten_fieldsets(fieldsets):\n+    \"\"\"Return a list of field names from an admin fieldsets structure.\"\"\"\n+    field_names = []\n+    for name, opts in fieldsets:\n+        field_names.extend(\n+            flatten(opts['fields'])\n+        )\n+    return field_names\n+\n+\n+def get_deleted_objects(objs, request, admin_site):\n+    \"\"\"\n+    Find all objects related to ``objs`` that should also be deleted. ``objs``\n+    must be a homogeneous iterable of objects (e.g. a QuerySet).\n+\n+    Return a nested list of strings suitable for display in the\n+    template with the ``unordered_list`` filter.\n+    \"\"\"\n+    try:\n+        obj = objs[0]\n+    except IndexError:\n+        return [], {}, set(), []\n+    else:\n+        using = router.db_for_write(obj._meta.model)\n+    collector = NestedObjects(using=using)\n+    collector.collect(objs)\n+    perms_needed = set()\n+\n+    def format_callback(obj):\n+        model = obj.__class__\n+        has_admin = model in admin_site._registry\n+        opts = obj._meta\n+\n+        no_edit_link = '%s: %s' % (capfirst(opts.verbose_name), obj)\n+\n+        if has_admin:\n+            if not admin_site._registry[model].has_delete_permission(request, obj):\n+                perms_needed.add(opts.verbose_name)\n+            try:\n+                admin_url = reverse('%s:%s_%s_change'\n+                                    % (admin_site.name,\n+                                       opts.app_label,\n+                                       opts.model_name),\n+                                    None, (quote(obj.pk),))\n+            except NoReverseMatch:\n+                # Change url doesn't exist -- don't display link to edit\n+                return no_edit_link\n+\n+            # Display a link to the admin page.\n+            return format_html('{}: <a href=\"{}\">{}</a>',\n+                               capfirst(opts.verbose_name),\n+                               admin_url,\n+                               obj)\n+        else:\n+            # Don't display link to edit, because it either has no\n+            # admin or is edited inline.\n+            return no_edit_link\n+\n+    to_delete = collector.nested(format_callback)\n+\n+    protected = [format_callback(obj) for obj in collector.protected]\n+    model_count = {model._meta.verbose_name_plural: len(objs) for model, objs in collector.model_objs.items()}\n+\n+    return to_delete, model_count, perms_needed, protected\n+\n+\n+class NestedObjects(Collector):\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.edges = {}  # {from_instance: [to_instances]}\n+        self.protected = set()\n+        self.model_objs = defaultdict(set)\n+\n+    def add_edge(self, source, target):\n+        self.edges.setdefault(source, []).append(target)\n+\n+    def collect(self, objs, source=None, source_attr=None, **kwargs):\n+        for obj in objs:\n+            if source_attr and not source_attr.endswith('+'):\n+                related_name = source_attr % {\n+                    'class': source._meta.model_name,\n+                    'app_label': source._meta.app_label,\n+                }\n+                self.add_edge(getattr(obj, related_name), obj)\n+            else:\n+                self.add_edge(None, obj)\n+            self.model_objs[obj._meta.model].add(obj)\n+        try:\n+            return super().collect(objs, source_attr=source_attr, **kwargs)\n+        except models.ProtectedError as e:\n+            self.protected.update(e.protected_objects)\n+        except models.RestrictedError as e:\n+            self.protected.update(e.restricted_objects)\n+\n+    def related_objects(self, related_model, related_fields, objs):\n+        qs = super().related_objects(related_model, related_fields, objs)\n+        return qs.select_related(*[related_field.name for related_field in related_fields])\n+\n+    def _nested(self, obj, seen, format_callback):\n+        if obj in seen:\n+            return []\n+        seen.add(obj)\n+        children = []\n+        for child in self.edges.get(obj, ()):\n+            children.extend(self._nested(child, seen, format_callback))\n+        if format_callback:\n+            ret = [format_callback(obj)]\n+        else:\n+            ret = [obj]\n+        if children:\n+            ret.append(children)\n+        return ret\n+\n+    def nested(self, format_callback=None):\n+        \"\"\"\n+        Return the graph as a nested list.\n+        \"\"\"\n+        seen = set()\n+        roots = []\n+        for root in self.edges.get(None, ()):\n+            roots.extend(self._nested(root, seen, format_callback))\n+        return roots\n+\n+    def can_fast_delete(self, *args, **kwargs):\n+        \"\"\"\n+        We always want to load the objects into memory so that we can display\n+        them to the user in confirm page.\n+        \"\"\"\n+        return False\n+\n+\n+def model_format_dict(obj):\n+    \"\"\"\n+    Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',\n+    typically for use with string formatting.\n+\n+    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.\n+    \"\"\"\n+    if isinstance(obj, (models.Model, models.base.ModelBase)):\n+        opts = obj._meta\n+    elif isinstance(obj, models.query.QuerySet):\n+        opts = obj.model._meta\n+    else:\n+        opts = obj\n+    return {\n+        'verbose_name': opts.verbose_name,\n+        'verbose_name_plural': opts.verbose_name_plural,\n+    }\n+\n+\n+def model_ngettext(obj, n=None):\n+    \"\"\"\n+    Return the appropriate `verbose_name` or `verbose_name_plural` value for\n+    `obj` depending on the count `n`.\n+\n+    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.\n+    If `obj` is a `QuerySet` instance, `n` is optional and the length of the\n+    `QuerySet` is used.\n+    \"\"\"\n+    if isinstance(obj, models.query.QuerySet):\n+        if n is None:\n+            n = obj.count()\n+        obj = obj.model\n+    d = model_format_dict(obj)\n+    singular, plural = d[\"verbose_name\"], d[\"verbose_name_plural\"]\n+    return ngettext(singular, plural, n or 0)\n+\n+\n+def lookup_field(name, obj, model_admin=None):\n+    opts = obj._meta\n+    try:\n+        f = _get_non_gfk_field(opts, name)\n+    except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):\n+        # For non-field values, the value is either a method, property or\n+        # returned via a callable.\n+        if callable(name):\n+            attr = name\n+            value = attr(obj)\n+        elif hasattr(model_admin, name) and name != '__str__':\n+            attr = getattr(model_admin, name)\n+            value = attr(obj)\n+        else:\n+            attr = getattr(obj, name)\n+            if callable(attr):\n+                value = attr()\n+            else:\n+                value = attr\n+        f = None\n+    else:\n+        attr = None\n+        value = getattr(obj, name)\n+    return f, attr, value\n+\n+\n+def _get_non_gfk_field(opts, name):\n+    \"\"\"\n+    For historical reasons, the admin app relies on GenericForeignKeys as being\n+    \"not found\" by get_field(). This could likely be cleaned up.\n+\n+    Reverse relations should also be excluded as these aren't attributes of the\n+    model (rather something like `foo_set`).\n+    \"\"\"\n+    field = opts.get_field(name)\n+    if (field.is_relation and\n+            # Generic foreign keys OR reverse relations\n+            ((field.many_to_one and not field.related_model) or field.one_to_many)):\n+        raise FieldDoesNotExist()\n+\n+    # Avoid coercing <FK>_id fields to FK\n+    if field.is_relation and not field.many_to_many and hasattr(field, 'attname') and field.attname == name:\n+        raise FieldIsAForeignKeyColumnName()\n+\n+    return field\n+\n+\n+def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n+    \"\"\"\n+    Return a sensible label for a field name. The name can be a callable,\n+    property (but not created with @property decorator), or the name of an\n+    object's attribute, as well as a model field. If return_attr is True, also\n+    return the resolved attribute (which could be a callable). This will be\n+    None if (and only if) the name refers to a field.\n+    \"\"\"\n+    attr = None\n+    try:\n+        field = _get_non_gfk_field(model._meta, name)\n+        try:\n+            label = field.verbose_name\n+        except AttributeError:\n+            # field is likely a ForeignObjectRel\n+            label = field.related_model._meta.verbose_name\n+    except FieldDoesNotExist:\n+        if name == \"__str__\":\n+            label = str(model._meta.verbose_name)\n+            attr = str\n+        else:\n+            if callable(name):\n+                attr = name\n+            elif hasattr(model_admin, name):\n+                attr = getattr(model_admin, name)\n+            elif hasattr(model, name):\n+                attr = getattr(model, name)\n+            elif form and name in form.fields:\n+                attr = form.fields[name]\n+            else:\n+                message = \"Unable to lookup '%s' on %s\" % (name, model._meta.object_name)\n+                if model_admin:\n+                    message += \" or %s\" % model_admin.__class__.__name__\n+                if form:\n+                    message += \" or %s\" % form.__class__.__name__\n+                raise AttributeError(message)\n+\n+            if hasattr(attr, \"short_description\"):\n+                label = attr.short_description\n+            elif (isinstance(attr, property) and\n+                  hasattr(attr, \"fget\") and\n+                  hasattr(attr.fget, \"short_description\")):\n+                label = attr.fget.short_description\n+            elif callable(attr):\n+                if attr.__name__ == \"<lambda>\":\n+                    label = \"--\"\n+                else:\n+                    label = pretty_name(attr.__name__)\n+            else:\n+                label = pretty_name(name)\n+    except FieldIsAForeignKeyColumnName:\n+        label = pretty_name(name)\n+        attr = name\n+\n+    if return_attr:\n+        return (label, attr)\n+    else:\n+        return label\n+\n+\n+def help_text_for_field(name, model):\n+    help_text = \"\"\n+    try:\n+        field = _get_non_gfk_field(model._meta, name)\n+    except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):\n+        pass\n+    else:\n+        if hasattr(field, 'help_text'):\n+            help_text = field.help_text\n+    return help_text\n+\n+\n+def display_for_field(value, field, empty_value_display):\n+    from django.contrib.admin.templatetags.admin_list import _boolean_icon\n+\n+    if getattr(field, 'flatchoices', None):\n+        return dict(field.flatchoices).get(value, empty_value_display)\n+    # BooleanField needs special-case null-handling, so it comes before the\n+    # general null test.\n+    elif isinstance(field, models.BooleanField):\n+        return _boolean_icon(value)\n+    elif value is None:\n+        return empty_value_display\n+    elif isinstance(field, models.DateTimeField):\n+        return formats.localize(timezone.template_localtime(value))\n+    elif isinstance(field, (models.DateField, models.TimeField)):\n+        return formats.localize(value)\n+    elif isinstance(field, models.DecimalField):\n+        return formats.number_format(value, field.decimal_places)\n+    elif isinstance(field, (models.IntegerField, models.FloatField)):\n+        return formats.number_format(value)\n+    elif isinstance(field, models.FileField) and value:\n+        return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    else:\n+        return display_for_value(value, empty_value_display)\n+\n+\n+def display_for_value(value, empty_value_display, boolean=False):\n+    from django.contrib.admin.templatetags.admin_list import _boolean_icon\n+\n+    if boolean:\n+        return _boolean_icon(value)\n+    elif value is None:\n+        return empty_value_display\n+    elif isinstance(value, bool):\n+        return str(value)\n+    elif isinstance(value, datetime.datetime):\n+        return formats.localize(timezone.template_localtime(value))\n+    elif isinstance(value, (datetime.date, datetime.time)):\n+        return formats.localize(value)\n+    elif isinstance(value, (int, decimal.Decimal, float)):\n+        return formats.number_format(value)\n+    elif isinstance(value, (list, tuple)):\n+        return ', '.join(str(v) for v in value)\n+    else:\n+        return str(value)\n+\n+\n+class NotRelationField(Exception):\n+    pass\n+\n+\n+def get_model_from_relation(field):\n+    if hasattr(field, 'get_path_info'):\n+        return field.get_path_info()[-1].to_opts.model\n+    else:\n+        raise NotRelationField\n+\n+\n+def reverse_field_path(model, path):\n+    \"\"\" Create a reversed field path.\n+\n+    E.g. Given (Order, \"user__groups\"),\n+    return (Group, \"user__order\").\n+\n+    Final field must be a related model, not a data field.\n+    \"\"\"\n+    reversed_path = []\n+    parent = model\n+    pieces = path.split(LOOKUP_SEP)\n+    for piece in pieces:\n+        field = parent._meta.get_field(piece)\n+        # skip trailing data field if extant:\n+        if len(reversed_path) == len(pieces) - 1:  # final iteration\n+            try:\n+                get_model_from_relation(field)\n+            except NotRelationField:\n+                break\n+\n+        # Field should point to another model\n+        if field.is_relation and not (field.auto_created and not field.concrete):\n+            related_name = field.related_query_name()\n+            parent = field.remote_field.model\n+        else:\n+            related_name = field.field.name\n+            parent = field.related_model\n+        reversed_path.insert(0, related_name)\n+    return (parent, LOOKUP_SEP.join(reversed_path))\n+\n+\n+def get_fields_from_path(model, path):\n+    \"\"\" Return list of Fields given path relative to model.\n+\n+    e.g. (ModelX, \"user__groups__name\") -> [\n+        <django.db.models.fields.related.ForeignKey object at 0x...>,\n+        <django.db.models.fields.related.ManyToManyField object at 0x...>,\n+        <django.db.models.fields.CharField object at 0x...>,\n+    ]\n+    \"\"\"\n+    pieces = path.split(LOOKUP_SEP)\n+    fields = []\n+    for piece in pieces:\n+        if fields:\n+            parent = get_model_from_relation(fields[-1])\n+        else:\n+            parent = model\n+        fields.append(parent._meta.get_field(piece))\n+    return fields\n+\n+\n+def construct_change_message(form, formsets, add):\n+    \"\"\"\n+    Construct a JSON structure describing changes from a changed object.\n+    Translations are deactivated so that strings are stored untranslated.\n+    Translation happens later on LogEntry access.\n+    \"\"\"\n+    # Evaluating `form.changed_data` prior to disabling translations is required\n+    # to avoid fields affected by localization from being included incorrectly,\n+    # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.\n+    changed_data = form.changed_data\n+    with translation_override(None):\n+        # Deactivate translations while fetching verbose_name for form\n+        # field labels and using `field_name`, if verbose_name is not provided.\n+        # Translations will happen later on LogEntry access.\n+        changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)\n+\n+    change_message = []\n+    if add:\n+        change_message.append({'added': {}})\n+    elif form.changed_data:\n+        change_message.append({'changed': {'fields': changed_field_labels}})\n+    if formsets:\n+        with translation_override(None):\n+            for formset in formsets:\n+                for added_object in formset.new_objects:\n+                    change_message.append({\n+                        'added': {\n+                            'name': str(added_object._meta.verbose_name),\n+                            'object': str(added_object),\n+                        }\n+                    })\n+                for changed_object, changed_fields in formset.changed_objects:\n+                    change_message.append({\n+                        'changed': {\n+                            'name': str(changed_object._meta.verbose_name),\n+                            'object': str(changed_object),\n+                            'fields': _get_changed_field_labels_from_form(formset.forms[0], changed_fields),\n+                        }\n+                    })\n+                for deleted_object in formset.deleted_objects:\n+                    change_message.append({\n+                        'deleted': {\n+                            'name': str(deleted_object._meta.verbose_name),\n+                            'object': str(deleted_object),\n+                        }\n+                    })\n+    return change_message\n+\n+\n+def _get_changed_field_labels_from_form(form, changed_data):\n+    changed_field_labels = []\n+    for field_name in changed_data:\n+        try:\n+            verbose_field_name = form.fields[field_name].label or field_name\n+        except KeyError:\n+            verbose_field_name = field_name\n+        changed_field_labels.append(str(verbose_field_name))\n+    return changed_field_labels\n"
  },
  "django__django-12325": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12325",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..f589090765 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -201,10 +201,19 @@ class ModelBase(type):\n             if base != new_class and not base._meta.abstract:\n                 continue\n             # Locate OneToOneField instances.\n+            # Prefer fields that are explicitly marked as parent_link=True when\n+            # multiple OneToOneFields relate to the same parent. This avoids\n+            # depending on declaration order of fields/classes.\n             for field in base._meta.local_fields:\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n-                    parent_links[make_model_tuple(related)] = field\n+                    key = make_model_tuple(related)\n+                    # If we already have a parent link for this related model,\n+                    # keep it if it's explicitly marked parent_link. Otherwise,\n+                    # replace it only if the new field has parent_link=True.\n+                    existing = parent_links.get(key)\n+                    if existing is None or (getattr(field.remote_field, 'parent_link', False) and not getattr(existing.remote_field, 'parent_link', False)):\n+                        parent_links[key] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n"
  },
  "django__django-12406": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12406",
    "model_patch": ""
  },
  "django__django-12708": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12708",
    "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..403ee211b2 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,8 +403,15 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        # When deleting an index (not a unique constraint), exclude unique constraints\n+        exclude = meta_constraint_names | meta_index_names\n+        # If we're deleting an index, also exclude unique constraints to avoid matching both\n+        if sql == self.sql_delete_index:\n+            # Exclude names of UNIQUE constraints to prevent conflicts with index names\n+            unique_names = {c.name for c in model._meta.constraints if getattr(c, '__class__', None) and getattr(c, 'name', None)}\n+            exclude |= unique_names\n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude,\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n"
  },
  "django__django-12713": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12713",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 69a5fbf389..d156b4303e 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -265,6 +265,15 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n             if queryset is not None:\n                 kwargs['queryset'] = queryset\n \n+        # Allow widget to be a callable that accepts (db_field, request)\n+        widget = kwargs.get('widget')\n+        if callable(widget):\n+            try:\n+                kwargs['widget'] = widget(db_field, request)\n+            except TypeError:\n+                # Fallback: call with only db_field if callable accepts single arg\n+                kwargs['widget'] = widget(db_field)\n+\n         form_field = db_field.formfield(**kwargs)\n         if (isinstance(form_field.widget, SelectMultiple) and\n                 not isinstance(form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple))):\n"
  },
  "django__django-12774": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12774",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex d9c9b0db04..a4381bffed 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -689,8 +689,17 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\n-        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n-            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+        if field_name != 'pk':\n+            field = self.model._meta.get_field(field_name)\n+            is_unique_field = getattr(field, 'unique', False)\n+            # Also consider UniqueConstraint on a single field as unique.\n+            if not is_unique_field:\n+                for constraint in getattr(self.model._meta, 'constraints', []):\n+                    if getattr(constraint, 'fields', None) is not None and len(constraint.fields) == 1 and constraint.fields[0] == field_name:\n+                        is_unique_field = True\n+                        break\n+            if not is_unique_field:\n+                raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\n"
  },
  "django__django-9296": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-9296",
    "model_patch": "diff --git a/django/core/paginator.py b/django/core/paginator.py\nindex 1f92da5d4f..9a0e11d6cf 100644\n--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -106,6 +106,11 @@ class Paginator:\n         \"\"\"\n         return range(1, self.num_pages + 1)\n \n+    def __iter__(self):\n+        \"\"\"Iterate over the pages (yields Page instances).\"\"\"\n+        for page_num in self.page_range:\n+            yield self.page(page_num)\n+\n     def _check_object_list_is_ordered(self):\n         \"\"\"\n         Warn if self.object_list is unordered (typically a QuerySet).\n"
  },
  "sphinx-doc__sphinx-10323": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10323",
    "model_patch": "diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py\nindex dc44ed314..9437fe9a5 100644\n--- a/sphinx/directives/code.py\n+++ b/sphinx/directives/code.py\n@@ -224,9 +224,9 @@ class LiteralIncludeReader:\n                        self.start_filter,\n                        self.end_filter,\n                        self.lines_filter,\n+                       self.dedent_filter,\n                        self.prepend_filter,\n-                       self.append_filter,\n-                       self.dedent_filter]\n+                       self.append_filter]\n             lines = self.read_file(self.filename, location=location)\n             for func in filters:\n                 lines = func(lines, location=location)\n"
  },
  "sphinx-doc__sphinx-10435": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10435",
    "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex e0c7d56f8..3abde2cf5 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -1,2061 +1,4124 @@\n+1: \"\"\"Custom docutils writer for LaTeX.\n \"\"\"Custom docutils writer for LaTeX.\n+2: \n \n+3: Much of this code is adapted from Dave Kuhlman's \"docpy\" writer from his\n Much of this code is adapted from Dave Kuhlman's \"docpy\" writer from his\n+4: docutils sandbox.\n docutils sandbox.\n+5: \"\"\"\n \"\"\"\n+6: \n \n+7: import re\n import re\n+8: import warnings\n import warnings\n+9: from collections import defaultdict\n from collections import defaultdict\n+10: from os import path\n from os import path\n+11: from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast\n from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast\n+12: \n \n+13: from docutils import nodes, writers\n from docutils import nodes, writers\n+14: from docutils.nodes import Element, Node, Text\n from docutils.nodes import Element, Node, Text\n+15: \n \n+16: from sphinx import addnodes, highlighting\n from sphinx import addnodes, highlighting\n+17: from sphinx.deprecation import RemovedInSphinx70Warning\n from sphinx.deprecation import RemovedInSphinx70Warning\n+18: from sphinx.domains import IndexEntry\n from sphinx.domains import IndexEntry\n+19: from sphinx.domains.std import StandardDomain\n from sphinx.domains.std import StandardDomain\n+20: from sphinx.errors import SphinxError\n from sphinx.errors import SphinxError\n+21: from sphinx.locale import _, __, admonitionlabels\n from sphinx.locale import _, __, admonitionlabels\n+22: from sphinx.util import logging, split_into, texescape\n from sphinx.util import logging, split_into, texescape\n+23: from sphinx.util.docutils import SphinxTranslator\n from sphinx.util.docutils import SphinxTranslator\n+24: from sphinx.util.nodes import clean_astext, get_prev_node\n from sphinx.util.nodes import clean_astext, get_prev_node\n+25: from sphinx.util.template import LaTeXRenderer\n from sphinx.util.template import LaTeXRenderer\n+26: from sphinx.util.texescape import tex_replace_map\n from sphinx.util.texescape import tex_replace_map\n+27: \n \n+28: try:\n try:\n+29:     from docutils.utils.roman import toRoman\n     from docutils.utils.roman import toRoman\n+30: except ImportError:\n except ImportError:\n+31:     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman\n     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman\n+32:     from roman import toRoman  # type: ignore\n     from roman import toRoman  # type: ignore\n+33: \n \n+34: if TYPE_CHECKING:\n if TYPE_CHECKING:\n+35:     from sphinx.builders.latex import LaTeXBuilder\n     from sphinx.builders.latex import LaTeXBuilder\n+36:     from sphinx.builders.latex.theming import Theme\n     from sphinx.builders.latex.theming import Theme\n+37: \n \n+38: \n \n+39: logger = logging.getLogger(__name__)\n logger = logging.getLogger(__name__)\n+40: \n \n+41: MAX_CITATION_LABEL_LENGTH = 8\n MAX_CITATION_LABEL_LENGTH = 8\n+42: LATEXSECTIONNAMES = [\"part\", \"chapter\", \"section\", \"subsection\",\n LATEXSECTIONNAMES = [\"part\", \"chapter\", \"section\", \"subsection\",\n+43:                      \"subsubsection\", \"paragraph\", \"subparagraph\"]\n                      \"subsubsection\", \"paragraph\", \"subparagraph\"]\n+44: ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\\arabic',\n ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\\arabic',\n+45:                                    {\n                                    {\n+46:                                        'arabic': r'\\arabic',\n                                        'arabic': r'\\arabic',\n+47:                                        'loweralpha': r'\\alph',\n                                        'loweralpha': r'\\alph',\n+48:                                        'upperalpha': r'\\Alph',\n                                        'upperalpha': r'\\Alph',\n+49:                                        'lowerroman': r'\\roman',\n                                        'lowerroman': r'\\roman',\n+50:                                        'upperroman': r'\\Roman',\n                                        'upperroman': r'\\Roman',\n+51:                                    })\n                                    })\n+52: \n \n+53: CR = '\\n'\n CR = '\\n'\n+54: BLANKLINE = '\\n\\n'\n BLANKLINE = '\\n\\n'\n+55: EXTRA_RE = re.compile(r'^(.*\\S)\\s+\\(([^()]*)\\)\\s*$')\n EXTRA_RE = re.compile(r'^(.*\\S)\\s+\\(([^()]*)\\)\\s*$')\n+56: \n \n+57: \n \n+58: class collected_footnote(nodes.footnote):\n class collected_footnote(nodes.footnote):\n+59:     \"\"\"Footnotes that are collected are assigned this class.\"\"\"\n     \"\"\"Footnotes that are collected are assigned this class.\"\"\"\n+60: \n \n+61: \n \n+62: class UnsupportedError(SphinxError):\n class UnsupportedError(SphinxError):\n+63:     category = 'Markup is unsupported in LaTeX'\n     category = 'Markup is unsupported in LaTeX'\n+64: \n \n+65: \n \n+66: class LaTeXWriter(writers.Writer):\n class LaTeXWriter(writers.Writer):\n+67: \n \n+68:     supported = ('sphinxlatex',)\n     supported = ('sphinxlatex',)\n+69: \n \n+70:     settings_spec = ('LaTeX writer options', '', (\n     settings_spec = ('LaTeX writer options', '', (\n+71:         ('Document name', ['--docname'], {'default': ''}),\n         ('Document name', ['--docname'], {'default': ''}),\n+72:         ('Document class', ['--docclass'], {'default': 'manual'}),\n         ('Document class', ['--docclass'], {'default': 'manual'}),\n+73:         ('Author', ['--author'], {'default': ''}),\n         ('Author', ['--author'], {'default': ''}),\n+74:     ))\n     ))\n+75:     settings_defaults: Dict = {}\n     settings_defaults: Dict = {}\n+76: \n \n+77:     output = None\n     output = None\n+78: \n \n+79:     def __init__(self, builder: \"LaTeXBuilder\") -> None:\n     def __init__(self, builder: \"LaTeXBuilder\") -> None:\n+80:         super().__init__()\n         super().__init__()\n+81:         self.builder = builder\n         self.builder = builder\n+82:         self.theme: Theme = None\n         self.theme: Theme = None\n+83: \n \n+84:     def translate(self) -> None:\n     def translate(self) -> None:\n+85:         visitor = self.builder.create_translator(self.document, self.builder, self.theme)\n         visitor = self.builder.create_translator(self.document, self.builder, self.theme)\n+86:         self.document.walkabout(visitor)\n         self.document.walkabout(visitor)\n+87:         self.output = cast(LaTeXTranslator, visitor).astext()\n         self.output = cast(LaTeXTranslator, visitor).astext()\n+88: \n \n+89: \n \n+90: # Helper classes\n # Helper classes\n+91: \n \n+92: class Table:\n class Table:\n+93:     \"\"\"A table data\"\"\"\n     \"\"\"A table data\"\"\"\n+94: \n \n+95:     def __init__(self, node: Element) -> None:\n     def __init__(self, node: Element) -> None:\n+96:         self.header: List[str] = []\n         self.header: List[str] = []\n+97:         self.body: List[str] = []\n         self.body: List[str] = []\n+98:         self.align = node.get('align', 'default')\n         self.align = node.get('align', 'default')\n+99:         self.classes: List[str] = node.get('classes', [])\n         self.classes: List[str] = node.get('classes', [])\n+100:         self.colcount = 0\n         self.colcount = 0\n+101:         self.colspec: str = None\n         self.colspec: str = None\n+102:         self.colwidths: List[int] = []\n         self.colwidths: List[int] = []\n+103:         self.has_problematic = False\n         self.has_problematic = False\n+104:         self.has_oldproblematic = False\n         self.has_oldproblematic = False\n+105:         self.has_verbatim = False\n         self.has_verbatim = False\n+106:         self.caption: List[str] = None\n         self.caption: List[str] = None\n+107:         self.stubs: List[int] = []\n         self.stubs: List[int] = []\n+108: \n \n+109:         # current position\n         # current position\n+110:         self.col = 0\n         self.col = 0\n+111:         self.row = 0\n         self.row = 0\n+112: \n \n+113:         # A dict mapping a table location to a cell_id (cell = rectangular area)\n         # A dict mapping a table location to a cell_id (cell = rectangular area)\n+114:         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)\n         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)\n+115:         self.cell_id = 0  # last assigned cell_id\n         self.cell_id = 0  # last assigned cell_id\n+116: \n \n+117:     def is_longtable(self) -> bool:\n     def is_longtable(self) -> bool:\n+118:         \"\"\"True if and only if table uses longtable environment.\"\"\"\n         \"\"\"True if and only if table uses longtable environment.\"\"\"\n+119:         return self.row > 30 or 'longtable' in self.classes\n         return self.row > 30 or 'longtable' in self.classes\n+120: \n \n+121:     def get_table_type(self) -> str:\n     def get_table_type(self) -> str:\n+122:         \"\"\"Returns the LaTeX environment name for the table.\n         \"\"\"Returns the LaTeX environment name for the table.\n+123: \n \n+124:         The class currently supports:\n         The class currently supports:\n+125: \n \n+126:         * longtable\n         * longtable\n+127:         * tabular\n         * tabular\n+128:         * tabulary\n         * tabulary\n+129:         \"\"\"\n         \"\"\"\n+130:         if self.is_longtable():\n         if self.is_longtable():\n+131:             return 'longtable'\n             return 'longtable'\n+132:         elif self.has_verbatim:\n         elif self.has_verbatim:\n+133:             return 'tabular'\n             return 'tabular'\n+134:         elif self.colspec:\n         elif self.colspec:\n+135:             return 'tabulary'\n             return 'tabulary'\n+136:         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):\n         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):\n+137:             return 'tabular'\n             return 'tabular'\n+138:         else:\n         else:\n+139:             return 'tabulary'\n             return 'tabulary'\n+140: \n \n+141:     def get_colspec(self) -> str:\n     def get_colspec(self) -> str:\n+142:         \"\"\"Returns a column spec of table.\n         \"\"\"Returns a column spec of table.\n+143: \n \n+144:         This is what LaTeX calls the 'preamble argument' of the used table environment.\n         This is what LaTeX calls the 'preamble argument' of the used table environment.\n+145: \n \n+146:         .. note:: the ``\\\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.\n         .. note:: the ``\\\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.\n+147:         \"\"\"\n         \"\"\"\n+148:         if self.colspec:\n         if self.colspec:\n+149:             return self.colspec\n             return self.colspec\n+150:         elif self.colwidths and 'colwidths-given' in self.classes:\n         elif self.colwidths and 'colwidths-given' in self.classes:\n+151:             total = sum(self.colwidths)\n             total = sum(self.colwidths)\n+152:             colspecs = [r'\\X{%d}{%d}' % (width, total) for width in self.colwidths]\n             colspecs = [r'\\X{%d}{%d}' % (width, total) for width in self.colwidths]\n+153:             return '{|%s|}' % '|'.join(colspecs) + CR\n             return '{|%s|}' % '|'.join(colspecs) + CR\n+154:         elif self.has_problematic:\n         elif self.has_problematic:\n+155:             return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n             return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n+156:         elif self.get_table_type() == 'tabulary':\n         elif self.get_table_type() == 'tabulary':\n+157:             # sphinx.sty sets T to be J by default.\n             # sphinx.sty sets T to be J by default.\n+158:             return '{|' + ('T|' * self.colcount) + '}' + CR\n             return '{|' + ('T|' * self.colcount) + '}' + CR\n+159:         elif self.has_oldproblematic:\n         elif self.has_oldproblematic:\n+160:             return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n             return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n+161:         else:\n         else:\n+162:             return '{|' + ('l|' * self.colcount) + '}' + CR\n             return '{|' + ('l|' * self.colcount) + '}' + CR\n+163: \n \n+164:     def add_cell(self, height: int, width: int) -> None:\n     def add_cell(self, height: int, width: int) -> None:\n+165:         \"\"\"Adds a new cell to a table.\n         \"\"\"Adds a new cell to a table.\n+166: \n \n+167:         It will be located at current position: (``self.row``, ``self.col``).\n         It will be located at current position: (``self.row``, ``self.col``).\n+168:         \"\"\"\n         \"\"\"\n+169:         self.cell_id += 1\n         self.cell_id += 1\n+170:         for col in range(width):\n         for col in range(width):\n+171:             for row in range(height):\n             for row in range(height):\n+172:                 assert self.cells[(self.row + row, self.col + col)] == 0\n                 assert self.cells[(self.row + row, self.col + col)] == 0\n+173:                 self.cells[(self.row + row, self.col + col)] = self.cell_id\n                 self.cells[(self.row + row, self.col + col)] = self.cell_id\n+174: \n \n+175:     def cell(self, row: int = None, col: int = None) -> \"TableCell\":\n     def cell(self, row: int = None, col: int = None) -> \"TableCell\":\n+176:         \"\"\"Returns a cell object (i.e. rectangular area) containing given position.\n         \"\"\"Returns a cell object (i.e. rectangular area) containing given position.\n+177: \n \n+178:         If no option arguments: ``row`` or ``col`` are given, the current position;\n         If no option arguments: ``row`` or ``col`` are given, the current position;\n+179:         ``self.row`` and ``self.col`` are used to get a cell object by default.\n         ``self.row`` and ``self.col`` are used to get a cell object by default.\n+180:         \"\"\"\n         \"\"\"\n+181:         try:\n         try:\n+182:             if row is None:\n             if row is None:\n+183:                 row = self.row\n                 row = self.row\n+184:             if col is None:\n             if col is None:\n+185:                 col = self.col\n                 col = self.col\n+186:             return TableCell(self, row, col)\n             return TableCell(self, row, col)\n+187:         except IndexError:\n         except IndexError:\n+188:             return None\n             return None\n+189: \n \n+190: \n \n+191: class TableCell:\n class TableCell:\n+192:     \"\"\"Data of a cell in a table.\"\"\"\n     \"\"\"Data of a cell in a table.\"\"\"\n+193: \n \n+194:     def __init__(self, table: Table, row: int, col: int) -> None:\n     def __init__(self, table: Table, row: int, col: int) -> None:\n+195:         if table.cells[(row, col)] == 0:\n         if table.cells[(row, col)] == 0:\n+196:             raise IndexError\n             raise IndexError\n+197: \n \n+198:         self.table = table\n         self.table = table\n+199:         self.cell_id = table.cells[(row, col)]\n         self.cell_id = table.cells[(row, col)]\n+200:         self.row = row\n         self.row = row\n+201:         self.col = col\n         self.col = col\n+202: \n \n+203:         # adjust position for multirow/multicol cell\n         # adjust position for multirow/multicol cell\n+204:         while table.cells[(self.row - 1, self.col)] == self.cell_id:\n         while table.cells[(self.row - 1, self.col)] == self.cell_id:\n+205:             self.row -= 1\n             self.row -= 1\n+206:         while table.cells[(self.row, self.col - 1)] == self.cell_id:\n         while table.cells[(self.row, self.col - 1)] == self.cell_id:\n+207:             self.col -= 1\n             self.col -= 1\n+208: \n \n+209:     @property\n     @property\n+210:     def width(self) -> int:\n     def width(self) -> int:\n+211:         \"\"\"Returns the cell width.\"\"\"\n         \"\"\"Returns the cell width.\"\"\"\n+212:         width = 0\n         width = 0\n+213:         while self.table.cells[(self.row, self.col + width)] == self.cell_id:\n         while self.table.cells[(self.row, self.col + width)] == self.cell_id:\n+214:             width += 1\n             width += 1\n+215:         return width\n         return width\n+216: \n \n+217:     @property\n     @property\n+218:     def height(self) -> int:\n     def height(self) -> int:\n+219:         \"\"\"Returns the cell height.\"\"\"\n         \"\"\"Returns the cell height.\"\"\"\n+220:         height = 0\n         height = 0\n+221:         while self.table.cells[(self.row + height, self.col)] == self.cell_id:\n         while self.table.cells[(self.row + height, self.col)] == self.cell_id:\n+222:             height += 1\n             height += 1\n+223:         return height\n         return height\n+224: \n \n+225: \n \n+226: def escape_abbr(text: str) -> str:\n def escape_abbr(text: str) -> str:\n+227:     \"\"\"Adjust spacing after abbreviations.\"\"\"\n     \"\"\"Adjust spacing after abbreviations.\"\"\"\n+228:     return re.sub(r'\\.(?=\\s|$)', r'.\\@', text)\n     return re.sub(r'\\.(?=\\s|$)', r'.\\@', text)\n+229: \n \n+230: \n \n+231: def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:\n def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:\n+232:     \"\"\"Convert `width_str` with rst length to LaTeX length.\"\"\"\n     \"\"\"Convert `width_str` with rst length to LaTeX length.\"\"\"\n+233:     match = re.match(r'^(\\d*\\.?\\d*)\\s*(\\S*)$', width_str)\n     match = re.match(r'^(\\d*\\.?\\d*)\\s*(\\S*)$', width_str)\n+234:     if not match:\n     if not match:\n+235:         raise ValueError\n         raise ValueError\n+236:     res = width_str\n     res = width_str\n+237:     amount, unit = match.groups()[:2]\n     amount, unit = match.groups()[:2]\n+238:     if scale == 100:\n     if scale == 100:\n+239:         float(amount)  # validate amount is float\n         float(amount)  # validate amount is float\n+240:         if unit in ('', \"px\"):\n         if unit in ('', \"px\"):\n+241:             res = r\"%s\\sphinxpxdimen\" % amount\n             res = r\"%s\\sphinxpxdimen\" % amount\n+242:         elif unit == 'pt':\n         elif unit == 'pt':\n+243:             res = '%sbp' % amount  # convert to 'bp'\n             res = '%sbp' % amount  # convert to 'bp'\n+244:         elif unit == \"%\":\n         elif unit == \"%\":\n+245:             res = r\"%.3f\\linewidth\" % (float(amount) / 100.0)\n             res = r\"%.3f\\linewidth\" % (float(amount) / 100.0)\n+246:     else:\n     else:\n+247:         amount_float = float(amount) * scale / 100.0\n         amount_float = float(amount) * scale / 100.0\n+248:         if unit in ('', \"px\"):\n         if unit in ('', \"px\"):\n+249:             res = r\"%.5f\\sphinxpxdimen\" % amount_float\n             res = r\"%.5f\\sphinxpxdimen\" % amount_float\n+250:         elif unit == 'pt':\n         elif unit == 'pt':\n+251:             res = '%.5fbp' % amount_float\n             res = '%.5fbp' % amount_float\n+252:         elif unit == \"%\":\n         elif unit == \"%\":\n+253:             res = r\"%.5f\\linewidth\" % (amount_float / 100.0)\n             res = r\"%.5f\\linewidth\" % (amount_float / 100.0)\n+254:         else:\n         else:\n+255:             res = \"%.5f%s\" % (amount_float, unit)\n             res = \"%.5f%s\" % (amount_float, unit)\n+256:     return res\n     return res\n+257: \n \n+258: \n \n+259: class LaTeXTranslator(SphinxTranslator):\n class LaTeXTranslator(SphinxTranslator):\n+260:     builder: \"LaTeXBuilder\" = None\n     builder: \"LaTeXBuilder\" = None\n+261: \n \n+262:     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls\n     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls\n+263:     # default is originally 3. For book/report, 2 is already LaTeX default.\n     # default is originally 3. For book/report, 2 is already LaTeX default.\n+264:     ignore_missing_images = False\n     ignore_missing_images = False\n+265: \n \n+266:     def __init__(self, document: nodes.document, builder: \"LaTeXBuilder\",\n     def __init__(self, document: nodes.document, builder: \"LaTeXBuilder\",\n+267:                  theme: \"Theme\") -> None:\n                  theme: \"Theme\") -> None:\n+268:         super().__init__(document, builder)\n         super().__init__(document, builder)\n+269:         self.body: List[str] = []\n         self.body: List[str] = []\n+270:         self.theme = theme\n         self.theme = theme\n+271: \n \n+272:         # flags\n         # flags\n+273:         self.in_title = 0\n         self.in_title = 0\n+274:         self.in_production_list = 0\n         self.in_production_list = 0\n+275:         self.in_footnote = 0\n         self.in_footnote = 0\n+276:         self.in_caption = 0\n         self.in_caption = 0\n+277:         self.in_term = 0\n         self.in_term = 0\n+278:         self.needs_linetrimming = 0\n         self.needs_linetrimming = 0\n+279:         self.in_minipage = 0\n         self.in_minipage = 0\n+280:         self.no_latex_floats = 0\n         self.no_latex_floats = 0\n+281:         self.first_document = 1\n         self.first_document = 1\n+282:         self.this_is_the_title = 1\n         self.this_is_the_title = 1\n+283:         self.literal_whitespace = 0\n         self.literal_whitespace = 0\n+284:         self.in_parsed_literal = 0\n         self.in_parsed_literal = 0\n+285:         self.compact_list = 0\n         self.compact_list = 0\n+286:         self.first_param = 0\n         self.first_param = 0\n+287:         self.in_desc_signature = False\n         self.in_desc_signature = False\n+288: \n \n+289:         sphinxpkgoptions = []\n         sphinxpkgoptions = []\n+290: \n \n+291:         # sort out some elements\n         # sort out some elements\n+292:         self.elements = self.builder.context.copy()\n         self.elements = self.builder.context.copy()\n+293: \n \n+294:         # initial section names\n         # initial section names\n+295:         self.sectionnames = LATEXSECTIONNAMES[:]\n         self.sectionnames = LATEXSECTIONNAMES[:]\n+296:         if self.theme.toplevel_sectioning == 'section':\n         if self.theme.toplevel_sectioning == 'section':\n+297:             self.sectionnames.remove('chapter')\n             self.sectionnames.remove('chapter')\n+298: \n \n+299:         # determine top section level\n         # determine top section level\n+300:         self.top_sectionlevel = 1\n         self.top_sectionlevel = 1\n+301:         if self.config.latex_toplevel_sectioning:\n         if self.config.latex_toplevel_sectioning:\n+302:             try:\n             try:\n+303:                 self.top_sectionlevel = \\\n                 self.top_sectionlevel = \\\n+304:                     self.sectionnames.index(self.config.latex_toplevel_sectioning)\n                     self.sectionnames.index(self.config.latex_toplevel_sectioning)\n+305:             except ValueError:\n             except ValueError:\n+306:                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %\n                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %\n+307:                                (self.config.latex_toplevel_sectioning, self.theme.docclass))\n                                (self.config.latex_toplevel_sectioning, self.theme.docclass))\n+308: \n \n+309:         if self.config.numfig:\n         if self.config.numfig:\n+310:             self.numfig_secnum_depth = self.config.numfig_secnum_depth\n             self.numfig_secnum_depth = self.config.numfig_secnum_depth\n+311:             if self.numfig_secnum_depth > 0:  # default is 1\n             if self.numfig_secnum_depth > 0:  # default is 1\n+312:                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in\n                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in\n+313:                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...\n                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...\n+314:                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n+315:                    self.top_sectionlevel > 0:\n                    self.top_sectionlevel > 0:\n+316:                     self.numfig_secnum_depth += self.top_sectionlevel\n                     self.numfig_secnum_depth += self.top_sectionlevel\n+317:                 else:\n                 else:\n+318:                     self.numfig_secnum_depth += self.top_sectionlevel - 1\n                     self.numfig_secnum_depth += self.top_sectionlevel - 1\n+319:                 # this (minus one) will serve as minimum to LaTeX's secnumdepth\n                 # this (minus one) will serve as minimum to LaTeX's secnumdepth\n+320:                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,\n                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,\n+321:                                                len(LATEXSECTIONNAMES) - 1)\n                                                len(LATEXSECTIONNAMES) - 1)\n+322:                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty\n                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty\n+323:                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)\n                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)\n+324:             else:\n             else:\n+325:                 sphinxpkgoptions.append('nonumfigreset')\n                 sphinxpkgoptions.append('nonumfigreset')\n+326: \n \n+327:         if self.config.numfig and self.config.math_numfig:\n         if self.config.numfig and self.config.math_numfig:\n+328:             sphinxpkgoptions.append('mathnumfig')\n             sphinxpkgoptions.append('mathnumfig')\n+329: \n \n+330:         if (self.config.language not in {'en', 'ja'} and\n         if (self.config.language not in {'en', 'ja'} and\n+331:                 'fncychap' not in self.config.latex_elements):\n                 'fncychap' not in self.config.latex_elements):\n+332:             # use Sonny style if any language specified (except English)\n             # use Sonny style if any language specified (except English)\n+333:             self.elements['fncychap'] = (r'\\usepackage[Sonny]{fncychap}' + CR +\n             self.elements['fncychap'] = (r'\\usepackage[Sonny]{fncychap}' + CR +\n+334:                                          r'\\ChNameVar{\\Large\\normalfont\\sffamily}' + CR +\n                                          r'\\ChNameVar{\\Large\\normalfont\\sffamily}' + CR +\n+335:                                          r'\\ChTitleVar{\\Large\\normalfont\\sffamily}')\n                                          r'\\ChTitleVar{\\Large\\normalfont\\sffamily}')\n+336: \n \n+337:         self.babel = self.builder.babel\n         self.babel = self.builder.babel\n+338:         if not self.babel.is_supported_language():\n         if not self.babel.is_supported_language():\n+339:             # emit warning if specified language is invalid\n             # emit warning if specified language is invalid\n+340:             # (only emitting, nothing changed to processing)\n             # (only emitting, nothing changed to processing)\n+341:             logger.warning(__('no Babel option known for language %r'),\n             logger.warning(__('no Babel option known for language %r'),\n+342:                            self.config.language)\n                            self.config.language)\n+343: \n \n+344:         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto\n         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto\n+345:         if self.document.get('tocdepth'):\n         if self.document.get('tocdepth'):\n+346:             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel\n             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel\n+347:             #   tocdepth = -1: show only parts\n             #   tocdepth = -1: show only parts\n+348:             #   tocdepth =  0: show parts and chapters\n             #   tocdepth =  0: show parts and chapters\n+349:             #   tocdepth =  1: show parts, chapters and sections\n             #   tocdepth =  1: show parts, chapters and sections\n+350:             #   tocdepth =  2: show parts, chapters, sections and subsections\n             #   tocdepth =  2: show parts, chapters, sections and subsections\n+351:             #   ...\n             #   ...\n+352:             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2\n             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2\n+353:             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n+354:                self.top_sectionlevel > 0:\n                self.top_sectionlevel > 0:\n+355:                 tocdepth += 1  # because top_sectionlevel is shifted by -1\n                 tocdepth += 1  # because top_sectionlevel is shifted by -1\n+356:             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph\n             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph\n+357:                 logger.warning(__('too large :maxdepth:, ignored.'))\n                 logger.warning(__('too large :maxdepth:, ignored.'))\n+358:                 tocdepth = len(LATEXSECTIONNAMES) - 2\n                 tocdepth = len(LATEXSECTIONNAMES) - 2\n+359: \n \n+360:             self.elements['tocdepth'] = r'\\setcounter{tocdepth}{%d}' % tocdepth\n             self.elements['tocdepth'] = r'\\setcounter{tocdepth}{%d}' % tocdepth\n+361:             minsecnumdepth = max(minsecnumdepth, tocdepth)\n             minsecnumdepth = max(minsecnumdepth, tocdepth)\n+362: \n \n+363:         if self.config.numfig and (self.config.numfig_secnum_depth > 0):\n         if self.config.numfig and (self.config.numfig_secnum_depth > 0):\n+364:             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)\n             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)\n+365: \n \n+366:         if minsecnumdepth > self.secnumdepth:\n         if minsecnumdepth > self.secnumdepth:\n+367:             self.elements['secnumdepth'] = r'\\setcounter{secnumdepth}{%d}' %\\\n             self.elements['secnumdepth'] = r'\\setcounter{secnumdepth}{%d}' %\\\n+368:                                            minsecnumdepth\n                                            minsecnumdepth\n+369: \n \n+370:         contentsname = document.get('contentsname')\n         contentsname = document.get('contentsname')\n+371:         if contentsname:\n         if contentsname:\n+372:             self.elements['contentsname'] = self.babel_renewcommand(r'\\contentsname',\n             self.elements['contentsname'] = self.babel_renewcommand(r'\\contentsname',\n+373:                                                                     contentsname)\n                                                                     contentsname)\n+374: \n \n+375:         if self.elements['maxlistdepth']:\n         if self.elements['maxlistdepth']:\n+376:             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])\n             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])\n+377:         if sphinxpkgoptions:\n         if sphinxpkgoptions:\n+378:             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)\n             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)\n+379:         if self.elements['sphinxsetup']:\n         if self.elements['sphinxsetup']:\n+380:             self.elements['sphinxsetup'] = (r'\\sphinxsetup{%s}' % self.elements['sphinxsetup'])\n             self.elements['sphinxsetup'] = (r'\\sphinxsetup{%s}' % self.elements['sphinxsetup'])\n+381:         if self.elements['extraclassoptions']:\n         if self.elements['extraclassoptions']:\n+382:             self.elements['classoptions'] += ',' + \\\n             self.elements['classoptions'] += ',' + \\\n+383:                                              self.elements['extraclassoptions']\n                                              self.elements['extraclassoptions']\n+384: \n \n+385:         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,\n         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,\n+386:                                                        latex_engine=self.config.latex_engine)\n                                                        latex_engine=self.config.latex_engine)\n+387:         self.context: List[Any] = []\n         self.context: List[Any] = []\n+388:         self.descstack: List[str] = []\n         self.descstack: List[str] = []\n+389:         self.tables: List[Table] = []\n         self.tables: List[Table] = []\n+390:         self.next_table_colspec: str = None\n         self.next_table_colspec: str = None\n+391:         self.bodystack: List[List[str]] = []\n         self.bodystack: List[List[str]] = []\n+392:         self.footnote_restricted: Element = None\n         self.footnote_restricted: Element = None\n+393:         self.pending_footnotes: List[nodes.footnote_reference] = []\n         self.pending_footnotes: List[nodes.footnote_reference] = []\n+394:         self.curfilestack: List[str] = []\n         self.curfilestack: List[str] = []\n+395:         self.handled_abbrs: Set[str] = set()\n         self.handled_abbrs: Set[str] = set()\n+396: \n \n+397:     def pushbody(self, newbody: List[str]) -> None:\n     def pushbody(self, newbody: List[str]) -> None:\n+398:         self.bodystack.append(self.body)\n         self.bodystack.append(self.body)\n+399:         self.body = newbody\n         self.body = newbody\n+400: \n \n+401:     def popbody(self) -> List[str]:\n     def popbody(self) -> List[str]:\n+402:         body = self.body\n         body = self.body\n+403:         self.body = self.bodystack.pop()\n         self.body = self.bodystack.pop()\n+404:         return body\n         return body\n+405: \n \n+406:     def astext(self) -> str:\n     def astext(self) -> str:\n+407:         self.elements.update({\n         self.elements.update({\n+408:             'body': ''.join(self.body),\n             'body': ''.join(self.body),\n+409:             'indices': self.generate_indices()\n             'indices': self.generate_indices()\n+410:         })\n         })\n+411:         return self.render('latex.tex_t', self.elements)\n         return self.render('latex.tex_t', self.elements)\n+412: \n \n+413:     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:\n     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:\n+414:         if withdoc:\n         if withdoc:\n+415:             id = self.curfilestack[-1] + ':' + id\n             id = self.curfilestack[-1] + ':' + id\n+416:         return (r'\\phantomsection' if anchor else '') + r'\\label{%s}' % self.idescape(id)\n         return (r'\\phantomsection' if anchor else '') + r'\\label{%s}' % self.idescape(id)\n+417: \n \n+418:     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:\n     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:\n+419:         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])\n         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])\n+420:         if anchor:\n         if anchor:\n+421:             return r'\\phantomsection' + labels\n             return r'\\phantomsection' + labels\n+422:         else:\n         else:\n+423:             return labels\n             return labels\n+424: \n \n+425:     def hyperlink(self, id: str) -> str:\n     def hyperlink(self, id: str) -> str:\n+426:         return r'{\\hyperref[%s]{' % self.idescape(id)\n         return r'{\\hyperref[%s]{' % self.idescape(id)\n+427: \n \n+428:     def hyperpageref(self, id: str) -> str:\n     def hyperpageref(self, id: str) -> str:\n+429:         return r'\\autopageref*{%s}' % self.idescape(id)\n         return r'\\autopageref*{%s}' % self.idescape(id)\n+430: \n \n+431:     def escape(self, s: str) -> str:\n     def escape(self, s: str) -> str:\n+432:         return texescape.escape(s, self.config.latex_engine)\n         return texescape.escape(s, self.config.latex_engine)\n+433: \n \n+434:     def idescape(self, id: str) -> str:\n     def idescape(self, id: str) -> str:\n+435:         return r'\\detokenize{%s}' % str(id).translate(tex_replace_map).\\\n         return r'\\detokenize{%s}' % str(id).translate(tex_replace_map).\\\n+436:             encode('ascii', 'backslashreplace').decode('ascii').\\\n             encode('ascii', 'backslashreplace').decode('ascii').\\\n+437:             replace('\\\\', '_')\n             replace('\\\\', '_')\n+438: \n \n+439:     def babel_renewcommand(self, command: str, definition: str) -> str:\n     def babel_renewcommand(self, command: str, definition: str) -> str:\n+440:         if self.elements['multilingual']:\n         if self.elements['multilingual']:\n+441:             prefix = r'\\addto\\captions%s{' % self.babel.get_language()\n             prefix = r'\\addto\\captions%s{' % self.babel.get_language()\n+442:             suffix = '}'\n             suffix = '}'\n+443:         else:  # babel is disabled (mainly for Japanese environment)\n         else:  # babel is disabled (mainly for Japanese environment)\n+444:             prefix = ''\n             prefix = ''\n+445:             suffix = ''\n             suffix = ''\n+446: \n \n+447:         return r'%s\\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR\n         return r'%s\\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR\n+448: \n \n+449:     def generate_indices(self) -> str:\n     def generate_indices(self) -> str:\n+450:         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:\n         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:\n+451:             ret.append(r'\\begin{sphinxtheindex}' + CR)\n             ret.append(r'\\begin{sphinxtheindex}' + CR)\n+452:             ret.append(r'\\let\\bigletter\\sphinxstyleindexlettergroup' + CR)\n             ret.append(r'\\let\\bigletter\\sphinxstyleindexlettergroup' + CR)\n+453:             for i, (letter, entries) in enumerate(content):\n             for i, (letter, entries) in enumerate(content):\n+454:                 if i > 0:\n                 if i > 0:\n+455:                     ret.append(r'\\indexspace' + CR)\n                     ret.append(r'\\indexspace' + CR)\n+456:                 ret.append(r'\\bigletter{%s}' % self.escape(letter) + CR)\n                 ret.append(r'\\bigletter{%s}' % self.escape(letter) + CR)\n+457:                 for entry in entries:\n                 for entry in entries:\n+458:                     if not entry[3]:\n                     if not entry[3]:\n+459:                         continue\n                         continue\n+460:                     ret.append(r'\\item\\relax\\sphinxstyleindexentry{%s}' %\n                     ret.append(r'\\item\\relax\\sphinxstyleindexentry{%s}' %\n+461:                                self.encode(entry[0]))\n                                self.encode(entry[0]))\n+462:                     if entry[4]:\n                     if entry[4]:\n+463:                         # add \"extra\" info\n                         # add \"extra\" info\n+464:                         ret.append(r'\\sphinxstyleindexextra{%s}' % self.encode(entry[4]))\n                         ret.append(r'\\sphinxstyleindexextra{%s}' % self.encode(entry[4]))\n+465:                     ret.append(r'\\sphinxstyleindexpageref{%s:%s}' %\n                     ret.append(r'\\sphinxstyleindexpageref{%s:%s}' %\n+466:                                (entry[2], self.idescape(entry[3])) + CR)\n                                (entry[2], self.idescape(entry[3])) + CR)\n+467:             ret.append(r'\\end{sphinxtheindex}' + CR)\n             ret.append(r'\\end{sphinxtheindex}' + CR)\n+468: \n \n+469:         ret = []\n         ret = []\n+470:         # latex_domain_indices can be False/True or a list of index names\n         # latex_domain_indices can be False/True or a list of index names\n+471:         indices_config = self.config.latex_domain_indices\n         indices_config = self.config.latex_domain_indices\n+472:         if indices_config:\n         if indices_config:\n+473:             for domain in self.builder.env.domains.values():\n             for domain in self.builder.env.domains.values():\n+474:                 for indexcls in domain.indices:\n                 for indexcls in domain.indices:\n+475:                     indexname = '%s-%s' % (domain.name, indexcls.name)\n                     indexname = '%s-%s' % (domain.name, indexcls.name)\n+476:                     if isinstance(indices_config, list):\n                     if isinstance(indices_config, list):\n+477:                         if indexname not in indices_config:\n                         if indexname not in indices_config:\n+478:                             continue\n                             continue\n+479:                     content, collapsed = indexcls(domain).generate(\n                     content, collapsed = indexcls(domain).generate(\n+480:                         self.builder.docnames)\n                         self.builder.docnames)\n+481:                     if not content:\n                     if not content:\n+482:                         continue\n                         continue\n+483:                     ret.append(r'\\renewcommand{\\indexname}{%s}' % indexcls.localname + CR)\n                     ret.append(r'\\renewcommand{\\indexname}{%s}' % indexcls.localname + CR)\n+484:                     generate(content, collapsed)\n                     generate(content, collapsed)\n+485: \n \n+486:         return ''.join(ret)\n         return ''.join(ret)\n+487: \n \n+488:     def render(self, template_name: str, variables: Dict) -> str:\n     def render(self, template_name: str, variables: Dict) -> str:\n+489:         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)\n         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)\n+490:         for template_dir in self.config.templates_path:\n         for template_dir in self.config.templates_path:\n+491:             template = path.join(self.builder.confdir, template_dir,\n             template = path.join(self.builder.confdir, template_dir,\n+492:                                  template_name)\n                                  template_name)\n+493:             if path.exists(template):\n             if path.exists(template):\n+494:                 return renderer.render(template, variables)\n                 return renderer.render(template, variables)\n+495: \n \n+496:         return renderer.render(template_name, variables)\n         return renderer.render(template_name, variables)\n+497: \n \n+498:     @property\n     @property\n+499:     def table(self) -> Table:\n     def table(self) -> Table:\n+500:         \"\"\"Get current table.\"\"\"\n         \"\"\"Get current table.\"\"\"\n+501:         if self.tables:\n         if self.tables:\n+502:             return self.tables[-1]\n             return self.tables[-1]\n+503:         else:\n         else:\n+504:             return None\n             return None\n+505: \n \n+506:     def visit_document(self, node: Element) -> None:\n     def visit_document(self, node: Element) -> None:\n+507:         self.curfilestack.append(node.get('docname', ''))\n         self.curfilestack.append(node.get('docname', ''))\n+508:         if self.first_document == 1:\n         if self.first_document == 1:\n+509:             # the first document is all the regular content ...\n             # the first document is all the regular content ...\n+510:             self.first_document = 0\n             self.first_document = 0\n+511:         elif self.first_document == 0:\n         elif self.first_document == 0:\n+512:             # ... and all others are the appendices\n             # ... and all others are the appendices\n+513:             self.body.append(CR + r'\\appendix' + CR)\n             self.body.append(CR + r'\\appendix' + CR)\n+514:             self.first_document = -1\n             self.first_document = -1\n+515:         if 'docname' in node:\n         if 'docname' in node:\n+516:             self.body.append(self.hypertarget(':doc'))\n             self.body.append(self.hypertarget(':doc'))\n+517:         # \"- 1\" because the level is increased before the title is visited\n         # \"- 1\" because the level is increased before the title is visited\n+518:         self.sectionlevel = self.top_sectionlevel - 1\n         self.sectionlevel = self.top_sectionlevel - 1\n+519: \n \n+520:     def depart_document(self, node: Element) -> None:\n     def depart_document(self, node: Element) -> None:\n+521:         pass\n         pass\n+522: \n \n+523:     def visit_start_of_file(self, node: Element) -> None:\n     def visit_start_of_file(self, node: Element) -> None:\n+524:         self.curfilestack.append(node['docname'])\n         self.curfilestack.append(node['docname'])\n+525:         self.body.append(CR + r'\\sphinxstepscope' + CR)\n         self.body.append(CR + r'\\sphinxstepscope' + CR)\n+526: \n \n+527:     def depart_start_of_file(self, node: Element) -> None:\n     def depart_start_of_file(self, node: Element) -> None:\n+528:         self.curfilestack.pop()\n         self.curfilestack.pop()\n+529: \n \n+530:     def visit_section(self, node: Element) -> None:\n     def visit_section(self, node: Element) -> None:\n+531:         if not self.this_is_the_title:\n         if not self.this_is_the_title:\n+532:             self.sectionlevel += 1\n             self.sectionlevel += 1\n+533:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+534: \n \n+535:     def depart_section(self, node: Element) -> None:\n     def depart_section(self, node: Element) -> None:\n+536:         self.sectionlevel = max(self.sectionlevel - 1,\n         self.sectionlevel = max(self.sectionlevel - 1,\n+537:                                 self.top_sectionlevel - 1)\n                                 self.top_sectionlevel - 1)\n+538: \n \n+539:     def visit_problematic(self, node: Element) -> None:\n     def visit_problematic(self, node: Element) -> None:\n+540:         self.body.append(r'{\\color{red}\\bfseries{}')\n         self.body.append(r'{\\color{red}\\bfseries{}')\n+541: \n \n+542:     def depart_problematic(self, node: Element) -> None:\n     def depart_problematic(self, node: Element) -> None:\n+543:         self.body.append('}')\n         self.body.append('}')\n+544: \n \n+545:     def visit_topic(self, node: Element) -> None:\n     def visit_topic(self, node: Element) -> None:\n+546:         self.in_minipage = 1\n         self.in_minipage = 1\n+547:         self.body.append(CR + r'\\begin{sphinxShadowBox}' + CR)\n         self.body.append(CR + r'\\begin{sphinxShadowBox}' + CR)\n+548: \n \n+549:     def depart_topic(self, node: Element) -> None:\n     def depart_topic(self, node: Element) -> None:\n+550:         self.in_minipage = 0\n         self.in_minipage = 0\n+551:         self.body.append(r'\\end{sphinxShadowBox}' + CR)\n         self.body.append(r'\\end{sphinxShadowBox}' + CR)\n+552:     visit_sidebar = visit_topic\n     visit_sidebar = visit_topic\n+553:     depart_sidebar = depart_topic\n     depart_sidebar = depart_topic\n+554: \n \n+555:     def visit_glossary(self, node: Element) -> None:\n     def visit_glossary(self, node: Element) -> None:\n+556:         pass\n         pass\n+557: \n \n+558:     def depart_glossary(self, node: Element) -> None:\n     def depart_glossary(self, node: Element) -> None:\n+559:         pass\n         pass\n+560: \n \n+561:     def visit_productionlist(self, node: Element) -> None:\n     def visit_productionlist(self, node: Element) -> None:\n+562:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+563:         self.body.append(r'\\begin{productionlist}' + CR)\n         self.body.append(r'\\begin{productionlist}' + CR)\n+564:         self.in_production_list = 1\n         self.in_production_list = 1\n+565: \n \n+566:     def depart_productionlist(self, node: Element) -> None:\n     def depart_productionlist(self, node: Element) -> None:\n+567:         self.body.append(r'\\end{productionlist}' + BLANKLINE)\n         self.body.append(r'\\end{productionlist}' + BLANKLINE)\n+568:         self.in_production_list = 0\n         self.in_production_list = 0\n+569: \n \n+570:     def visit_production(self, node: Element) -> None:\n     def visit_production(self, node: Element) -> None:\n+571:         if node['tokenname']:\n         if node['tokenname']:\n+572:             tn = node['tokenname']\n             tn = node['tokenname']\n+573:             self.body.append(self.hypertarget('grammar-token-' + tn))\n             self.body.append(self.hypertarget('grammar-token-' + tn))\n+574:             self.body.append(r'\\production{%s}{' % self.encode(tn))\n             self.body.append(r'\\production{%s}{' % self.encode(tn))\n+575:         else:\n         else:\n+576:             self.body.append(r'\\productioncont{')\n             self.body.append(r'\\productioncont{')\n+577: \n \n+578:     def depart_production(self, node: Element) -> None:\n     def depart_production(self, node: Element) -> None:\n+579:         self.body.append('}' + CR)\n         self.body.append('}' + CR)\n+580: \n \n+581:     def visit_transition(self, node: Element) -> None:\n     def visit_transition(self, node: Element) -> None:\n+582:         self.body.append(self.elements['transition'])\n         self.body.append(self.elements['transition'])\n+583: \n \n+584:     def depart_transition(self, node: Element) -> None:\n     def depart_transition(self, node: Element) -> None:\n+585:         pass\n         pass\n+586: \n \n+587:     def visit_title(self, node: Element) -> None:\n     def visit_title(self, node: Element) -> None:\n+588:         parent = node.parent\n         parent = node.parent\n+589:         if isinstance(parent, addnodes.seealso):\n         if isinstance(parent, addnodes.seealso):\n+590:             # the environment already handles this\n             # the environment already handles this\n+591:             raise nodes.SkipNode\n             raise nodes.SkipNode\n+592:         elif isinstance(parent, nodes.section):\n         elif isinstance(parent, nodes.section):\n+593:             if self.this_is_the_title:\n             if self.this_is_the_title:\n+594:                 if len(node.children) != 1 and not isinstance(node.children[0],\n                 if len(node.children) != 1 and not isinstance(node.children[0],\n+595:                                                               nodes.Text):\n                                                               nodes.Text):\n+596:                     logger.warning(__('document title is not a single Text node'),\n                     logger.warning(__('document title is not a single Text node'),\n+597:                                    location=node)\n                                    location=node)\n+598:                 if not self.elements['title']:\n                 if not self.elements['title']:\n+599:                     # text needs to be escaped since it is inserted into\n                     # text needs to be escaped since it is inserted into\n+600:                     # the output literally\n                     # the output literally\n+601:                     self.elements['title'] = self.escape(node.astext())\n                     self.elements['title'] = self.escape(node.astext())\n+602:                 self.this_is_the_title = 0\n                 self.this_is_the_title = 0\n+603:                 raise nodes.SkipNode\n                 raise nodes.SkipNode\n+604:             else:\n             else:\n+605:                 short = ''\n                 short = ''\n+606:                 if any(node.findall(nodes.image)):\n                 if any(node.findall(nodes.image)):\n+607:                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))\n                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))\n+608: \n \n+609:                 try:\n                 try:\n+610:                     self.body.append(r'\\%s%s{' % (self.sectionnames[self.sectionlevel], short))\n                     self.body.append(r'\\%s%s{' % (self.sectionnames[self.sectionlevel], short))\n+611:                 except IndexError:\n                 except IndexError:\n+612:                     # just use \"subparagraph\", it's not numbered anyway\n                     # just use \"subparagraph\", it's not numbered anyway\n+613:                     self.body.append(r'\\%s%s{' % (self.sectionnames[-1], short))\n                     self.body.append(r'\\%s%s{' % (self.sectionnames[-1], short))\n+614:                 self.context.append('}' + CR + self.hypertarget_to(node.parent))\n                 self.context.append('}' + CR + self.hypertarget_to(node.parent))\n+615:         elif isinstance(parent, nodes.topic):\n         elif isinstance(parent, nodes.topic):\n+616:             self.body.append(r'\\sphinxstyletopictitle{')\n             self.body.append(r'\\sphinxstyletopictitle{')\n+617:             self.context.append('}' + CR)\n             self.context.append('}' + CR)\n+618:         elif isinstance(parent, nodes.sidebar):\n         elif isinstance(parent, nodes.sidebar):\n+619:             self.body.append(r'\\sphinxstylesidebartitle{')\n             self.body.append(r'\\sphinxstylesidebartitle{')\n+620:             self.context.append('}' + CR)\n             self.context.append('}' + CR)\n+621:         elif isinstance(parent, nodes.Admonition):\n         elif isinstance(parent, nodes.Admonition):\n+622:             self.body.append('{')\n             self.body.append('{')\n+623:             self.context.append('}' + CR)\n             self.context.append('}' + CR)\n+624:         elif isinstance(parent, nodes.table):\n         elif isinstance(parent, nodes.table):\n+625:             # Redirect body output until title is finished.\n             # Redirect body output until title is finished.\n+626:             self.pushbody([])\n             self.pushbody([])\n+627:         else:\n         else:\n+628:             logger.warning(__('encountered title node not in section, topic, table, '\n             logger.warning(__('encountered title node not in section, topic, table, '\n+629:                               'admonition or sidebar'),\n                               'admonition or sidebar'),\n+630:                            location=node)\n                            location=node)\n+631:             self.body.append(r'\\sphinxstyleothertitle{')\n             self.body.append(r'\\sphinxstyleothertitle{')\n+632:             self.context.append('}' + CR)\n             self.context.append('}' + CR)\n+633:         self.in_title = 1\n         self.in_title = 1\n+634: \n \n+635:     def depart_title(self, node: Element) -> None:\n     def depart_title(self, node: Element) -> None:\n+636:         self.in_title = 0\n         self.in_title = 0\n+637:         if isinstance(node.parent, nodes.table):\n         if isinstance(node.parent, nodes.table):\n+638:             self.table.caption = self.popbody()\n             self.table.caption = self.popbody()\n+639:         else:\n         else:\n+640:             self.body.append(self.context.pop())\n             self.body.append(self.context.pop())\n+641: \n \n+642:     def visit_subtitle(self, node: Element) -> None:\n     def visit_subtitle(self, node: Element) -> None:\n+643:         if isinstance(node.parent, nodes.sidebar):\n         if isinstance(node.parent, nodes.sidebar):\n+644:             self.body.append(r'\\sphinxstylesidebarsubtitle{')\n             self.body.append(r'\\sphinxstylesidebarsubtitle{')\n+645:             self.context.append('}' + CR)\n             self.context.append('}' + CR)\n+646:         else:\n         else:\n+647:             self.context.append('')\n             self.context.append('')\n+648: \n \n+649:     def depart_subtitle(self, node: Element) -> None:\n     def depart_subtitle(self, node: Element) -> None:\n+650:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+651: \n \n+652:     #############################################################\n     #############################################################\n+653:     # Domain-specific object descriptions\n     # Domain-specific object descriptions\n+654:     #############################################################\n     #############################################################\n+655: \n \n+656:     # Top-level nodes for descriptions\n     # Top-level nodes for descriptions\n+657:     ##################################\n     ##################################\n+658: \n \n+659:     def visit_desc(self, node: Element) -> None:\n     def visit_desc(self, node: Element) -> None:\n+660:         if self.config.latex_show_urls == 'footnote':\n         if self.config.latex_show_urls == 'footnote':\n+661:             self.body.append(BLANKLINE)\n             self.body.append(BLANKLINE)\n+662:             self.body.append(r'\\begin{savenotes}\\begin{fulllineitems}' + CR)\n             self.body.append(r'\\begin{savenotes}\\begin{fulllineitems}' + CR)\n+663:         else:\n         else:\n+664:             self.body.append(BLANKLINE)\n             self.body.append(BLANKLINE)\n+665:             self.body.append(r'\\begin{fulllineitems}' + CR)\n             self.body.append(r'\\begin{fulllineitems}' + CR)\n+666:         if self.table:\n         if self.table:\n+667:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+668: \n \n+669:     def depart_desc(self, node: Element) -> None:\n     def depart_desc(self, node: Element) -> None:\n+670:         if self.in_desc_signature:\n         if self.in_desc_signature:\n+671:             self.body.append(CR + r'\\pysigstopsignatures')\n             self.body.append(CR + r'\\pysigstopsignatures')\n+672:             self.in_desc_signature = False\n             self.in_desc_signature = False\n+673:         if self.config.latex_show_urls == 'footnote':\n         if self.config.latex_show_urls == 'footnote':\n+674:             self.body.append(CR + r'\\end{fulllineitems}\\end{savenotes}' + BLANKLINE)\n             self.body.append(CR + r'\\end{fulllineitems}\\end{savenotes}' + BLANKLINE)\n+675:         else:\n         else:\n+676:             self.body.append(CR + r'\\end{fulllineitems}' + BLANKLINE)\n             self.body.append(CR + r'\\end{fulllineitems}' + BLANKLINE)\n+677: \n \n+678:     def _visit_signature_line(self, node: Element) -> None:\n     def _visit_signature_line(self, node: Element) -> None:\n+679:         for child in node:\n         for child in node:\n+680:             if isinstance(child, addnodes.desc_parameterlist):\n             if isinstance(child, addnodes.desc_parameterlist):\n+681:                 self.body.append(CR + r'\\pysiglinewithargsret{')\n                 self.body.append(CR + r'\\pysiglinewithargsret{')\n+682:                 break\n                 break\n+683:         else:\n         else:\n+684:             self.body.append(CR + r'\\pysigline{')\n             self.body.append(CR + r'\\pysigline{')\n+685: \n \n+686:     def _depart_signature_line(self, node: Element) -> None:\n     def _depart_signature_line(self, node: Element) -> None:\n+687:         self.body.append('}')\n         self.body.append('}')\n+688: \n \n+689:     def visit_desc_signature(self, node: Element) -> None:\n     def visit_desc_signature(self, node: Element) -> None:\n+690:         if node.parent['objtype'] != 'describe' and node['ids']:\n         if node.parent['objtype'] != 'describe' and node['ids']:\n+691:             hyper = self.hypertarget(node['ids'][0])\n             hyper = self.hypertarget(node['ids'][0])\n+692:         else:\n         else:\n+693:             hyper = ''\n             hyper = ''\n+694:         self.body.append(hyper)\n         self.body.append(hyper)\n+695:         if not self.in_desc_signature:\n         if not self.in_desc_signature:\n+696:             self.in_desc_signature = True\n             self.in_desc_signature = True\n+697:             self.body.append(CR + r'\\pysigstartsignatures')\n             self.body.append(CR + r'\\pysigstartsignatures')\n+698:         if not node.get('is_multiline'):\n         if not node.get('is_multiline'):\n+699:             self._visit_signature_line(node)\n             self._visit_signature_line(node)\n+700:         else:\n         else:\n+701:             self.body.append(CR + r'\\pysigstartmultiline')\n             self.body.append(CR + r'\\pysigstartmultiline')\n+702: \n \n+703:     def depart_desc_signature(self, node: Element) -> None:\n     def depart_desc_signature(self, node: Element) -> None:\n+704:         if not node.get('is_multiline'):\n         if not node.get('is_multiline'):\n+705:             self._depart_signature_line(node)\n             self._depart_signature_line(node)\n+706:         else:\n         else:\n+707:             self.body.append(CR + r'\\pysigstopmultiline')\n             self.body.append(CR + r'\\pysigstopmultiline')\n+708: \n \n+709:     def visit_desc_signature_line(self, node: Element) -> None:\n     def visit_desc_signature_line(self, node: Element) -> None:\n+710:         self._visit_signature_line(node)\n         self._visit_signature_line(node)\n+711: \n \n+712:     def depart_desc_signature_line(self, node: Element) -> None:\n     def depart_desc_signature_line(self, node: Element) -> None:\n+713:         self._depart_signature_line(node)\n         self._depart_signature_line(node)\n+714: \n \n+715:     def visit_desc_content(self, node: Element) -> None:\n     def visit_desc_content(self, node: Element) -> None:\n+716:         assert self.in_desc_signature\n         assert self.in_desc_signature\n+717:         self.body.append(CR + r'\\pysigstopsignatures')\n         self.body.append(CR + r'\\pysigstopsignatures')\n+718:         self.in_desc_signature = False\n         self.in_desc_signature = False\n+719: \n \n+720:     def depart_desc_content(self, node: Element) -> None:\n     def depart_desc_content(self, node: Element) -> None:\n+721:         pass\n         pass\n+722: \n \n+723:     def visit_desc_inline(self, node: Element) -> None:\n     def visit_desc_inline(self, node: Element) -> None:\n-        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+        # avoid introducing spurious spaces in LaTeX output by using % after\n+        # the opening brace so leading/trailing spaces from surrounding text\n+        # are not rendered.\n+        self.body.append(r\\\"\\\\sphinxcode{\\\\sphinxupquote{%\\\")\n+725: \n \n+726:     def depart_desc_inline(self, node: Element) -> None:\n     def depart_desc_inline(self, node: Element) -> None:\n+        self.body.append(\"%}}\")\n         self.body.append('}}')\n+728: \n \n+729:     # Nodes for high-level structure in signatures\n     # Nodes for high-level structure in signatures\n+730:     ##############################################\n     ##############################################\n+731: \n \n+732:     def visit_desc_name(self, node: Element) -> None:\n     def visit_desc_name(self, node: Element) -> None:\n+733:         self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n         self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n+734:         self.literal_whitespace += 1\n         self.literal_whitespace += 1\n+735: \n \n+736:     def depart_desc_name(self, node: Element) -> None:\n     def depart_desc_name(self, node: Element) -> None:\n+737:         self.body.append('}}')\n         self.body.append('}}')\n+738:         self.literal_whitespace -= 1\n         self.literal_whitespace -= 1\n+739: \n \n+740:     def visit_desc_addname(self, node: Element) -> None:\n     def visit_desc_addname(self, node: Element) -> None:\n-        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+741:         self.body.append(r'\\sphinxcode{\\sphinxupquote{%')\n+        self.body.append(r'\\sphinxcode{\\sphinxupquote{%')\n+742:         self.literal_whitespace += 1\n         self.literal_whitespace += 1\n+743: \n \n+744:     def depart_desc_addname(self, node: Element) -> None:\n     def depart_desc_addname(self, node: Element) -> None:\n+745:         self.body.append('}}')\n         self.body.append('}}')\n+746:         self.literal_whitespace -= 1\n         self.literal_whitespace -= 1\n+747: \n \n+748:     def visit_desc_type(self, node: Element) -> None:\n     def visit_desc_type(self, node: Element) -> None:\n+749:         pass\n         pass\n+750: \n \n+751:     def depart_desc_type(self, node: Element) -> None:\n     def depart_desc_type(self, node: Element) -> None:\n+752:         pass\n         pass\n+753: \n \n+754:     def visit_desc_returns(self, node: Element) -> None:\n     def visit_desc_returns(self, node: Element) -> None:\n+755:         self.body.append(r'{ $\\rightarrow$ ')\n         self.body.append(r'{ $\\rightarrow$ ')\n+756: \n \n+757:     def depart_desc_returns(self, node: Element) -> None:\n     def depart_desc_returns(self, node: Element) -> None:\n+758:         self.body.append(r'}')\n         self.body.append(r'}')\n+759: \n \n+760:     def visit_desc_parameterlist(self, node: Element) -> None:\n     def visit_desc_parameterlist(self, node: Element) -> None:\n+761:         # close name, open parameterlist\n         # close name, open parameterlist\n+762:         self.body.append('}{')\n         self.body.append('}{')\n+763:         self.first_param = 1\n         self.first_param = 1\n+764: \n \n+765:     def depart_desc_parameterlist(self, node: Element) -> None:\n     def depart_desc_parameterlist(self, node: Element) -> None:\n+766:         # close parameterlist, open return annotation\n         # close parameterlist, open return annotation\n+767:         self.body.append('}{')\n         self.body.append('}{')\n+768: \n \n+769:     def visit_desc_parameter(self, node: Element) -> None:\n     def visit_desc_parameter(self, node: Element) -> None:\n+770:         if not self.first_param:\n         if not self.first_param:\n+771:             self.body.append(', ')\n             self.body.append(', ')\n+772:         else:\n         else:\n+773:             self.first_param = 0\n             self.first_param = 0\n+774:         if not node.hasattr('noemph'):\n         if not node.hasattr('noemph'):\n+775:             self.body.append(r'\\emph{')\n             self.body.append(r'\\emph{')\n+776: \n \n+777:     def depart_desc_parameter(self, node: Element) -> None:\n     def depart_desc_parameter(self, node: Element) -> None:\n+778:         if not node.hasattr('noemph'):\n         if not node.hasattr('noemph'):\n+779:             self.body.append('}')\n             self.body.append('}')\n+780: \n \n+781:     def visit_desc_optional(self, node: Element) -> None:\n     def visit_desc_optional(self, node: Element) -> None:\n+782:         self.body.append(r'\\sphinxoptional{')\n         self.body.append(r'\\sphinxoptional{')\n+783: \n \n+784:     def depart_desc_optional(self, node: Element) -> None:\n     def depart_desc_optional(self, node: Element) -> None:\n+785:         self.body.append('}')\n         self.body.append('}')\n+786: \n \n+787:     def visit_desc_annotation(self, node: Element) -> None:\n     def visit_desc_annotation(self, node: Element) -> None:\n+788:         self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n         self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n+789: \n \n+790:     def depart_desc_annotation(self, node: Element) -> None:\n     def depart_desc_annotation(self, node: Element) -> None:\n+791:         self.body.append('}}')\n         self.body.append('}}')\n+792: \n \n+793:     ##############################################\n     ##############################################\n+794: \n \n+795:     def visit_seealso(self, node: Element) -> None:\n     def visit_seealso(self, node: Element) -> None:\n+796:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+797:         self.body.append(r'\\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)\n         self.body.append(r'\\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)\n+798:         self.body.append(r'\\nopagebreak' + BLANKLINE)\n         self.body.append(r'\\nopagebreak' + BLANKLINE)\n+799: \n \n+800:     def depart_seealso(self, node: Element) -> None:\n     def depart_seealso(self, node: Element) -> None:\n+801:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+802: \n \n+803:     def visit_rubric(self, node: Element) -> None:\n     def visit_rubric(self, node: Element) -> None:\n+804:         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):\n         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):\n+805:             raise nodes.SkipNode\n             raise nodes.SkipNode\n+806:         self.body.append(r'\\subsubsection*{')\n         self.body.append(r'\\subsubsection*{')\n+807:         self.context.append('}' + CR)\n         self.context.append('}' + CR)\n+808:         self.in_title = 1\n         self.in_title = 1\n+809: \n \n+810:     def depart_rubric(self, node: Element) -> None:\n     def depart_rubric(self, node: Element) -> None:\n+811:         self.in_title = 0\n         self.in_title = 0\n+812:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+813: \n \n+814:     def visit_footnote(self, node: Element) -> None:\n     def visit_footnote(self, node: Element) -> None:\n+815:         self.in_footnote += 1\n         self.in_footnote += 1\n+816:         label = cast(nodes.label, node[0])\n         label = cast(nodes.label, node[0])\n+817:         if self.in_parsed_literal:\n         if self.in_parsed_literal:\n+818:             self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n             self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n+819:         else:\n         else:\n+820:             self.body.append('%' + CR)\n             self.body.append('%' + CR)\n+821:             self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n             self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n+822:         if 'referred' in node:\n         if 'referred' in node:\n+823:             # TODO: in future maybe output a latex macro with backrefs here\n             # TODO: in future maybe output a latex macro with backrefs here\n+824:             pass\n             pass\n+825:         self.body.append(r'\\sphinxAtStartFootnote' + CR)\n         self.body.append(r'\\sphinxAtStartFootnote' + CR)\n+826: \n \n+827:     def depart_footnote(self, node: Element) -> None:\n     def depart_footnote(self, node: Element) -> None:\n+828:         if self.in_parsed_literal:\n         if self.in_parsed_literal:\n+829:             self.body.append(r'\\end{footnote}')\n             self.body.append(r'\\end{footnote}')\n+830:         else:\n         else:\n+831:             self.body.append('%' + CR)\n             self.body.append('%' + CR)\n+832:             self.body.append(r'\\end{footnote}')\n             self.body.append(r'\\end{footnote}')\n+833:         self.in_footnote -= 1\n         self.in_footnote -= 1\n+834: \n \n+835:     def visit_label(self, node: Element) -> None:\n     def visit_label(self, node: Element) -> None:\n+836:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+837: \n \n+838:     def visit_tabular_col_spec(self, node: Element) -> None:\n     def visit_tabular_col_spec(self, node: Element) -> None:\n+839:         self.next_table_colspec = node['spec']\n         self.next_table_colspec = node['spec']\n+840:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+841: \n \n+842:     def visit_table(self, node: Element) -> None:\n     def visit_table(self, node: Element) -> None:\n+843:         if len(self.tables) == 1:\n         if len(self.tables) == 1:\n+844:             if self.table.get_table_type() == 'longtable':\n             if self.table.get_table_type() == 'longtable':\n+845:                 raise UnsupportedError(\n                 raise UnsupportedError(\n+846:                     '%s:%s: longtable does not support nesting a table.' %\n                     '%s:%s: longtable does not support nesting a table.' %\n+847:                     (self.curfilestack[-1], node.line or ''))\n                     (self.curfilestack[-1], node.line or ''))\n+848:             else:\n             else:\n+849:                 # change type of parent table to tabular\n                 # change type of parent table to tabular\n+850:                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ\n                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ\n+851:                 self.table.has_problematic = True\n                 self.table.has_problematic = True\n+852:         elif len(self.tables) > 2:\n         elif len(self.tables) > 2:\n+853:             raise UnsupportedError(\n             raise UnsupportedError(\n+854:                 '%s:%s: deeply nested tables are not implemented.' %\n                 '%s:%s: deeply nested tables are not implemented.' %\n+855:                 (self.curfilestack[-1], node.line or ''))\n                 (self.curfilestack[-1], node.line or ''))\n+856: \n \n+857:         self.tables.append(Table(node))\n         self.tables.append(Table(node))\n+858:         if self.next_table_colspec:\n         if self.next_table_colspec:\n+859:             self.table.colspec = '{%s}' % self.next_table_colspec + CR\n             self.table.colspec = '{%s}' % self.next_table_colspec + CR\n+860:             if 'colwidths-given' in node.get('classes', []):\n             if 'colwidths-given' in node.get('classes', []):\n+861:                 logger.info(__('both tabularcolumns and :widths: option are given. '\n                 logger.info(__('both tabularcolumns and :widths: option are given. '\n+862:                                ':widths: is ignored.'), location=node)\n                                ':widths: is ignored.'), location=node)\n+863:         self.next_table_colspec = None\n         self.next_table_colspec = None\n+864: \n \n+865:     def depart_table(self, node: Element) -> None:\n     def depart_table(self, node: Element) -> None:\n+866:         labels = self.hypertarget_to(node)\n         labels = self.hypertarget_to(node)\n+867:         table_type = self.table.get_table_type()\n         table_type = self.table.get_table_type()\n+868:         table = self.render(table_type + '.tex_t',\n         table = self.render(table_type + '.tex_t',\n+869:                             dict(table=self.table, labels=labels))\n                             dict(table=self.table, labels=labels))\n+870:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+871:         self.body.append(table)\n         self.body.append(table)\n+872:         self.body.append(CR)\n         self.body.append(CR)\n+873: \n \n+874:         self.tables.pop()\n         self.tables.pop()\n+875: \n \n+876:     def visit_colspec(self, node: Element) -> None:\n     def visit_colspec(self, node: Element) -> None:\n+877:         self.table.colcount += 1\n         self.table.colcount += 1\n+878:         if 'colwidth' in node:\n         if 'colwidth' in node:\n+879:             self.table.colwidths.append(node['colwidth'])\n             self.table.colwidths.append(node['colwidth'])\n+880:         if 'stub' in node:\n         if 'stub' in node:\n+881:             self.table.stubs.append(self.table.colcount - 1)\n             self.table.stubs.append(self.table.colcount - 1)\n+882: \n \n+883:     def depart_colspec(self, node: Element) -> None:\n     def depart_colspec(self, node: Element) -> None:\n+884:         pass\n         pass\n+885: \n \n+886:     def visit_tgroup(self, node: Element) -> None:\n     def visit_tgroup(self, node: Element) -> None:\n+887:         pass\n         pass\n+888: \n \n+889:     def depart_tgroup(self, node: Element) -> None:\n     def depart_tgroup(self, node: Element) -> None:\n+890:         pass\n         pass\n+891: \n \n+892:     def visit_thead(self, node: Element) -> None:\n     def visit_thead(self, node: Element) -> None:\n+893:         # Redirect head output until header is finished.\n         # Redirect head output until header is finished.\n+894:         self.pushbody(self.table.header)\n         self.pushbody(self.table.header)\n+895: \n \n+896:     def depart_thead(self, node: Element) -> None:\n     def depart_thead(self, node: Element) -> None:\n+897:         self.popbody()\n         self.popbody()\n+898: \n \n+899:     def visit_tbody(self, node: Element) -> None:\n     def visit_tbody(self, node: Element) -> None:\n+900:         # Redirect body output until table is finished.\n         # Redirect body output until table is finished.\n+901:         self.pushbody(self.table.body)\n         self.pushbody(self.table.body)\n+902: \n \n+903:     def depart_tbody(self, node: Element) -> None:\n     def depart_tbody(self, node: Element) -> None:\n+904:         self.popbody()\n         self.popbody()\n+905: \n \n+906:     def visit_row(self, node: Element) -> None:\n     def visit_row(self, node: Element) -> None:\n+907:         self.table.col = 0\n         self.table.col = 0\n+908: \n \n+909:         # fill columns if the row starts with the bottom of multirow cell\n         # fill columns if the row starts with the bottom of multirow cell\n+910:         while True:\n         while True:\n+911:             cell = self.table.cell(self.table.row, self.table.col)\n             cell = self.table.cell(self.table.row, self.table.col)\n+912:             if cell is None:  # not a bottom of multirow cell\n             if cell is None:  # not a bottom of multirow cell\n+913:                 break\n                 break\n+914:             else:  # a bottom of multirow cell\n             else:  # a bottom of multirow cell\n+915:                 self.table.col += cell.width\n                 self.table.col += cell.width\n+916:                 if cell.col:\n                 if cell.col:\n+917:                     self.body.append('&')\n                     self.body.append('&')\n+918:                 if cell.width == 1:\n                 if cell.width == 1:\n+919:                     # insert suitable strut for equalizing row heights in given multirow\n                     # insert suitable strut for equalizing row heights in given multirow\n+920:                     self.body.append(r'\\sphinxtablestrut{%d}' % cell.cell_id)\n                     self.body.append(r'\\sphinxtablestrut{%d}' % cell.cell_id)\n+921:                 else:  # use \\multicolumn for wide multirow cell\n                 else:  # use \\multicolumn for wide multirow cell\n+922:                     self.body.append(r'\\multicolumn{%d}{|l|}{\\sphinxtablestrut{%d}}' %\n                     self.body.append(r'\\multicolumn{%d}{|l|}{\\sphinxtablestrut{%d}}' %\n+923:                                      (cell.width, cell.cell_id))\n                                      (cell.width, cell.cell_id))\n+924: \n \n+925:     def depart_row(self, node: Element) -> None:\n     def depart_row(self, node: Element) -> None:\n+926:         self.body.append(r'\\\\' + CR)\n         self.body.append(r'\\\\' + CR)\n+927:         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]\n         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]\n+928:         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]\n         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]\n+929:         if all(underlined):\n         if all(underlined):\n+930:             self.body.append(r'\\hline')\n             self.body.append(r'\\hline')\n+931:         else:\n         else:\n+932:             i = 0\n             i = 0\n+933:             underlined.extend([False])  # sentinel\n             underlined.extend([False])  # sentinel\n+934:             while i < len(underlined):\n             while i < len(underlined):\n+935:                 if underlined[i] is True:\n                 if underlined[i] is True:\n+936:                     j = underlined[i:].index(False)\n                     j = underlined[i:].index(False)\n+937:                     self.body.append(r'\\cline{%d-%d}' % (i + 1, i + j))\n                     self.body.append(r'\\cline{%d-%d}' % (i + 1, i + j))\n+938:                     i += j\n                     i += j\n+939:                 i += 1\n                 i += 1\n+940:         self.table.row += 1\n         self.table.row += 1\n+941: \n \n+942:     def visit_entry(self, node: Element) -> None:\n     def visit_entry(self, node: Element) -> None:\n+943:         if self.table.col > 0:\n         if self.table.col > 0:\n+944:             self.body.append('&')\n             self.body.append('&')\n+945:         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)\n         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)\n+946:         cell = self.table.cell()\n         cell = self.table.cell()\n+947:         context = ''\n         context = ''\n+948:         if cell.width > 1:\n         if cell.width > 1:\n+949:             if self.config.latex_use_latex_multicolumn:\n             if self.config.latex_use_latex_multicolumn:\n+950:                 if self.table.col == 0:\n                 if self.table.col == 0:\n+951:                     self.body.append(r'\\multicolumn{%d}{|l|}{%%' % cell.width + CR)\n                     self.body.append(r'\\multicolumn{%d}{|l|}{%%' % cell.width + CR)\n+952:                 else:\n                 else:\n+953:                     self.body.append(r'\\multicolumn{%d}{l|}{%%' % cell.width + CR)\n                     self.body.append(r'\\multicolumn{%d}{l|}{%%' % cell.width + CR)\n+954:                 context = '}%' + CR\n                 context = '}%' + CR\n+955:             else:\n             else:\n+956:                 self.body.append(r'\\sphinxstartmulticolumn{%d}%%' % cell.width + CR)\n                 self.body.append(r'\\sphinxstartmulticolumn{%d}%%' % cell.width + CR)\n+957:                 context = r'\\sphinxstopmulticolumn' + CR\n                 context = r'\\sphinxstopmulticolumn' + CR\n+958:         if cell.height > 1:\n         if cell.height > 1:\n+959:             # \\sphinxmultirow 2nd arg \"cell_id\" will serve as id for LaTeX macros as well\n             # \\sphinxmultirow 2nd arg \"cell_id\" will serve as id for LaTeX macros as well\n+960:             self.body.append(r'\\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)\n             self.body.append(r'\\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)\n+961:             context = '}%' + CR + context\n             context = '}%' + CR + context\n+962:         if cell.width > 1 or cell.height > 1:\n         if cell.width > 1 or cell.height > 1:\n+963:             self.body.append(r'\\begin{varwidth}[t]{\\sphinxcolwidth{%d}{%d}}'\n             self.body.append(r'\\begin{varwidth}[t]{\\sphinxcolwidth{%d}{%d}}'\n+964:                              % (cell.width, self.table.colcount) + CR)\n                              % (cell.width, self.table.colcount) + CR)\n+965:             context = (r'\\par' + CR + r'\\vskip-\\baselineskip'\n             context = (r'\\par' + CR + r'\\vskip-\\baselineskip'\n+966:                        r'\\vbox{\\hbox{\\strut}}\\end{varwidth}%' + CR + context)\n                        r'\\vbox{\\hbox{\\strut}}\\end{varwidth}%' + CR + context)\n+967:             self.needs_linetrimming = 1\n             self.needs_linetrimming = 1\n+968:         if len(list(node.findall(nodes.paragraph))) >= 2:\n         if len(list(node.findall(nodes.paragraph))) >= 2:\n+969:             self.table.has_oldproblematic = True\n             self.table.has_oldproblematic = True\n+970:         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):\n         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):\n+971:             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':\n             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':\n+972:                 pass\n                 pass\n+973:             else:\n             else:\n+974:                 self.body.append(r'\\sphinxstyletheadfamily ')\n                 self.body.append(r'\\sphinxstyletheadfamily ')\n+975:         if self.needs_linetrimming:\n         if self.needs_linetrimming:\n+976:             self.pushbody([])\n             self.pushbody([])\n+977:         self.context.append(context)\n         self.context.append(context)\n+978: \n \n+979:     def depart_entry(self, node: Element) -> None:\n     def depart_entry(self, node: Element) -> None:\n+980:         if self.needs_linetrimming:\n         if self.needs_linetrimming:\n+981:             self.needs_linetrimming = 0\n             self.needs_linetrimming = 0\n+982:             body = self.popbody()\n             body = self.popbody()\n+983: \n \n+984:             # Remove empty lines from top of merged cell\n             # Remove empty lines from top of merged cell\n+985:             while body and body[0] == CR:\n             while body and body[0] == CR:\n+986:                 body.pop(0)\n                 body.pop(0)\n+987:             self.body.extend(body)\n             self.body.extend(body)\n+988: \n \n+989:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+990: \n \n+991:         cell = self.table.cell()\n         cell = self.table.cell()\n+992:         self.table.col += cell.width\n         self.table.col += cell.width\n+993: \n \n+994:         # fill columns if next ones are a bottom of wide-multirow cell\n         # fill columns if next ones are a bottom of wide-multirow cell\n+995:         while True:\n         while True:\n+996:             nextcell = self.table.cell()\n             nextcell = self.table.cell()\n+997:             if nextcell is None:  # not a bottom of multirow cell\n             if nextcell is None:  # not a bottom of multirow cell\n+998:                 break\n                 break\n+999:             else:  # a bottom part of multirow cell\n             else:  # a bottom part of multirow cell\n+1000:                 self.table.col += nextcell.width\n                 self.table.col += nextcell.width\n+1001:                 self.body.append('&')\n                 self.body.append('&')\n+1002:                 if nextcell.width == 1:\n                 if nextcell.width == 1:\n+1003:                     # insert suitable strut for equalizing row heights in multirow\n                     # insert suitable strut for equalizing row heights in multirow\n+1004:                     # they also serve to clear colour panels which would hide the text\n                     # they also serve to clear colour panels which would hide the text\n+1005:                     self.body.append(r'\\sphinxtablestrut{%d}' % nextcell.cell_id)\n                     self.body.append(r'\\sphinxtablestrut{%d}' % nextcell.cell_id)\n+1006:                 else:\n                 else:\n+1007:                     # use \\multicolumn for wide multirow cell\n                     # use \\multicolumn for wide multirow cell\n+1008:                     self.body.append(r'\\multicolumn{%d}{l|}{\\sphinxtablestrut{%d}}' %\n                     self.body.append(r'\\multicolumn{%d}{l|}{\\sphinxtablestrut{%d}}' %\n+1009:                                      (nextcell.width, nextcell.cell_id))\n                                      (nextcell.width, nextcell.cell_id))\n+1010: \n \n+1011:     def visit_acks(self, node: Element) -> None:\n     def visit_acks(self, node: Element) -> None:\n+1012:         # this is a list in the source, but should be rendered as a\n         # this is a list in the source, but should be rendered as a\n+1013:         # comma-separated list here\n         # comma-separated list here\n+1014:         bullet_list = cast(nodes.bullet_list, node[0])\n         bullet_list = cast(nodes.bullet_list, node[0])\n+1015:         list_items = cast(Iterable[nodes.list_item], bullet_list)\n         list_items = cast(Iterable[nodes.list_item], bullet_list)\n+1016:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+1017:         self.body.append(', '.join(n.astext() for n in list_items) + '.')\n         self.body.append(', '.join(n.astext() for n in list_items) + '.')\n+1018:         self.body.append(BLANKLINE)\n         self.body.append(BLANKLINE)\n+1019:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1020: \n \n+1021:     def visit_bullet_list(self, node: Element) -> None:\n     def visit_bullet_list(self, node: Element) -> None:\n+1022:         if not self.compact_list:\n         if not self.compact_list:\n+1023:             self.body.append(r'\\begin{itemize}' + CR)\n             self.body.append(r'\\begin{itemize}' + CR)\n+1024:         if self.table:\n         if self.table:\n+1025:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1026: \n \n+1027:     def depart_bullet_list(self, node: Element) -> None:\n     def depart_bullet_list(self, node: Element) -> None:\n+1028:         if not self.compact_list:\n         if not self.compact_list:\n+1029:             self.body.append(r'\\end{itemize}' + CR)\n             self.body.append(r'\\end{itemize}' + CR)\n+1030: \n \n+1031:     def visit_enumerated_list(self, node: Element) -> None:\n     def visit_enumerated_list(self, node: Element) -> None:\n+1032:         def get_enumtype(node: Element) -> str:\n         def get_enumtype(node: Element) -> str:\n+1033:             enumtype = node.get('enumtype', 'arabic')\n             enumtype = node.get('enumtype', 'arabic')\n+1034:             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):\n             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):\n+1035:                 # fallback to arabic if alphabet counter overflows\n                 # fallback to arabic if alphabet counter overflows\n+1036:                 enumtype = 'arabic'\n                 enumtype = 'arabic'\n+1037: \n \n+1038:             return enumtype\n             return enumtype\n+1039: \n \n+1040:         def get_nested_level(node: Element) -> int:\n         def get_nested_level(node: Element) -> int:\n+1041:             if node is None:\n             if node is None:\n+1042:                 return 0\n                 return 0\n+1043:             elif isinstance(node, nodes.enumerated_list):\n             elif isinstance(node, nodes.enumerated_list):\n+1044:                 return get_nested_level(node.parent) + 1\n                 return get_nested_level(node.parent) + 1\n+1045:             else:\n             else:\n+1046:                 return get_nested_level(node.parent)\n                 return get_nested_level(node.parent)\n+1047: \n \n+1048:         enum = \"enum%s\" % toRoman(get_nested_level(node)).lower()\n         enum = \"enum%s\" % toRoman(get_nested_level(node)).lower()\n+1049:         enumnext = \"enum%s\" % toRoman(get_nested_level(node) + 1).lower()\n         enumnext = \"enum%s\" % toRoman(get_nested_level(node) + 1).lower()\n+1050:         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))\n         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))\n+1051:         prefix = node.get('prefix', '')\n         prefix = node.get('prefix', '')\n+1052:         suffix = node.get('suffix', '.')\n         suffix = node.get('suffix', '.')\n+1053: \n \n+1054:         self.body.append(r'\\begin{enumerate}' + CR)\n         self.body.append(r'\\begin{enumerate}' + CR)\n+1055:         self.body.append(r'\\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %\n         self.body.append(r'\\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %\n+1056:                          (style, enum, enumnext, prefix, suffix) + CR)\n                          (style, enum, enumnext, prefix, suffix) + CR)\n+1057:         if 'start' in node:\n         if 'start' in node:\n+1058:             self.body.append(r'\\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)\n             self.body.append(r'\\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)\n+1059:         if self.table:\n         if self.table:\n+1060:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1061: \n \n+1062:     def depart_enumerated_list(self, node: Element) -> None:\n     def depart_enumerated_list(self, node: Element) -> None:\n+1063:         self.body.append(r'\\end{enumerate}' + CR)\n         self.body.append(r'\\end{enumerate}' + CR)\n+1064: \n \n+1065:     def visit_list_item(self, node: Element) -> None:\n     def visit_list_item(self, node: Element) -> None:\n+1066:         # Append \"{}\" in case the next character is \"[\", which would break\n         # Append \"{}\" in case the next character is \"[\", which would break\n+1067:         # LaTeX's list environment (no numbering and the \"[\" is not printed).\n         # LaTeX's list environment (no numbering and the \"[\" is not printed).\n+1068:         self.body.append(r'\\item {} ')\n         self.body.append(r'\\item {} ')\n+1069: \n \n+1070:     def depart_list_item(self, node: Element) -> None:\n     def depart_list_item(self, node: Element) -> None:\n+1071:         self.body.append(CR)\n         self.body.append(CR)\n+1072: \n \n+1073:     def visit_definition_list(self, node: Element) -> None:\n     def visit_definition_list(self, node: Element) -> None:\n+1074:         self.body.append(r'\\begin{description}' + CR)\n         self.body.append(r'\\begin{description}' + CR)\n+1075:         if self.table:\n         if self.table:\n+1076:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1077: \n \n+1078:     def depart_definition_list(self, node: Element) -> None:\n     def depart_definition_list(self, node: Element) -> None:\n+1079:         self.body.append(r'\\end{description}' + CR)\n         self.body.append(r'\\end{description}' + CR)\n+1080: \n \n+1081:     def visit_definition_list_item(self, node: Element) -> None:\n     def visit_definition_list_item(self, node: Element) -> None:\n+1082:         pass\n         pass\n+1083: \n \n+1084:     def depart_definition_list_item(self, node: Element) -> None:\n     def depart_definition_list_item(self, node: Element) -> None:\n+1085:         pass\n         pass\n+1086: \n \n+1087:     def visit_term(self, node: Element) -> None:\n     def visit_term(self, node: Element) -> None:\n+1088:         self.in_term += 1\n         self.in_term += 1\n+1089:         ctx = ''\n         ctx = ''\n+1090:         if node.get('ids'):\n         if node.get('ids'):\n+1091:             ctx = r'\\phantomsection'\n             ctx = r'\\phantomsection'\n+1092:             for node_id in node['ids']:\n             for node_id in node['ids']:\n+1093:                 ctx += self.hypertarget(node_id, anchor=False)\n                 ctx += self.hypertarget(node_id, anchor=False)\n+1094:         ctx += r'}'\n         ctx += r'}'\n+1095:         self.body.append(r'\\sphinxlineitem{')\n         self.body.append(r'\\sphinxlineitem{')\n+1096:         self.context.append(ctx)\n         self.context.append(ctx)\n+1097: \n \n+1098:     def depart_term(self, node: Element) -> None:\n     def depart_term(self, node: Element) -> None:\n+1099:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+1100:         self.in_term -= 1\n         self.in_term -= 1\n+1101: \n \n+1102:     def visit_classifier(self, node: Element) -> None:\n     def visit_classifier(self, node: Element) -> None:\n+1103:         self.body.append('{[}')\n         self.body.append('{[}')\n+1104: \n \n+1105:     def depart_classifier(self, node: Element) -> None:\n     def depart_classifier(self, node: Element) -> None:\n+1106:         self.body.append('{]}')\n         self.body.append('{]}')\n+1107: \n \n+1108:     def visit_definition(self, node: Element) -> None:\n     def visit_definition(self, node: Element) -> None:\n+1109:         pass\n         pass\n+1110: \n \n+1111:     def depart_definition(self, node: Element) -> None:\n     def depart_definition(self, node: Element) -> None:\n+1112:         self.body.append(CR)\n         self.body.append(CR)\n+1113: \n \n+1114:     def visit_field_list(self, node: Element) -> None:\n     def visit_field_list(self, node: Element) -> None:\n+1115:         self.body.append(r'\\begin{quote}\\begin{description}' + CR)\n         self.body.append(r'\\begin{quote}\\begin{description}' + CR)\n+1116:         if self.table:\n         if self.table:\n+1117:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1118: \n \n+1119:     def depart_field_list(self, node: Element) -> None:\n     def depart_field_list(self, node: Element) -> None:\n+1120:         self.body.append(r'\\end{description}\\end{quote}' + CR)\n         self.body.append(r'\\end{description}\\end{quote}' + CR)\n+1121: \n \n+1122:     def visit_field(self, node: Element) -> None:\n     def visit_field(self, node: Element) -> None:\n+1123:         pass\n         pass\n+1124: \n \n+1125:     def depart_field(self, node: Element) -> None:\n     def depart_field(self, node: Element) -> None:\n+1126:         pass\n         pass\n+1127: \n \n+1128:     visit_field_name = visit_term\n     visit_field_name = visit_term\n+1129:     depart_field_name = depart_term\n     depart_field_name = depart_term\n+1130: \n \n+1131:     visit_field_body = visit_definition\n     visit_field_body = visit_definition\n+1132:     depart_field_body = depart_definition\n     depart_field_body = depart_definition\n+1133: \n \n+1134:     def visit_paragraph(self, node: Element) -> None:\n     def visit_paragraph(self, node: Element) -> None:\n+1135:         index = node.parent.index(node)\n         index = node.parent.index(node)\n+1136:         if (index > 0 and isinstance(node.parent, nodes.compound) and\n         if (index > 0 and isinstance(node.parent, nodes.compound) and\n+1137:                 not isinstance(node.parent[index - 1], nodes.paragraph) and\n                 not isinstance(node.parent[index - 1], nodes.paragraph) and\n+1138:                 not isinstance(node.parent[index - 1], nodes.compound)):\n                 not isinstance(node.parent[index - 1], nodes.compound)):\n+1139:             # insert blank line, if the paragraph follows a non-paragraph node in a compound\n             # insert blank line, if the paragraph follows a non-paragraph node in a compound\n+1140:             self.body.append(r'\\noindent' + CR)\n             self.body.append(r'\\noindent' + CR)\n+1141:         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):\n         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):\n+1142:             # don't insert blank line, if the paragraph is second child of a footnote\n             # don't insert blank line, if the paragraph is second child of a footnote\n+1143:             # (first one is label node)\n             # (first one is label node)\n+1144:             pass\n             pass\n+1145:         else:\n         else:\n+1146:             # the \\sphinxAtStartPar is to allow hyphenation of first word of\n             # the \\sphinxAtStartPar is to allow hyphenation of first word of\n+1147:             # a paragraph in narrow contexts such as in a table cell\n             # a paragraph in narrow contexts such as in a table cell\n+1148:             # added as two items (cf. line trimming in depart_entry())\n             # added as two items (cf. line trimming in depart_entry())\n+1149:             self.body.extend([CR, r'\\sphinxAtStartPar' + CR])\n             self.body.extend([CR, r'\\sphinxAtStartPar' + CR])\n+1150: \n \n+1151:     def depart_paragraph(self, node: Element) -> None:\n     def depart_paragraph(self, node: Element) -> None:\n+1152:         self.body.append(CR)\n         self.body.append(CR)\n+1153: \n \n+1154:     def visit_centered(self, node: Element) -> None:\n     def visit_centered(self, node: Element) -> None:\n+1155:         self.body.append(CR + r'\\begin{center}')\n         self.body.append(CR + r'\\begin{center}')\n+1156:         if self.table:\n         if self.table:\n+1157:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1158: \n \n+1159:     def depart_centered(self, node: Element) -> None:\n     def depart_centered(self, node: Element) -> None:\n+1160:         self.body.append(CR + r'\\end{center}')\n         self.body.append(CR + r'\\end{center}')\n+1161: \n \n+1162:     def visit_hlist(self, node: Element) -> None:\n     def visit_hlist(self, node: Element) -> None:\n+1163:         self.compact_list += 1\n         self.compact_list += 1\n+1164:         ncolumns = node['ncolumns']\n         ncolumns = node['ncolumns']\n+1165:         if self.compact_list > 1:\n         if self.compact_list > 1:\n+1166:             self.body.append(r'\\setlength{\\multicolsep}{0pt}' + CR)\n             self.body.append(r'\\setlength{\\multicolsep}{0pt}' + CR)\n+1167:         self.body.append(r'\\begin{multicols}{' + ncolumns + r'}\\raggedright' + CR)\n         self.body.append(r'\\begin{multicols}{' + ncolumns + r'}\\raggedright' + CR)\n+1168:         self.body.append(r'\\begin{itemize}\\setlength{\\itemsep}{0pt}'\n         self.body.append(r'\\begin{itemize}\\setlength{\\itemsep}{0pt}'\n+1169:                          r'\\setlength{\\parskip}{0pt}' + CR)\n                          r'\\setlength{\\parskip}{0pt}' + CR)\n+1170:         if self.table:\n         if self.table:\n+1171:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1172: \n \n+1173:     def depart_hlist(self, node: Element) -> None:\n     def depart_hlist(self, node: Element) -> None:\n+1174:         self.compact_list -= 1\n         self.compact_list -= 1\n+1175:         self.body.append(r'\\end{itemize}\\raggedcolumns\\end{multicols}' + CR)\n         self.body.append(r'\\end{itemize}\\raggedcolumns\\end{multicols}' + CR)\n+1176: \n \n+1177:     def visit_hlistcol(self, node: Element) -> None:\n     def visit_hlistcol(self, node: Element) -> None:\n+1178:         pass\n         pass\n+1179: \n \n+1180:     def depart_hlistcol(self, node: Element) -> None:\n     def depart_hlistcol(self, node: Element) -> None:\n+1181:         # \\columnbreak would guarantee same columns as in html output.  But\n         # \\columnbreak would guarantee same columns as in html output.  But\n+1182:         # some testing with long items showed that columns may be too uneven.\n         # some testing with long items showed that columns may be too uneven.\n+1183:         # And in case only of short items, the automatic column breaks should\n         # And in case only of short items, the automatic column breaks should\n+1184:         # match the ones pre-computed by the hlist() directive.\n         # match the ones pre-computed by the hlist() directive.\n+1185:         # self.body.append(r'\\columnbreak\\n')\n         # self.body.append(r'\\columnbreak\\n')\n+1186:         pass\n         pass\n+1187: \n \n+1188:     def latex_image_length(self, width_str: str, scale: int = 100) -> str:\n     def latex_image_length(self, width_str: str, scale: int = 100) -> str:\n+1189:         try:\n         try:\n+1190:             return rstdim_to_latexdim(width_str, scale)\n             return rstdim_to_latexdim(width_str, scale)\n+1191:         except ValueError:\n         except ValueError:\n+1192:             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)\n             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)\n+1193:             return None\n             return None\n+1194: \n \n+1195:     def is_inline(self, node: Element) -> bool:\n     def is_inline(self, node: Element) -> bool:\n+1196:         \"\"\"Check whether a node represents an inline element.\"\"\"\n         \"\"\"Check whether a node represents an inline element.\"\"\"\n+1197:         return isinstance(node.parent, nodes.TextElement)\n         return isinstance(node.parent, nodes.TextElement)\n+1198: \n \n+1199:     def visit_image(self, node: Element) -> None:\n     def visit_image(self, node: Element) -> None:\n+1200:         pre: List[str] = []  # in reverse order\n         pre: List[str] = []  # in reverse order\n+1201:         post: List[str] = []\n         post: List[str] = []\n+1202:         include_graphics_options = []\n         include_graphics_options = []\n+1203:         has_hyperlink = isinstance(node.parent, nodes.reference)\n         has_hyperlink = isinstance(node.parent, nodes.reference)\n+1204:         if has_hyperlink:\n         if has_hyperlink:\n+1205:             is_inline = self.is_inline(node.parent)\n             is_inline = self.is_inline(node.parent)\n+1206:         else:\n         else:\n+1207:             is_inline = self.is_inline(node)\n             is_inline = self.is_inline(node)\n+1208:         if 'width' in node:\n         if 'width' in node:\n+1209:             if 'scale' in node:\n             if 'scale' in node:\n+1210:                 w = self.latex_image_length(node['width'], node['scale'])\n                 w = self.latex_image_length(node['width'], node['scale'])\n+1211:             else:\n             else:\n+1212:                 w = self.latex_image_length(node['width'])\n                 w = self.latex_image_length(node['width'])\n+1213:             if w:\n             if w:\n+1214:                 include_graphics_options.append('width=%s' % w)\n                 include_graphics_options.append('width=%s' % w)\n+1215:         if 'height' in node:\n         if 'height' in node:\n+1216:             if 'scale' in node:\n             if 'scale' in node:\n+1217:                 h = self.latex_image_length(node['height'], node['scale'])\n                 h = self.latex_image_length(node['height'], node['scale'])\n+1218:             else:\n             else:\n+1219:                 h = self.latex_image_length(node['height'])\n                 h = self.latex_image_length(node['height'])\n+1220:             if h:\n             if h:\n+1221:                 include_graphics_options.append('height=%s' % h)\n                 include_graphics_options.append('height=%s' % h)\n+1222:         if 'scale' in node:\n         if 'scale' in node:\n+1223:             if not include_graphics_options:\n             if not include_graphics_options:\n+1224:                 # if no \"width\" nor \"height\", \\sphinxincludegraphics will fit\n                 # if no \"width\" nor \"height\", \\sphinxincludegraphics will fit\n+1225:                 # to the available text width if oversized after rescaling.\n                 # to the available text width if oversized after rescaling.\n+1226:                 include_graphics_options.append('scale=%s'\n                 include_graphics_options.append('scale=%s'\n+1227:                                                 % (float(node['scale']) / 100.0))\n                                                 % (float(node['scale']) / 100.0))\n+1228:         if 'align' in node:\n         if 'align' in node:\n+1229:             align_prepost = {\n             align_prepost = {\n+1230:                 # By default latex aligns the top of an image.\n                 # By default latex aligns the top of an image.\n+1231:                 (1, 'top'): ('', ''),\n                 (1, 'top'): ('', ''),\n+1232:                 (1, 'middle'): (r'\\raisebox{-0.5\\height}{', '}'),\n                 (1, 'middle'): (r'\\raisebox{-0.5\\height}{', '}'),\n+1233:                 (1, 'bottom'): (r'\\raisebox{-\\height}{', '}'),\n                 (1, 'bottom'): (r'\\raisebox{-\\height}{', '}'),\n+1234:                 (0, 'center'): (r'{\\hspace*{\\fill}', r'\\hspace*{\\fill}}'),\n                 (0, 'center'): (r'{\\hspace*{\\fill}', r'\\hspace*{\\fill}}'),\n+1235:                 # These 2 don't exactly do the right thing.  The image should\n                 # These 2 don't exactly do the right thing.  The image should\n+1236:                 # be floated alongside the paragraph.  See\n                 # be floated alongside the paragraph.  See\n+1237:                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG\n                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG\n+1238:                 (0, 'left'): ('{', r'\\hspace*{\\fill}}'),\n                 (0, 'left'): ('{', r'\\hspace*{\\fill}}'),\n+1239:                 (0, 'right'): (r'{\\hspace*{\\fill}', '}'),\n                 (0, 'right'): (r'{\\hspace*{\\fill}', '}'),\n+1240:             }\n             }\n+1241:             try:\n             try:\n+1242:                 pre.append(align_prepost[is_inline, node['align']][0])\n                 pre.append(align_prepost[is_inline, node['align']][0])\n+1243:                 post.append(align_prepost[is_inline, node['align']][1])\n                 post.append(align_prepost[is_inline, node['align']][1])\n+1244:             except KeyError:\n             except KeyError:\n+1245:                 pass\n                 pass\n+1246:         if self.in_parsed_literal:\n         if self.in_parsed_literal:\n+1247:             pre.append(r'{\\sphinxunactivateextrasandspace ')\n             pre.append(r'{\\sphinxunactivateextrasandspace ')\n+1248:             post.append('}')\n             post.append('}')\n+1249:         if not is_inline and not has_hyperlink:\n         if not is_inline and not has_hyperlink:\n+1250:             pre.append(CR + r'\\noindent')\n             pre.append(CR + r'\\noindent')\n+1251:             post.append(CR)\n             post.append(CR)\n+1252:         pre.reverse()\n         pre.reverse()\n+1253:         if node['uri'] in self.builder.images:\n         if node['uri'] in self.builder.images:\n+1254:             uri = self.builder.images[node['uri']]\n             uri = self.builder.images[node['uri']]\n+1255:         else:\n         else:\n+1256:             # missing image!\n             # missing image!\n+1257:             if self.ignore_missing_images:\n             if self.ignore_missing_images:\n+1258:                 return\n                 return\n+1259:             uri = node['uri']\n             uri = node['uri']\n+1260:         if uri.find('://') != -1:\n         if uri.find('://') != -1:\n+1261:             # ignore remote images\n             # ignore remote images\n+1262:             return\n             return\n+1263:         self.body.extend(pre)\n         self.body.extend(pre)\n+1264:         options = ''\n         options = ''\n+1265:         if include_graphics_options:\n         if include_graphics_options:\n+1266:             options = '[%s]' % ','.join(include_graphics_options)\n             options = '[%s]' % ','.join(include_graphics_options)\n+1267:         base, ext = path.splitext(uri)\n         base, ext = path.splitext(uri)\n+1268:         if self.in_title and base:\n         if self.in_title and base:\n+1269:             # Lowercase tokens forcely because some fncychap themes capitalize\n             # Lowercase tokens forcely because some fncychap themes capitalize\n+1270:             # the options of \\sphinxincludegraphics unexpectedly (ex. WIDTH=...).\n             # the options of \\sphinxincludegraphics unexpectedly (ex. WIDTH=...).\n+1271:             self.body.append(r'\\lowercase{\\sphinxincludegraphics%s}{{%s}%s}' %\n             self.body.append(r'\\lowercase{\\sphinxincludegraphics%s}{{%s}%s}' %\n+1272:                              (options, base, ext))\n                              (options, base, ext))\n+1273:         else:\n         else:\n+1274:             self.body.append(r'\\sphinxincludegraphics%s{{%s}%s}' %\n             self.body.append(r'\\sphinxincludegraphics%s{{%s}%s}' %\n+1275:                              (options, base, ext))\n                              (options, base, ext))\n+1276:         self.body.extend(post)\n         self.body.extend(post)\n+1277: \n \n+1278:     def depart_image(self, node: Element) -> None:\n     def depart_image(self, node: Element) -> None:\n+1279:         pass\n         pass\n+1280: \n \n+1281:     def visit_figure(self, node: Element) -> None:\n     def visit_figure(self, node: Element) -> None:\n+1282:         align = self.elements['figure_align']\n         align = self.elements['figure_align']\n+1283:         if self.no_latex_floats:\n         if self.no_latex_floats:\n+1284:             align = \"H\"\n             align = \"H\"\n+1285:         if self.table:\n         if self.table:\n+1286:             # TODO: support align option\n             # TODO: support align option\n+1287:             if 'width' in node:\n             if 'width' in node:\n+1288:                 length = self.latex_image_length(node['width'])\n                 length = self.latex_image_length(node['width'])\n+1289:                 if length:\n                 if length:\n+1290:                     self.body.append(r'\\begin{sphinxfigure-in-table}[%s]' % length + CR)\n                     self.body.append(r'\\begin{sphinxfigure-in-table}[%s]' % length + CR)\n+1291:                     self.body.append(r'\\centering' + CR)\n                     self.body.append(r'\\centering' + CR)\n+1292:             else:\n             else:\n+1293:                 self.body.append(r'\\begin{sphinxfigure-in-table}' + CR)\n                 self.body.append(r'\\begin{sphinxfigure-in-table}' + CR)\n+1294:                 self.body.append(r'\\centering' + CR)\n                 self.body.append(r'\\centering' + CR)\n+1295:             if any(isinstance(child, nodes.caption) for child in node):\n             if any(isinstance(child, nodes.caption) for child in node):\n+1296:                 self.body.append(r'\\capstart')\n                 self.body.append(r'\\capstart')\n+1297:             self.context.append(r'\\end{sphinxfigure-in-table}\\relax' + CR)\n             self.context.append(r'\\end{sphinxfigure-in-table}\\relax' + CR)\n+1298:         elif node.get('align', '') in ('left', 'right'):\n         elif node.get('align', '') in ('left', 'right'):\n+1299:             length = None\n             length = None\n+1300:             if 'width' in node:\n             if 'width' in node:\n+1301:                 length = self.latex_image_length(node['width'])\n                 length = self.latex_image_length(node['width'])\n+1302:             elif isinstance(node[0], nodes.image) and 'width' in node[0]:\n             elif isinstance(node[0], nodes.image) and 'width' in node[0]:\n+1303:                 length = self.latex_image_length(node[0]['width'])\n                 length = self.latex_image_length(node[0]['width'])\n+1304:             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop\n             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop\n+1305:                                             # https://github.com/sphinx-doc/sphinx/issues/7059\n                                             # https://github.com/sphinx-doc/sphinx/issues/7059\n+1306:             self.body.append(r'\\begin{wrapfigure}{%s}{%s}' %\n             self.body.append(r'\\begin{wrapfigure}{%s}{%s}' %\n+1307:                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)\n                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)\n+1308:             self.body.append(r'\\centering')\n             self.body.append(r'\\centering')\n+1309:             self.context.append(r'\\end{wrapfigure}' + CR)\n             self.context.append(r'\\end{wrapfigure}' + CR)\n+1310:         elif self.in_minipage:\n         elif self.in_minipage:\n+1311:             self.body.append(CR + r'\\begin{center}')\n             self.body.append(CR + r'\\begin{center}')\n+1312:             self.context.append(r'\\end{center}' + CR)\n             self.context.append(r'\\end{center}' + CR)\n+1313:         else:\n         else:\n+1314:             self.body.append(CR + r'\\begin{figure}[%s]' % align + CR)\n             self.body.append(CR + r'\\begin{figure}[%s]' % align + CR)\n+1315:             self.body.append(r'\\centering' + CR)\n             self.body.append(r'\\centering' + CR)\n+1316:             if any(isinstance(child, nodes.caption) for child in node):\n             if any(isinstance(child, nodes.caption) for child in node):\n+1317:                 self.body.append(r'\\capstart' + CR)\n                 self.body.append(r'\\capstart' + CR)\n+1318:             self.context.append(r'\\end{figure}' + CR)\n             self.context.append(r'\\end{figure}' + CR)\n+1319: \n \n+1320:     def depart_figure(self, node: Element) -> None:\n     def depart_figure(self, node: Element) -> None:\n+1321:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+1322: \n \n+1323:     def visit_caption(self, node: Element) -> None:\n     def visit_caption(self, node: Element) -> None:\n+1324:         self.in_caption += 1\n         self.in_caption += 1\n+1325:         if isinstance(node.parent, captioned_literal_block):\n         if isinstance(node.parent, captioned_literal_block):\n+1326:             self.body.append(r'\\sphinxSetupCaptionForVerbatim{')\n             self.body.append(r'\\sphinxSetupCaptionForVerbatim{')\n+1327:         elif self.in_minipage and isinstance(node.parent, nodes.figure):\n         elif self.in_minipage and isinstance(node.parent, nodes.figure):\n+1328:             self.body.append(r'\\captionof{figure}{')\n             self.body.append(r'\\captionof{figure}{')\n+1329:         elif self.table and node.parent.tagname == 'figure':\n         elif self.table and node.parent.tagname == 'figure':\n+1330:             self.body.append(r'\\sphinxfigcaption{')\n             self.body.append(r'\\sphinxfigcaption{')\n+1331:         else:\n         else:\n+1332:             self.body.append(r'\\caption{')\n             self.body.append(r'\\caption{')\n+1333: \n \n+1334:     def depart_caption(self, node: Element) -> None:\n     def depart_caption(self, node: Element) -> None:\n+1335:         self.body.append('}')\n         self.body.append('}')\n+1336:         if isinstance(node.parent, nodes.figure):\n         if isinstance(node.parent, nodes.figure):\n+1337:             labels = self.hypertarget_to(node.parent)\n             labels = self.hypertarget_to(node.parent)\n+1338:             self.body.append(labels)\n             self.body.append(labels)\n+1339:         self.in_caption -= 1\n         self.in_caption -= 1\n+1340: \n \n+1341:     def visit_legend(self, node: Element) -> None:\n     def visit_legend(self, node: Element) -> None:\n+1342:         self.body.append(CR + r'\\begin{sphinxlegend}')\n         self.body.append(CR + r'\\begin{sphinxlegend}')\n+1343: \n \n+1344:     def depart_legend(self, node: Element) -> None:\n     def depart_legend(self, node: Element) -> None:\n+1345:         self.body.append(r'\\end{sphinxlegend}' + CR)\n         self.body.append(r'\\end{sphinxlegend}' + CR)\n+1346: \n \n+1347:     def visit_admonition(self, node: Element) -> None:\n     def visit_admonition(self, node: Element) -> None:\n+1348:         self.body.append(CR + r'\\begin{sphinxadmonition}{note}')\n         self.body.append(CR + r'\\begin{sphinxadmonition}{note}')\n+1349:         self.no_latex_floats += 1\n         self.no_latex_floats += 1\n+1350: \n \n+1351:     def depart_admonition(self, node: Element) -> None:\n     def depart_admonition(self, node: Element) -> None:\n+1352:         self.body.append(r'\\end{sphinxadmonition}' + CR)\n         self.body.append(r'\\end{sphinxadmonition}' + CR)\n+1353:         self.no_latex_floats -= 1\n         self.no_latex_floats -= 1\n+1354: \n \n+1355:     def _visit_named_admonition(self, node: Element) -> None:\n     def _visit_named_admonition(self, node: Element) -> None:\n+1356:         label = admonitionlabels[node.tagname]\n         label = admonitionlabels[node.tagname]\n+1357:         self.body.append(CR + r'\\begin{sphinxadmonition}{%s}{%s:}' %\n         self.body.append(CR + r'\\begin{sphinxadmonition}{%s}{%s:}' %\n+1358:                          (node.tagname, label))\n                          (node.tagname, label))\n+1359:         self.no_latex_floats += 1\n         self.no_latex_floats += 1\n+1360: \n \n+1361:     def _depart_named_admonition(self, node: Element) -> None:\n     def _depart_named_admonition(self, node: Element) -> None:\n+1362:         self.body.append(r'\\end{sphinxadmonition}' + CR)\n         self.body.append(r'\\end{sphinxadmonition}' + CR)\n+1363:         self.no_latex_floats -= 1\n         self.no_latex_floats -= 1\n+1364: \n \n+1365:     visit_attention = _visit_named_admonition\n     visit_attention = _visit_named_admonition\n+1366:     depart_attention = _depart_named_admonition\n     depart_attention = _depart_named_admonition\n+1367:     visit_caution = _visit_named_admonition\n     visit_caution = _visit_named_admonition\n+1368:     depart_caution = _depart_named_admonition\n     depart_caution = _depart_named_admonition\n+1369:     visit_danger = _visit_named_admonition\n     visit_danger = _visit_named_admonition\n+1370:     depart_danger = _depart_named_admonition\n     depart_danger = _depart_named_admonition\n+1371:     visit_error = _visit_named_admonition\n     visit_error = _visit_named_admonition\n+1372:     depart_error = _depart_named_admonition\n     depart_error = _depart_named_admonition\n+1373:     visit_hint = _visit_named_admonition\n     visit_hint = _visit_named_admonition\n+1374:     depart_hint = _depart_named_admonition\n     depart_hint = _depart_named_admonition\n+1375:     visit_important = _visit_named_admonition\n     visit_important = _visit_named_admonition\n+1376:     depart_important = _depart_named_admonition\n     depart_important = _depart_named_admonition\n+1377:     visit_note = _visit_named_admonition\n     visit_note = _visit_named_admonition\n+1378:     depart_note = _depart_named_admonition\n     depart_note = _depart_named_admonition\n+1379:     visit_tip = _visit_named_admonition\n     visit_tip = _visit_named_admonition\n+1380:     depart_tip = _depart_named_admonition\n     depart_tip = _depart_named_admonition\n+1381:     visit_warning = _visit_named_admonition\n     visit_warning = _visit_named_admonition\n+1382:     depart_warning = _depart_named_admonition\n     depart_warning = _depart_named_admonition\n+1383: \n \n+1384:     def visit_versionmodified(self, node: Element) -> None:\n     def visit_versionmodified(self, node: Element) -> None:\n+1385:         pass\n         pass\n+1386: \n \n+1387:     def depart_versionmodified(self, node: Element) -> None:\n     def depart_versionmodified(self, node: Element) -> None:\n+1388:         pass\n         pass\n+1389: \n \n+1390:     def visit_target(self, node: Element) -> None:\n     def visit_target(self, node: Element) -> None:\n+1391:         def add_target(id: str) -> None:\n         def add_target(id: str) -> None:\n+1392:             # indexing uses standard LaTeX index markup, so the targets\n             # indexing uses standard LaTeX index markup, so the targets\n+1393:             # will be generated differently\n             # will be generated differently\n+1394:             if id.startswith('index-'):\n             if id.startswith('index-'):\n+1395:                 return\n                 return\n+1396: \n \n+1397:             # equations also need no extra blank line nor hypertarget\n             # equations also need no extra blank line nor hypertarget\n+1398:             # TODO: fix this dependency on mathbase extension internals\n             # TODO: fix this dependency on mathbase extension internals\n+1399:             if id.startswith('equation-'):\n             if id.startswith('equation-'):\n+1400:                 return\n                 return\n+1401: \n \n+1402:             # insert blank line, if the target follows a paragraph node\n             # insert blank line, if the target follows a paragraph node\n+1403:             index = node.parent.index(node)\n             index = node.parent.index(node)\n+1404:             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):\n             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):\n+1405:                 self.body.append(CR)\n                 self.body.append(CR)\n+1406: \n \n+1407:             # do not generate \\phantomsection in \\section{}\n             # do not generate \\phantomsection in \\section{}\n+1408:             anchor = not self.in_title\n             anchor = not self.in_title\n+1409:             self.body.append(self.hypertarget(id, anchor=anchor))\n             self.body.append(self.hypertarget(id, anchor=anchor))\n+1410: \n \n+1411:         # skip if visitor for next node supports hyperlink\n         # skip if visitor for next node supports hyperlink\n+1412:         next_node: Node = node\n         next_node: Node = node\n+1413:         while isinstance(next_node, nodes.target):\n         while isinstance(next_node, nodes.target):\n+1414:             next_node = next_node.next_node(ascend=True)\n             next_node = next_node.next_node(ascend=True)\n+1415: \n \n+1416:         domain = cast(StandardDomain, self.builder.env.get_domain('std'))\n         domain = cast(StandardDomain, self.builder.env.get_domain('std'))\n+1417:         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):\n         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):\n+1418:             return\n             return\n+1419:         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):\n         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):\n+1420:             return\n             return\n+1421: \n \n+1422:         if 'refuri' in node:\n         if 'refuri' in node:\n+1423:             return\n             return\n+1424:         if 'anonymous' in node:\n         if 'anonymous' in node:\n+1425:             return\n             return\n+1426:         if node.get('refid'):\n         if node.get('refid'):\n+1427:             prev_node = get_prev_node(node)\n             prev_node = get_prev_node(node)\n+1428:             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:\n             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:\n+1429:                 # a target for a hyperlink reference having alias\n                 # a target for a hyperlink reference having alias\n+1430:                 pass\n                 pass\n+1431:             else:\n             else:\n+1432:                 add_target(node['refid'])\n                 add_target(node['refid'])\n+1433:         for id in node['ids']:\n         for id in node['ids']:\n+1434:             add_target(id)\n             add_target(id)\n+1435: \n \n+1436:     def depart_target(self, node: Element) -> None:\n     def depart_target(self, node: Element) -> None:\n+1437:         pass\n         pass\n+1438: \n \n+1439:     def visit_attribution(self, node: Element) -> None:\n     def visit_attribution(self, node: Element) -> None:\n+1440:         self.body.append(CR + r'\\begin{flushright}' + CR)\n         self.body.append(CR + r'\\begin{flushright}' + CR)\n+1441:         self.body.append('---')\n         self.body.append('---')\n+1442: \n \n+1443:     def depart_attribution(self, node: Element) -> None:\n     def depart_attribution(self, node: Element) -> None:\n+1444:         self.body.append(CR + r'\\end{flushright}' + CR)\n         self.body.append(CR + r'\\end{flushright}' + CR)\n+1445: \n \n+1446:     def visit_index(self, node: Element) -> None:\n     def visit_index(self, node: Element) -> None:\n+1447:         def escape(value: str) -> str:\n         def escape(value: str) -> str:\n+1448:             value = self.encode(value)\n             value = self.encode(value)\n+1449:             value = value.replace(r'\\{', r'\\sphinxleftcurlybrace{}')\n             value = value.replace(r'\\{', r'\\sphinxleftcurlybrace{}')\n+1450:             value = value.replace(r'\\}', r'\\sphinxrightcurlybrace{}')\n             value = value.replace(r'\\}', r'\\sphinxrightcurlybrace{}')\n+1451:             value = value.replace('\"', '\"\"')\n             value = value.replace('\"', '\"\"')\n+1452:             value = value.replace('@', '\"@')\n             value = value.replace('@', '\"@')\n+1453:             value = value.replace('!', '\"!')\n             value = value.replace('!', '\"!')\n+1454:             value = value.replace('|', r'\\textbar{}')\n             value = value.replace('|', r'\\textbar{}')\n+1455:             return value\n             return value\n+1456: \n \n+1457:         def style(string: str) -> str:\n         def style(string: str) -> str:\n+1458:             match = EXTRA_RE.match(string)\n             match = EXTRA_RE.match(string)\n+1459:             if match:\n             if match:\n+1460:                 return match.expand(r'\\\\spxentry{\\1}\\\\spxextra{\\2}')\n                 return match.expand(r'\\\\spxentry{\\1}\\\\spxextra{\\2}')\n+1461:             else:\n             else:\n+1462:                 return r'\\spxentry{%s}' % string\n                 return r'\\spxentry{%s}' % string\n+1463: \n \n+1464:         if not node.get('inline', True):\n         if not node.get('inline', True):\n+1465:             self.body.append(CR)\n             self.body.append(CR)\n+1466:         entries = node['entries']\n         entries = node['entries']\n+1467:         for type, string, _tid, ismain, _key in entries:\n         for type, string, _tid, ismain, _key in entries:\n+1468:             m = ''\n             m = ''\n+1469:             if ismain:\n             if ismain:\n+1470:                 m = '|spxpagem'\n                 m = '|spxpagem'\n+1471:             try:\n             try:\n+1472:                 if type == 'single':\n                 if type == 'single':\n+1473:                     try:\n                     try:\n+1474:                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]\n                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]\n+1475:                         P1, P2 = style(p1), style(p2)\n                         P1, P2 = style(p1), style(p2)\n+1476:                         self.body.append(r'\\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))\n                         self.body.append(r'\\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))\n+1477:                     except ValueError:\n                     except ValueError:\n+1478:                         p = escape(split_into(1, 'single', string)[0])\n                         p = escape(split_into(1, 'single', string)[0])\n+1479:                         P = style(p)\n                         P = style(p)\n+1480:                         self.body.append(r'\\index{%s@%s%s}' % (p, P, m))\n                         self.body.append(r'\\index{%s@%s%s}' % (p, P, m))\n+1481:                 elif type == 'pair':\n                 elif type == 'pair':\n+1482:                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]\n                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]\n+1483:                     P1, P2 = style(p1), style(p2)\n                     P1, P2 = style(p1), style(p2)\n+1484:                     self.body.append(r'\\index{%s@%s!%s@%s%s}\\index{%s@%s!%s@%s%s}' %\n                     self.body.append(r'\\index{%s@%s!%s@%s%s}\\index{%s@%s!%s@%s%s}' %\n+1485:                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))\n                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))\n+1486:                 elif type == 'triple':\n                 elif type == 'triple':\n+1487:                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]\n                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]\n+1488:                     P1, P2, P3 = style(p1), style(p2), style(p3)\n                     P1, P2, P3 = style(p1), style(p2), style(p3)\n+1489:                     self.body.append(\n                     self.body.append(\n+1490:                         r'\\index{%s@%s!%s %s@%s %s%s}'\n                         r'\\index{%s@%s!%s %s@%s %s%s}'\n+1491:                         r'\\index{%s@%s!%s, %s@%s, %s%s}'\n                         r'\\index{%s@%s!%s, %s@%s, %s%s}'\n+1492:                         r'\\index{%s@%s!%s %s@%s %s%s}' %\n                         r'\\index{%s@%s!%s %s@%s %s%s}' %\n+1493:                         (p1, P1, p2, p3, P2, P3, m,\n                         (p1, P1, p2, p3, P2, P3, m,\n+1494:                          p2, P2, p3, p1, P3, P1, m,\n                          p2, P2, p3, p1, P3, P1, m,\n+1495:                          p3, P3, p1, p2, P1, P2, m))\n                          p3, P3, p1, p2, P1, P2, m))\n+1496:                 elif type == 'see':\n                 elif type == 'see':\n+1497:                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]\n                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]\n+1498:                     P1 = style(p1)\n                     P1 = style(p1)\n+1499:                     self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n                     self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n+1500:                 elif type == 'seealso':\n                 elif type == 'seealso':\n+1501:                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]\n                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]\n+1502:                     P1 = style(p1)\n                     P1 = style(p1)\n+1503:                     self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n                     self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n+1504:                 else:\n                 else:\n+1505:                     logger.warning(__('unknown index entry type %s found'), type)\n                     logger.warning(__('unknown index entry type %s found'), type)\n+1506:             except ValueError as err:\n             except ValueError as err:\n+1507:                 logger.warning(str(err))\n                 logger.warning(str(err))\n+1508:         if not node.get('inline', True):\n         if not node.get('inline', True):\n+1509:             self.body.append(r'\\ignorespaces ')\n             self.body.append(r'\\ignorespaces ')\n+1510:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1511: \n \n+1512:     def visit_raw(self, node: Element) -> None:\n     def visit_raw(self, node: Element) -> None:\n+1513:         if not self.is_inline(node):\n         if not self.is_inline(node):\n+1514:             self.body.append(CR)\n             self.body.append(CR)\n+1515:         if 'latex' in node.get('format', '').split():\n         if 'latex' in node.get('format', '').split():\n+1516:             self.body.append(node.astext())\n             self.body.append(node.astext())\n+1517:         if not self.is_inline(node):\n         if not self.is_inline(node):\n+1518:             self.body.append(CR)\n             self.body.append(CR)\n+1519:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1520: \n \n+1521:     def visit_reference(self, node: Element) -> None:\n     def visit_reference(self, node: Element) -> None:\n+1522:         if not self.in_title:\n         if not self.in_title:\n+1523:             for id in node.get('ids'):\n             for id in node.get('ids'):\n+1524:                 anchor = not self.in_caption\n                 anchor = not self.in_caption\n+1525:                 self.body += self.hypertarget(id, anchor=anchor)\n                 self.body += self.hypertarget(id, anchor=anchor)\n+1526:         if not self.is_inline(node):\n         if not self.is_inline(node):\n+1527:             self.body.append(CR)\n             self.body.append(CR)\n+1528:         uri = node.get('refuri', '')\n         uri = node.get('refuri', '')\n+1529:         if not uri and node.get('refid'):\n         if not uri and node.get('refid'):\n+1530:             uri = '%' + self.curfilestack[-1] + '#' + node['refid']\n             uri = '%' + self.curfilestack[-1] + '#' + node['refid']\n+1531:         if self.in_title or not uri:\n         if self.in_title or not uri:\n+1532:             self.context.append('')\n             self.context.append('')\n+1533:         elif uri.startswith('#'):\n         elif uri.startswith('#'):\n+1534:             # references to labels in the same document\n             # references to labels in the same document\n+1535:             id = self.curfilestack[-1] + ':' + uri[1:]\n             id = self.curfilestack[-1] + ':' + uri[1:]\n+1536:             self.body.append(self.hyperlink(id))\n             self.body.append(self.hyperlink(id))\n+1537:             self.body.append(r'\\emph{')\n             self.body.append(r'\\emph{')\n+1538:             if self.config.latex_show_pagerefs and not \\\n             if self.config.latex_show_pagerefs and not \\\n+1539:                     self.in_production_list:\n                     self.in_production_list:\n+1540:                 self.context.append('}}} (%s)' % self.hyperpageref(id))\n                 self.context.append('}}} (%s)' % self.hyperpageref(id))\n+1541:             else:\n             else:\n+1542:                 self.context.append('}}}')\n                 self.context.append('}}}')\n+1543:         elif uri.startswith('%'):\n         elif uri.startswith('%'):\n+1544:             # references to documents or labels inside documents\n             # references to documents or labels inside documents\n+1545:             hashindex = uri.find('#')\n             hashindex = uri.find('#')\n+1546:             if hashindex == -1:\n             if hashindex == -1:\n+1547:                 # reference to the document\n                 # reference to the document\n+1548:                 id = uri[1:] + '::doc'\n                 id = uri[1:] + '::doc'\n+1549:             else:\n             else:\n+1550:                 # reference to a label\n                 # reference to a label\n+1551:                 id = uri[1:].replace('#', ':')\n                 id = uri[1:].replace('#', ':')\n+1552:             self.body.append(self.hyperlink(id))\n             self.body.append(self.hyperlink(id))\n+1553:             if (len(node) and\n             if (len(node) and\n+1554:                     isinstance(node[0], nodes.Element) and\n                     isinstance(node[0], nodes.Element) and\n+1555:                     'std-term' in node[0].get('classes', [])):\n                     'std-term' in node[0].get('classes', [])):\n+1556:                 # don't add a pageref for glossary terms\n                 # don't add a pageref for glossary terms\n+1557:                 self.context.append('}}}')\n                 self.context.append('}}}')\n+1558:                 # mark up as termreference\n                 # mark up as termreference\n+1559:                 self.body.append(r'\\sphinxtermref{')\n                 self.body.append(r'\\sphinxtermref{')\n+1560:             else:\n             else:\n+1561:                 self.body.append(r'\\sphinxcrossref{')\n                 self.body.append(r'\\sphinxcrossref{')\n+1562:                 if self.config.latex_show_pagerefs and not self.in_production_list:\n                 if self.config.latex_show_pagerefs and not self.in_production_list:\n+1563:                     self.context.append('}}} (%s)' % self.hyperpageref(id))\n                     self.context.append('}}} (%s)' % self.hyperpageref(id))\n+1564:                 else:\n                 else:\n+1565:                     self.context.append('}}}')\n                     self.context.append('}}}')\n+1566:         else:\n         else:\n+1567:             if len(node) == 1 and uri == node[0]:\n             if len(node) == 1 and uri == node[0]:\n+1568:                 if node.get('nolinkurl'):\n                 if node.get('nolinkurl'):\n+1569:                     self.body.append(r'\\sphinxnolinkurl{%s}' % self.encode_uri(uri))\n                     self.body.append(r'\\sphinxnolinkurl{%s}' % self.encode_uri(uri))\n+1570:                 else:\n                 else:\n+1571:                     self.body.append(r'\\sphinxurl{%s}' % self.encode_uri(uri))\n                     self.body.append(r'\\sphinxurl{%s}' % self.encode_uri(uri))\n+1572:                 raise nodes.SkipNode\n                 raise nodes.SkipNode\n+1573:             else:\n             else:\n+1574:                 self.body.append(r'\\sphinxhref{%s}{' % self.encode_uri(uri))\n                 self.body.append(r'\\sphinxhref{%s}{' % self.encode_uri(uri))\n+1575:                 self.context.append('}')\n                 self.context.append('}')\n+1576: \n \n+1577:     def depart_reference(self, node: Element) -> None:\n     def depart_reference(self, node: Element) -> None:\n+1578:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+1579:         if not self.is_inline(node):\n         if not self.is_inline(node):\n+1580:             self.body.append(CR)\n             self.body.append(CR)\n+1581: \n \n+1582:     def visit_number_reference(self, node: Element) -> None:\n     def visit_number_reference(self, node: Element) -> None:\n+1583:         if node.get('refid'):\n         if node.get('refid'):\n+1584:             id = self.curfilestack[-1] + ':' + node['refid']\n             id = self.curfilestack[-1] + ':' + node['refid']\n+1585:         else:\n         else:\n+1586:             id = node.get('refuri', '')[1:].replace('#', ':')\n             id = node.get('refuri', '')[1:].replace('#', ':')\n+1587: \n \n+1588:         title = self.escape(node.get('title', '%s')).replace(r'\\%s', '%s')\n         title = self.escape(node.get('title', '%s')).replace(r'\\%s', '%s')\n+1589:         if r'\\{name\\}' in title or r'\\{number\\}' in title:\n         if r'\\{name\\}' in title or r'\\{number\\}' in title:\n+1590:             # new style format (cf. \"Fig.%{number}\")\n             # new style format (cf. \"Fig.%{number}\")\n+1591:             title = title.replace(r'\\{name\\}', '{name}').replace(r'\\{number\\}', '{number}')\n             title = title.replace(r'\\{name\\}', '{name}').replace(r'\\{number\\}', '{number}')\n+1592:             text = escape_abbr(title).format(name=r'\\nameref{%s}' % self.idescape(id),\n             text = escape_abbr(title).format(name=r'\\nameref{%s}' % self.idescape(id),\n+1593:                                              number=r'\\ref{%s}' % self.idescape(id))\n                                              number=r'\\ref{%s}' % self.idescape(id))\n+1594:         else:\n         else:\n+1595:             # old style format (cf. \"Fig.%{number}\")\n             # old style format (cf. \"Fig.%{number}\")\n+1596:             text = escape_abbr(title) % (r'\\ref{%s}' % self.idescape(id))\n             text = escape_abbr(title) % (r'\\ref{%s}' % self.idescape(id))\n+1597:         hyperref = r'\\hyperref[%s]{%s}' % (self.idescape(id), text)\n         hyperref = r'\\hyperref[%s]{%s}' % (self.idescape(id), text)\n+1598:         self.body.append(hyperref)\n         self.body.append(hyperref)\n+1599: \n \n+1600:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1601: \n \n+1602:     def visit_download_reference(self, node: Element) -> None:\n     def visit_download_reference(self, node: Element) -> None:\n+1603:         pass\n         pass\n+1604: \n \n+1605:     def depart_download_reference(self, node: Element) -> None:\n     def depart_download_reference(self, node: Element) -> None:\n+1606:         pass\n         pass\n+1607: \n \n+1608:     def visit_pending_xref(self, node: Element) -> None:\n     def visit_pending_xref(self, node: Element) -> None:\n+1609:         pass\n         pass\n+1610: \n \n+1611:     def depart_pending_xref(self, node: Element) -> None:\n     def depart_pending_xref(self, node: Element) -> None:\n+1612:         pass\n         pass\n+1613: \n \n+1614:     def visit_emphasis(self, node: Element) -> None:\n     def visit_emphasis(self, node: Element) -> None:\n+1615:         self.body.append(r'\\sphinxstyleemphasis{')\n         self.body.append(r'\\sphinxstyleemphasis{')\n+1616: \n \n+1617:     def depart_emphasis(self, node: Element) -> None:\n     def depart_emphasis(self, node: Element) -> None:\n+1618:         self.body.append('}')\n         self.body.append('}')\n+1619: \n \n+1620:     def visit_literal_emphasis(self, node: Element) -> None:\n     def visit_literal_emphasis(self, node: Element) -> None:\n+1621:         self.body.append(r'\\sphinxstyleliteralemphasis{\\sphinxupquote{')\n         self.body.append(r'\\sphinxstyleliteralemphasis{\\sphinxupquote{')\n+1622: \n \n+1623:     def depart_literal_emphasis(self, node: Element) -> None:\n     def depart_literal_emphasis(self, node: Element) -> None:\n+1624:         self.body.append('}}')\n         self.body.append('}}')\n+1625: \n \n+1626:     def visit_strong(self, node: Element) -> None:\n     def visit_strong(self, node: Element) -> None:\n+1627:         self.body.append(r'\\sphinxstylestrong{')\n         self.body.append(r'\\sphinxstylestrong{')\n+1628: \n \n+1629:     def depart_strong(self, node: Element) -> None:\n     def depart_strong(self, node: Element) -> None:\n+1630:         self.body.append('}')\n         self.body.append('}')\n+1631: \n \n+1632:     def visit_literal_strong(self, node: Element) -> None:\n     def visit_literal_strong(self, node: Element) -> None:\n+1633:         self.body.append(r'\\sphinxstyleliteralstrong{\\sphinxupquote{')\n         self.body.append(r'\\sphinxstyleliteralstrong{\\sphinxupquote{')\n+1634: \n \n+1635:     def depart_literal_strong(self, node: Element) -> None:\n     def depart_literal_strong(self, node: Element) -> None:\n+1636:         self.body.append('}}')\n         self.body.append('}}')\n+1637: \n \n+1638:     def visit_abbreviation(self, node: Element) -> None:\n     def visit_abbreviation(self, node: Element) -> None:\n+1639:         abbr = node.astext()\n         abbr = node.astext()\n+1640:         self.body.append(r'\\sphinxstyleabbreviation{')\n         self.body.append(r'\\sphinxstyleabbreviation{')\n+1641:         # spell out the explanation once\n         # spell out the explanation once\n+1642:         if node.hasattr('explanation') and abbr not in self.handled_abbrs:\n         if node.hasattr('explanation') and abbr not in self.handled_abbrs:\n+1643:             self.context.append('} (%s)' % self.encode(node['explanation']))\n             self.context.append('} (%s)' % self.encode(node['explanation']))\n+1644:             self.handled_abbrs.add(abbr)\n             self.handled_abbrs.add(abbr)\n+1645:         else:\n         else:\n+1646:             self.context.append('}')\n             self.context.append('}')\n+1647: \n \n+1648:     def depart_abbreviation(self, node: Element) -> None:\n     def depart_abbreviation(self, node: Element) -> None:\n+1649:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+1650: \n \n+1651:     def visit_manpage(self, node: Element) -> None:\n     def visit_manpage(self, node: Element) -> None:\n+1652:         return self.visit_literal_emphasis(node)\n         return self.visit_literal_emphasis(node)\n+1653: \n \n+1654:     def depart_manpage(self, node: Element) -> None:\n     def depart_manpage(self, node: Element) -> None:\n+1655:         return self.depart_literal_emphasis(node)\n         return self.depart_literal_emphasis(node)\n+1656: \n \n+1657:     def visit_title_reference(self, node: Element) -> None:\n     def visit_title_reference(self, node: Element) -> None:\n+1658:         self.body.append(r'\\sphinxtitleref{')\n         self.body.append(r'\\sphinxtitleref{')\n+1659: \n \n+1660:     def depart_title_reference(self, node: Element) -> None:\n     def depart_title_reference(self, node: Element) -> None:\n+1661:         self.body.append('}')\n         self.body.append('}')\n+1662: \n \n+1663:     def visit_thebibliography(self, node: Element) -> None:\n     def visit_thebibliography(self, node: Element) -> None:\n+1664:         citations = cast(Iterable[nodes.citation], node)\n         citations = cast(Iterable[nodes.citation], node)\n+1665:         labels = (cast(nodes.label, citation[0]) for citation in citations)\n         labels = (cast(nodes.label, citation[0]) for citation in citations)\n+1666:         longest_label = max((label.astext() for label in labels), key=len)\n         longest_label = max((label.astext() for label in labels), key=len)\n+1667:         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:\n         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:\n+1668:             # adjust max width of citation labels not to break the layout\n             # adjust max width of citation labels not to break the layout\n+1669:             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]\n             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]\n+1670: \n \n+1671:         self.body.append(CR + r'\\begin{sphinxthebibliography}{%s}' %\n         self.body.append(CR + r'\\begin{sphinxthebibliography}{%s}' %\n+1672:                          self.encode(longest_label) + CR)\n                          self.encode(longest_label) + CR)\n+1673: \n \n+1674:     def depart_thebibliography(self, node: Element) -> None:\n     def depart_thebibliography(self, node: Element) -> None:\n+1675:         self.body.append(r'\\end{sphinxthebibliography}' + CR)\n         self.body.append(r'\\end{sphinxthebibliography}' + CR)\n+1676: \n \n+1677:     def visit_citation(self, node: Element) -> None:\n     def visit_citation(self, node: Element) -> None:\n+1678:         label = cast(nodes.label, node[0])\n         label = cast(nodes.label, node[0])\n+1679:         self.body.append(r'\\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),\n         self.body.append(r'\\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),\n+1680:                                                    node['docname'], node['ids'][0]))\n                                                    node['docname'], node['ids'][0]))\n+1681: \n \n+1682:     def depart_citation(self, node: Element) -> None:\n     def depart_citation(self, node: Element) -> None:\n+1683:         pass\n         pass\n+1684: \n \n+1685:     def visit_citation_reference(self, node: Element) -> None:\n     def visit_citation_reference(self, node: Element) -> None:\n+1686:         if self.in_title:\n         if self.in_title:\n+1687:             pass\n             pass\n+1688:         else:\n         else:\n+1689:             self.body.append(r'\\sphinxcite{%s:%s}' % (node['docname'], node['refname']))\n             self.body.append(r'\\sphinxcite{%s:%s}' % (node['docname'], node['refname']))\n+1690:             raise nodes.SkipNode\n             raise nodes.SkipNode\n+1691: \n \n+1692:     def depart_citation_reference(self, node: Element) -> None:\n     def depart_citation_reference(self, node: Element) -> None:\n+1693:         pass\n         pass\n+1694: \n \n+1695:     def visit_literal(self, node: Element) -> None:\n     def visit_literal(self, node: Element) -> None:\n+1696:         if self.in_title:\n         if self.in_title:\n+1697:             self.body.append(r'\\sphinxstyleliteralintitle{\\sphinxupquote{')\n             self.body.append(r'\\sphinxstyleliteralintitle{\\sphinxupquote{')\n+1698:             return\n             return\n+1699:         elif 'kbd' in node['classes']:\n         elif 'kbd' in node['classes']:\n+1700:             self.body.append(r'\\sphinxkeyboard{\\sphinxupquote{')\n             self.body.append(r'\\sphinxkeyboard{\\sphinxupquote{')\n+1701:             return\n             return\n+1702:         lang = node.get(\"language\", None)\n         lang = node.get(\"language\", None)\n+1703:         if 'code' not in node['classes'] or not lang:\n         if 'code' not in node['classes'] or not lang:\n-            self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+1704:             self.body.append(r'\\sphinxcode{\\sphinxupquote{%')\n+            self.body.append(r'\\sphinxcode{\\sphinxupquote{%')\n+1705:             return\n             return\n+1706: \n \n+1707:         opts = self.config.highlight_options.get(lang, {})\n         opts = self.config.highlight_options.get(lang, {})\n+1708:         hlcode = self.highlighter.highlight_block(\n         hlcode = self.highlighter.highlight_block(\n+1709:             node.astext(), lang, opts=opts, location=node)\n             node.astext(), lang, opts=opts, location=node)\n+1710:         # TODO: Use nowrap option once LaTeX formatter supports it\n         # TODO: Use nowrap option once LaTeX formatter supports it\n+1711:         # https://github.com/pygments/pygments/pull/1343\n         # https://github.com/pygments/pygments/pull/1343\n+1712:         hlcode = hlcode.replace(r'\\begin{Verbatim}[commandchars=\\\\\\{\\}]',\n         hlcode = hlcode.replace(r'\\begin{Verbatim}[commandchars=\\\\\\{\\}]',\n+1713:                                 r'\\sphinxcode{\\sphinxupquote{')\n                                 r'\\sphinxcode{\\sphinxupquote{')\n+1714:         # get consistent trailer\n         # get consistent trailer\n+1715:         hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n         hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n+1716:         self.body.append(hlcode)\n         self.body.append(hlcode)\n+1717:         self.body.append('}}')\n         self.body.append('}}')\n+1718:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1719: \n \n+1720:     def depart_literal(self, node: Element) -> None:\n     def depart_literal(self, node: Element) -> None:\n+1721:         self.body.append('}}')\n         self.body.append('}}')\n+1722: \n \n+1723:     def visit_footnote_reference(self, node: Element) -> None:\n     def visit_footnote_reference(self, node: Element) -> None:\n+1724:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1725: \n \n+1726:     def visit_footnotemark(self, node: Element) -> None:\n     def visit_footnotemark(self, node: Element) -> None:\n+1727:         self.body.append(r'\\sphinxfootnotemark[')\n         self.body.append(r'\\sphinxfootnotemark[')\n+1728: \n \n+1729:     def depart_footnotemark(self, node: Element) -> None:\n     def depart_footnotemark(self, node: Element) -> None:\n+1730:         self.body.append(']')\n         self.body.append(']')\n+1731: \n \n+1732:     def visit_footnotetext(self, node: Element) -> None:\n     def visit_footnotetext(self, node: Element) -> None:\n+1733:         label = cast(nodes.label, node[0])\n         label = cast(nodes.label, node[0])\n+1734:         self.body.append('%' + CR)\n         self.body.append('%' + CR)\n+1735:         self.body.append(r'\\begin{footnotetext}[%s]' % label.astext())\n         self.body.append(r'\\begin{footnotetext}[%s]' % label.astext())\n+1736:         self.body.append(r'\\sphinxAtStartFootnote' + CR)\n         self.body.append(r'\\sphinxAtStartFootnote' + CR)\n+1737: \n \n+1738:     def depart_footnotetext(self, node: Element) -> None:\n     def depart_footnotetext(self, node: Element) -> None:\n+1739:         # the \\ignorespaces in particular for after table header use\n         # the \\ignorespaces in particular for after table header use\n+1740:         self.body.append('%' + CR)\n         self.body.append('%' + CR)\n+1741:         self.body.append(r'\\end{footnotetext}\\ignorespaces ')\n         self.body.append(r'\\end{footnotetext}\\ignorespaces ')\n+1742: \n \n+1743:     def visit_captioned_literal_block(self, node: Element) -> None:\n     def visit_captioned_literal_block(self, node: Element) -> None:\n+1744:         pass\n         pass\n+1745: \n \n+1746:     def depart_captioned_literal_block(self, node: Element) -> None:\n     def depart_captioned_literal_block(self, node: Element) -> None:\n+1747:         pass\n         pass\n+1748: \n \n+1749:     def visit_literal_block(self, node: Element) -> None:\n     def visit_literal_block(self, node: Element) -> None:\n+1750:         if node.rawsource != node.astext():\n         if node.rawsource != node.astext():\n+1751:             # most probably a parsed-literal block -- don't highlight\n             # most probably a parsed-literal block -- don't highlight\n+1752:             self.in_parsed_literal += 1\n             self.in_parsed_literal += 1\n+1753:             self.body.append(r'\\begin{sphinxalltt}' + CR)\n             self.body.append(r'\\begin{sphinxalltt}' + CR)\n+1754:         else:\n         else:\n+1755:             labels = self.hypertarget_to(node)\n             labels = self.hypertarget_to(node)\n+1756:             if isinstance(node.parent, captioned_literal_block):\n             if isinstance(node.parent, captioned_literal_block):\n+1757:                 labels += self.hypertarget_to(node.parent)\n                 labels += self.hypertarget_to(node.parent)\n+1758:             if labels and not self.in_footnote:\n             if labels and not self.in_footnote:\n+1759:                 self.body.append(CR + r'\\def\\sphinxLiteralBlockLabel{' + labels + '}')\n                 self.body.append(CR + r'\\def\\sphinxLiteralBlockLabel{' + labels + '}')\n+1760: \n \n+1761:             lang = node.get('language', 'default')\n             lang = node.get('language', 'default')\n+1762:             linenos = node.get('linenos', False)\n             linenos = node.get('linenos', False)\n+1763:             highlight_args = node.get('highlight_args', {})\n             highlight_args = node.get('highlight_args', {})\n+1764:             highlight_args['force'] = node.get('force', False)\n             highlight_args['force'] = node.get('force', False)\n+1765:             opts = self.config.highlight_options.get(lang, {})\n             opts = self.config.highlight_options.get(lang, {})\n+1766: \n \n+1767:             hlcode = self.highlighter.highlight_block(\n             hlcode = self.highlighter.highlight_block(\n+1768:                 node.rawsource, lang, opts=opts, linenos=linenos,\n                 node.rawsource, lang, opts=opts, linenos=linenos,\n+1769:                 location=node, **highlight_args\n                 location=node, **highlight_args\n+1770:             )\n             )\n+1771:             if self.in_footnote:\n             if self.in_footnote:\n+1772:                 self.body.append(CR + r'\\sphinxSetupCodeBlockInFootnote')\n                 self.body.append(CR + r'\\sphinxSetupCodeBlockInFootnote')\n+1773:                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n+1774:                                         r'\\begin{sphinxVerbatim}')\n                                         r'\\begin{sphinxVerbatim}')\n+1775:             # if in table raise verbatim flag to avoid \"tabulary\" environment\n             # if in table raise verbatim flag to avoid \"tabulary\" environment\n+1776:             # and opt for sphinxVerbatimintable to handle caption & long lines\n             # and opt for sphinxVerbatimintable to handle caption & long lines\n+1777:             elif self.table:\n             elif self.table:\n+1778:                 self.table.has_problematic = True\n                 self.table.has_problematic = True\n+1779:                 self.table.has_verbatim = True\n                 self.table.has_verbatim = True\n+1780:                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n+1781:                                         r'\\begin{sphinxVerbatimintable}')\n                                         r'\\begin{sphinxVerbatimintable}')\n+1782:             else:\n             else:\n+1783:                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n+1784:                                         r'\\begin{sphinxVerbatim}')\n                                         r'\\begin{sphinxVerbatim}')\n+1785:             # get consistent trailer\n             # get consistent trailer\n+1786:             hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n             hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n+1787:             if self.table and not self.in_footnote:\n             if self.table and not self.in_footnote:\n+1788:                 hlcode += r'\\end{sphinxVerbatimintable}'\n                 hlcode += r'\\end{sphinxVerbatimintable}'\n+1789:             else:\n             else:\n+1790:                 hlcode += r'\\end{sphinxVerbatim}'\n                 hlcode += r'\\end{sphinxVerbatim}'\n+1791: \n \n+1792:             hllines = str(highlight_args.get('hl_lines', []))[1:-1]\n             hllines = str(highlight_args.get('hl_lines', []))[1:-1]\n+1793:             if hllines:\n             if hllines:\n+1794:                 self.body.append(CR + r'\\fvset{hllines={, %s,}}%%' % hllines)\n                 self.body.append(CR + r'\\fvset{hllines={, %s,}}%%' % hllines)\n+1795:             self.body.append(CR + hlcode + CR)\n             self.body.append(CR + hlcode + CR)\n+1796:             if hllines:\n             if hllines:\n+1797:                 self.body.append(r'\\sphinxresetverbatimhllines' + CR)\n                 self.body.append(r'\\sphinxresetverbatimhllines' + CR)\n+1798:             raise nodes.SkipNode\n             raise nodes.SkipNode\n+1799: \n \n+1800:     def depart_literal_block(self, node: Element) -> None:\n     def depart_literal_block(self, node: Element) -> None:\n+1801:         self.body.append(CR + r'\\end{sphinxalltt}' + CR)\n         self.body.append(CR + r'\\end{sphinxalltt}' + CR)\n+1802:         self.in_parsed_literal -= 1\n         self.in_parsed_literal -= 1\n+1803:     visit_doctest_block = visit_literal_block\n     visit_doctest_block = visit_literal_block\n+1804:     depart_doctest_block = depart_literal_block\n     depart_doctest_block = depart_literal_block\n+1805: \n \n+1806:     def visit_line(self, node: Element) -> None:\n     def visit_line(self, node: Element) -> None:\n+1807:         self.body.append(r'\\item[] ')\n         self.body.append(r'\\item[] ')\n+1808: \n \n+1809:     def depart_line(self, node: Element) -> None:\n     def depart_line(self, node: Element) -> None:\n+1810:         self.body.append(CR)\n         self.body.append(CR)\n+1811: \n \n+1812:     def visit_line_block(self, node: Element) -> None:\n     def visit_line_block(self, node: Element) -> None:\n+1813:         if isinstance(node.parent, nodes.line_block):\n         if isinstance(node.parent, nodes.line_block):\n+1814:             self.body.append(r'\\item[]' + CR)\n             self.body.append(r'\\item[]' + CR)\n+1815:             self.body.append(r'\\begin{DUlineblock}{\\DUlineblockindent}' + CR)\n             self.body.append(r'\\begin{DUlineblock}{\\DUlineblockindent}' + CR)\n+1816:         else:\n         else:\n+1817:             self.body.append(CR + r'\\begin{DUlineblock}{0em}' + CR)\n             self.body.append(CR + r'\\begin{DUlineblock}{0em}' + CR)\n+1818:         if self.table:\n         if self.table:\n+1819:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1820: \n \n+1821:     def depart_line_block(self, node: Element) -> None:\n     def depart_line_block(self, node: Element) -> None:\n+1822:         self.body.append(r'\\end{DUlineblock}' + CR)\n         self.body.append(r'\\end{DUlineblock}' + CR)\n+1823: \n \n+1824:     def visit_block_quote(self, node: Element) -> None:\n     def visit_block_quote(self, node: Element) -> None:\n+1825:         # If the block quote contains a single object and that object\n         # If the block quote contains a single object and that object\n+1826:         # is a list, then generate a list not a block quote.\n         # is a list, then generate a list not a block quote.\n+1827:         # This lets us indent lists.\n         # This lets us indent lists.\n+1828:         done = 0\n         done = 0\n+1829:         if len(node.children) == 1:\n         if len(node.children) == 1:\n+1830:             child = node.children[0]\n             child = node.children[0]\n+1831:             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):\n             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):\n+1832:                 done = 1\n                 done = 1\n+1833:         if not done:\n         if not done:\n+1834:             self.body.append(r'\\begin{quote}' + CR)\n             self.body.append(r'\\begin{quote}' + CR)\n+1835:             if self.table:\n             if self.table:\n+1836:                 self.table.has_problematic = True\n                 self.table.has_problematic = True\n+1837: \n \n+1838:     def depart_block_quote(self, node: Element) -> None:\n     def depart_block_quote(self, node: Element) -> None:\n+1839:         done = 0\n         done = 0\n+1840:         if len(node.children) == 1:\n         if len(node.children) == 1:\n+1841:             child = node.children[0]\n             child = node.children[0]\n+1842:             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):\n             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):\n+1843:                 done = 1\n                 done = 1\n+1844:         if not done:\n         if not done:\n+1845:             self.body.append(r'\\end{quote}' + CR)\n             self.body.append(r'\\end{quote}' + CR)\n+1846: \n \n+1847:     # option node handling copied from docutils' latex writer\n     # option node handling copied from docutils' latex writer\n+1848: \n \n+1849:     def visit_option(self, node: Element) -> None:\n     def visit_option(self, node: Element) -> None:\n+1850:         if self.context[-1]:\n         if self.context[-1]:\n+1851:             # this is not the first option\n             # this is not the first option\n+1852:             self.body.append(', ')\n             self.body.append(', ')\n+1853: \n \n+1854:     def depart_option(self, node: Element) -> None:\n     def depart_option(self, node: Element) -> None:\n+1855:         # flag that the first option is done.\n         # flag that the first option is done.\n+1856:         self.context[-1] += 1\n         self.context[-1] += 1\n+1857: \n \n+1858:     def visit_option_argument(self, node: Element) -> None:\n     def visit_option_argument(self, node: Element) -> None:\n+1859:         \"\"\"The delimiter between an option and its argument.\"\"\"\n         \"\"\"The delimiter between an option and its argument.\"\"\"\n+1860:         self.body.append(node.get('delimiter', ' '))\n         self.body.append(node.get('delimiter', ' '))\n+1861: \n \n+1862:     def depart_option_argument(self, node: Element) -> None:\n     def depart_option_argument(self, node: Element) -> None:\n+1863:         pass\n         pass\n+1864: \n \n+1865:     def visit_option_group(self, node: Element) -> None:\n     def visit_option_group(self, node: Element) -> None:\n+1866:         self.body.append(r'\\item [')\n         self.body.append(r'\\item [')\n+1867:         # flag for first option\n         # flag for first option\n+1868:         self.context.append(0)\n         self.context.append(0)\n+1869: \n \n+1870:     def depart_option_group(self, node: Element) -> None:\n     def depart_option_group(self, node: Element) -> None:\n+1871:         self.context.pop()  # the flag\n         self.context.pop()  # the flag\n+1872:         self.body.append('] ')\n         self.body.append('] ')\n+1873: \n \n+1874:     def visit_option_list(self, node: Element) -> None:\n     def visit_option_list(self, node: Element) -> None:\n+1875:         self.body.append(r'\\begin{optionlist}{3cm}' + CR)\n         self.body.append(r'\\begin{optionlist}{3cm}' + CR)\n+1876:         if self.table:\n         if self.table:\n+1877:             self.table.has_problematic = True\n             self.table.has_problematic = True\n+1878: \n \n+1879:     def depart_option_list(self, node: Element) -> None:\n     def depart_option_list(self, node: Element) -> None:\n+1880:         self.body.append(r'\\end{optionlist}' + CR)\n         self.body.append(r'\\end{optionlist}' + CR)\n+1881: \n \n+1882:     def visit_option_list_item(self, node: Element) -> None:\n     def visit_option_list_item(self, node: Element) -> None:\n+1883:         pass\n         pass\n+1884: \n \n+1885:     def depart_option_list_item(self, node: Element) -> None:\n     def depart_option_list_item(self, node: Element) -> None:\n+1886:         pass\n         pass\n+1887: \n \n+1888:     def visit_option_string(self, node: Element) -> None:\n     def visit_option_string(self, node: Element) -> None:\n+1889:         ostring = node.astext()\n         ostring = node.astext()\n+1890:         self.body.append(self.encode(ostring))\n         self.body.append(self.encode(ostring))\n+1891:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1892: \n \n+1893:     def visit_description(self, node: Element) -> None:\n     def visit_description(self, node: Element) -> None:\n+1894:         self.body.append(' ')\n         self.body.append(' ')\n+1895: \n \n+1896:     def depart_description(self, node: Element) -> None:\n     def depart_description(self, node: Element) -> None:\n+1897:         pass\n         pass\n+1898: \n \n+1899:     def visit_superscript(self, node: Element) -> None:\n     def visit_superscript(self, node: Element) -> None:\n+1900:         self.body.append(r'$^{\\text{')\n         self.body.append(r'$^{\\text{')\n+1901: \n \n+1902:     def depart_superscript(self, node: Element) -> None:\n     def depart_superscript(self, node: Element) -> None:\n+1903:         self.body.append('}}$')\n         self.body.append('}}$')\n+1904: \n \n+1905:     def visit_subscript(self, node: Element) -> None:\n     def visit_subscript(self, node: Element) -> None:\n+1906:         self.body.append(r'$_{\\text{')\n         self.body.append(r'$_{\\text{')\n+1907: \n \n+1908:     def depart_subscript(self, node: Element) -> None:\n     def depart_subscript(self, node: Element) -> None:\n+1909:         self.body.append('}}$')\n         self.body.append('}}$')\n+1910: \n \n+1911:     def visit_inline(self, node: Element) -> None:\n     def visit_inline(self, node: Element) -> None:\n+1912:         classes = node.get('classes', [])\n         classes = node.get('classes', [])\n+1913:         if classes in [['menuselection']]:\n         if classes in [['menuselection']]:\n+1914:             self.body.append(r'\\sphinxmenuselection{')\n             self.body.append(r'\\sphinxmenuselection{')\n+1915:             self.context.append('}')\n             self.context.append('}')\n+1916:         elif classes in [['guilabel']]:\n         elif classes in [['guilabel']]:\n+1917:             self.body.append(r'\\sphinxguilabel{')\n             self.body.append(r'\\sphinxguilabel{')\n+1918:             self.context.append('}')\n             self.context.append('}')\n+1919:         elif classes in [['accelerator']]:\n         elif classes in [['accelerator']]:\n+1920:             self.body.append(r'\\sphinxaccelerator{')\n             self.body.append(r'\\sphinxaccelerator{')\n+1921:             self.context.append('}')\n             self.context.append('}')\n+1922:         elif classes and not self.in_title:\n         elif classes and not self.in_title:\n+1923:             self.body.append(r'\\DUrole{%s}{' % ','.join(classes))\n             self.body.append(r'\\DUrole{%s}{' % ','.join(classes))\n+1924:             self.context.append('}')\n             self.context.append('}')\n+1925:         else:\n         else:\n+1926:             self.context.append('')\n             self.context.append('')\n+1927: \n \n+1928:     def depart_inline(self, node: Element) -> None:\n     def depart_inline(self, node: Element) -> None:\n+1929:         self.body.append(self.context.pop())\n         self.body.append(self.context.pop())\n+1930: \n \n+1931:     def visit_generated(self, node: Element) -> None:\n     def visit_generated(self, node: Element) -> None:\n+1932:         pass\n         pass\n+1933: \n \n+1934:     def depart_generated(self, node: Element) -> None:\n     def depart_generated(self, node: Element) -> None:\n+1935:         pass\n         pass\n+1936: \n \n+1937:     def visit_compound(self, node: Element) -> None:\n     def visit_compound(self, node: Element) -> None:\n+1938:         pass\n         pass\n+1939: \n \n+1940:     def depart_compound(self, node: Element) -> None:\n     def depart_compound(self, node: Element) -> None:\n+1941:         pass\n         pass\n+1942: \n \n+1943:     def visit_container(self, node: Element) -> None:\n     def visit_container(self, node: Element) -> None:\n+1944:         classes = node.get('classes', [])\n         classes = node.get('classes', [])\n+1945:         for c in classes:\n         for c in classes:\n+1946:             self.body.append('\\n\\\\begin{sphinxuseclass}{%s}' % c)\n             self.body.append('\\n\\\\begin{sphinxuseclass}{%s}' % c)\n+1947: \n \n+1948:     def depart_container(self, node: Element) -> None:\n     def depart_container(self, node: Element) -> None:\n+1949:         classes = node.get('classes', [])\n         classes = node.get('classes', [])\n+1950:         for _c in classes:\n         for _c in classes:\n+1951:             self.body.append('\\n\\\\end{sphinxuseclass}')\n             self.body.append('\\n\\\\end{sphinxuseclass}')\n+1952: \n \n+1953:     def visit_decoration(self, node: Element) -> None:\n     def visit_decoration(self, node: Element) -> None:\n+1954:         pass\n         pass\n+1955: \n \n+1956:     def depart_decoration(self, node: Element) -> None:\n     def depart_decoration(self, node: Element) -> None:\n+1957:         pass\n         pass\n+1958: \n \n+1959:     # docutils-generated elements that we don't support\n     # docutils-generated elements that we don't support\n+1960: \n \n+1961:     def visit_header(self, node: Element) -> None:\n     def visit_header(self, node: Element) -> None:\n+1962:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1963: \n \n+1964:     def visit_footer(self, node: Element) -> None:\n     def visit_footer(self, node: Element) -> None:\n+1965:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1966: \n \n+1967:     def visit_docinfo(self, node: Element) -> None:\n     def visit_docinfo(self, node: Element) -> None:\n+1968:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1969: \n \n+1970:     # text handling\n     # text handling\n+1971: \n \n+1972:     def encode(self, text: str) -> str:\n     def encode(self, text: str) -> str:\n+1973:         text = self.escape(text)\n         text = self.escape(text)\n+1974:         if self.literal_whitespace:\n         if self.literal_whitespace:\n+1975:             # Insert a blank before the newline, to avoid\n             # Insert a blank before the newline, to avoid\n+1976:             # ! LaTeX Error: There's no line here to end.\n             # ! LaTeX Error: There's no line here to end.\n+1977:             text = text.replace(CR, r'~\\\\' + CR).replace(' ', '~')\n             text = text.replace(CR, r'~\\\\' + CR).replace(' ', '~')\n+1978:         return text\n         return text\n+1979: \n \n+1980:     def encode_uri(self, text: str) -> str:\n     def encode_uri(self, text: str) -> str:\n+1981:         # TODO: it is probably wrong that this uses texescape.escape()\n         # TODO: it is probably wrong that this uses texescape.escape()\n+1982:         #       this must be checked against hyperref package exact dealings\n         #       this must be checked against hyperref package exact dealings\n+1983:         #       mainly, %, #, {, } and \\ need escaping via a \\ escape\n         #       mainly, %, #, {, } and \\ need escaping via a \\ escape\n+1984:         # in \\href, the tilde is allowed and must be represented literally\n         # in \\href, the tilde is allowed and must be represented literally\n+1985:         return self.encode(text).replace(r'\\textasciitilde{}', '~').\\\n         return self.encode(text).replace(r'\\textasciitilde{}', '~').\\\n+1986:             replace(r'\\sphinxhyphen{}', '-').\\\n             replace(r'\\sphinxhyphen{}', '-').\\\n+1987:             replace(r'\\textquotesingle{}', \"'\")\n             replace(r'\\textquotesingle{}', \"'\")\n+1988: \n \n+1989:     def visit_Text(self, node: Text) -> None:\n     def visit_Text(self, node: Text) -> None:\n+1990:         text = self.encode(node.astext())\n         text = self.encode(node.astext())\n+1991:         self.body.append(text)\n         self.body.append(text)\n+1992: \n \n+1993:     def depart_Text(self, node: Text) -> None:\n     def depart_Text(self, node: Text) -> None:\n+1994:         pass\n         pass\n+1995: \n \n+1996:     def visit_comment(self, node: Element) -> None:\n     def visit_comment(self, node: Element) -> None:\n+1997:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+1998: \n \n+1999:     def visit_meta(self, node: Element) -> None:\n     def visit_meta(self, node: Element) -> None:\n+2000:         # only valid for HTML\n         # only valid for HTML\n+2001:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+2002: \n \n+2003:     def visit_system_message(self, node: Element) -> None:\n     def visit_system_message(self, node: Element) -> None:\n+2004:         pass\n         pass\n+2005: \n \n+2006:     def depart_system_message(self, node: Element) -> None:\n     def depart_system_message(self, node: Element) -> None:\n+2007:         self.body.append(CR)\n         self.body.append(CR)\n+2008: \n \n+2009:     def visit_math(self, node: Element) -> None:\n     def visit_math(self, node: Element) -> None:\n+2010:         if self.in_title:\n         if self.in_title:\n+2011:             self.body.append(r'\\protect\\(%s\\protect\\)' % node.astext())\n             self.body.append(r'\\protect\\(%s\\protect\\)' % node.astext())\n+2012:         else:\n         else:\n+2013:             self.body.append(r'\\(%s\\)' % node.astext())\n             self.body.append(r'\\(%s\\)' % node.astext())\n+2014:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+2015: \n \n+2016:     def visit_math_block(self, node: Element) -> None:\n     def visit_math_block(self, node: Element) -> None:\n+2017:         if node.get('label'):\n         if node.get('label'):\n+2018:             label = \"equation:%s:%s\" % (node['docname'], node['label'])\n             label = \"equation:%s:%s\" % (node['docname'], node['label'])\n+2019:         else:\n         else:\n+2020:             label = None\n             label = None\n+2021: \n \n+2022:         if node.get('nowrap'):\n         if node.get('nowrap'):\n+2023:             if label:\n             if label:\n+2024:                 self.body.append(r'\\label{%s}' % label)\n                 self.body.append(r'\\label{%s}' % label)\n+2025:             self.body.append(node.astext())\n             self.body.append(node.astext())\n+2026:         else:\n         else:\n+2027:             from sphinx.util.math import wrap_displaymath\n             from sphinx.util.math import wrap_displaymath\n+2028:             self.body.append(wrap_displaymath(node.astext(), label,\n             self.body.append(wrap_displaymath(node.astext(), label,\n+2029:                                               self.config.math_number_all))\n                                               self.config.math_number_all))\n+2030:         raise nodes.SkipNode\n         raise nodes.SkipNode\n+2031: \n \n+2032:     def visit_math_reference(self, node: Element) -> None:\n     def visit_math_reference(self, node: Element) -> None:\n+2033:         label = \"equation:%s:%s\" % (node['docname'], node['target'])\n         label = \"equation:%s:%s\" % (node['docname'], node['target'])\n+2034:         eqref_format = self.config.math_eqref_format\n         eqref_format = self.config.math_eqref_format\n+2035:         if eqref_format:\n         if eqref_format:\n+2036:             try:\n             try:\n+2037:                 ref = r'\\ref{%s}' % label\n                 ref = r'\\ref{%s}' % label\n+2038:                 self.body.append(eqref_format.format(number=ref))\n                 self.body.append(eqref_format.format(number=ref))\n+2039:             except KeyError as exc:\n             except KeyError as exc:\n+2040:                 logger.warning(__('Invalid math_eqref_format: %r'), exc,\n                 logger.warning(__('Invalid math_eqref_format: %r'), exc,\n+2041:                                location=node)\n                                location=node)\n+2042:                 self.body.append(r'\\eqref{%s}' % label)\n                 self.body.append(r'\\eqref{%s}' % label)\n+2043:         else:\n         else:\n+2044:             self.body.append(r'\\eqref{%s}' % label)\n             self.body.append(r'\\eqref{%s}' % label)\n+2045: \n \n+2046:     def depart_math_reference(self, node: Element) -> None:\n     def depart_math_reference(self, node: Element) -> None:\n+2047:         pass\n         pass\n+2048: \n \n+2049:     @property\n     @property\n+2050:     def docclasses(self) -> Tuple[str, str]:\n     def docclasses(self) -> Tuple[str, str]:\n+2051:         \"\"\"Prepends prefix to sphinx document classes\"\"\"\n         \"\"\"Prepends prefix to sphinx document classes\"\"\"\n+2052:         warnings.warn('LaTeXWriter.docclasses() is deprecated.',\n         warnings.warn('LaTeXWriter.docclasses() is deprecated.',\n+2053:                       RemovedInSphinx70Warning, stacklevel=2)\n                       RemovedInSphinx70Warning, stacklevel=2)\n+2054:         return ('howto', 'manual')\n         return ('howto', 'manual')\n+2055: \n \n+2056: \n \n+2057: # FIXME: Workaround to avoid circular import\n # FIXME: Workaround to avoid circular import\n+2058: # refs: https://github.com/sphinx-doc/sphinx/issues/5433\n # refs: https://github.com/sphinx-doc/sphinx/issues/5433\n+2059: from sphinx.builders.latex.nodes import ( # NOQA isort:skip\n from sphinx.builders.latex.nodes import ( # NOQA isort:skip\n+2060:     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,\n     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,\n+2061: )\n )\n"
  },
  "sphinx-doc__sphinx-10466": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10466",
    "model_patch": "diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py\nindex e8bc547b7..f3f5c5b8a 100644\n--- a/sphinx/builders/gettext.py\n+++ b/sphinx/builders/gettext.py\n@@ -32,7 +32,14 @@ class Message:\n     \"\"\"An entry of translatable message.\"\"\"\n     def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n         self.text = text\n-        self.locations = locations\n+        # remove duplicate locations but preserve order\n+        seen = set()\n+        unique_locations: List[Tuple[str, int]] = []\n+        for loc in locations:\n+            if loc not in seen:\n+                seen.add(loc)\n+                unique_locations.append(loc)\n+        self.locations = unique_locations\n         self.uuids = uuids\n \n \n"
  },
  "sphinx-doc__sphinx-10673": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10673",
    "model_patch": ""
  },
  "sphinx-doc__sphinx-11510": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-11510",
    "model_patch": ""
  },
  "sphinx-doc__sphinx-7590": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7590",
    "model_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..bc29bd32e 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -837,6 +837,13 @@ class ASTNumberLiteral(ASTLiteral):\n         txt = str(self)\n         signode.append(nodes.Text(txt, txt))\n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, text):\n+        self.text = text\n+    def __repr__(self):\n+        return '<ASTUserDefinedLiteral %s>' % self.text\n+\n+\n \n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n@@ -4682,7 +4689,15 @@ class DefinitionParser(BaseParser):\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+        # user-defined literal (UDL) support\n+        # After a literal, C++ allows a user-defined suffix: an identifier\n+        # (possibly a raw identifier). We check for an identifier right after\n+        # the literal and return it as a combined literal string so that UDLs\n+        # like 1.0m or 6.626e-34q_J are accepted.\n+        self.skip_ws()\n+        # match a UDL suffix: identifier or raw identifier\n+        if self.match(identifier_re):\n+            return ASTUserDefinedLiteral(self.definition[pos:self.pos])\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n"
  },
  "sphinx-doc__sphinx-7748": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7748",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..b09014836 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1049,11 +1049,20 @@ class DocstringSignatureMixin:\n             # no lines in docstring, no match\n             if not doclines:\n                 continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n+            # collect one or more leading signature lines in the docstring\n+            sig_lines = []\n+            rest_lines = doclines[:]\n+            while rest_lines:\n+                match = py_ext_sig_re.match(rest_lines[0])\n+                if not match:\n+                    break\n+                exmod, path, base, args, retann = match.groups()\n+                # store the original matched line (preserve as-is)\n+                sig_lines.append(rest_lines[0])\n+                # drop the matched line and continue checking following lines\n+                rest_lines = rest_lines[1:]\n+            if not sig_lines:\n                 continue\n-            exmod, path, base, args, retann = match.groups()\n             # the base name must match ours\n             valid_names = [self.objpath[-1]]  # type: ignore\n             if isinstance(self, ClassDocumenter):\n@@ -1064,9 +1073,11 @@ class DocstringSignatureMixin:\n                 continue\n             # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(rest_lines),\n                                                         tabsize=tab_width)\n-            result = args, retann\n+            # join collected signature lines with newline so multiple overloads are preserved\n+            joined_args = '\\n'.join(sig_lines)\n+            result = joined_args, retann\n             # don't look any further\n             break\n         return result\n"
  },
  "sphinx-doc__sphinx-7757": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7757",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 15f0d66e2..ec5ccffd5 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -88,6 +88,8 @@ def getargspec(func: Callable) -> Any:\n \n         if kind is Parameter.POSITIONAL_ONLY:\n             args.append(name)\n+            if param.default is not param.empty:\n+                defaults += (param.default,)  # type: ignore\n         elif kind is Parameter.POSITIONAL_OR_KEYWORD:\n             args.append(name)\n             if param.default is not param.empty:\n"
  },
  "sphinx-doc__sphinx-7985": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7985",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..315e12840 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -213,7 +213,59 @@ class CheckExternalLinksBuilder(Builder):\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # treat as local/internal link: check that the target exists in source or output\n+                # split off anchor if present\n+                target = uri\n+                anchor = None\n+                if '#' in uri:\n+                    target, anchor = uri.split('#', 1)\n+                # consider relative paths and output files\n+                srcdir = self.app.srcdir\n+                outdir = self.outdir\n+                candidates = []\n+                if target.startswith('/'):\n+                    candidates.append(path.join(srcdir, target.lstrip('/')))\n+                    candidates.append(path.join(outdir, target.lstrip('/')))\n+                else:\n+                    candidates.append(path.join(srcdir, target))\n+                    candidates.append(path.join(outdir, target))\n+                found = False\n+                for cand in candidates:\n+                    # check file existence, allow common extensions\n+                    if path.exists(cand):\n+                        found = True\n+                        break\n+                    for ext in ('.html', '.htm', '.rst', '.md'):\n+                        if path.exists(cand + ext):\n+                            found = True\n+                            break\n+                    if found:\n+                        break\n+                if not found:\n+                    return 'broken', \"local target not found\", 0\n+                # if anchor present and anchors checking enabled, try to find it in HTML\n+                if anchor and self.app.config.linkcheck_anchors:\n+                    try:\n+                        html_path = None\n+                        for cand in candidates:\n+                            pth = cand\n+                            if not path.exists(pth) and path.exists(pth + '.html'):\n+                                pth = pth + '.html'\n+                            if path.exists(pth):\n+                                html_path = pth\n+                                break\n+                        if html_path:\n+                            with open(html_path, 'r', encoding='utf-8', errors='ignore') as f:\n+                                content = f.read()\n+                            if ('id=\"%s\"' % anchor) in content or ('name=\"%s\"' % anchor) in content or ('href=\"#%s\"' % anchor) in content:\n+                                return 'working', '', 0\n+                            else:\n+                                return 'broken', \"Anchor '%s' not found\" % anchor, 0\n+                        else:\n+                            return 'working', '', 0\n+                    except Exception as err:\n+                        return 'broken', str(err), 0\n+                return 'working', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n"
  },
  "sphinx-doc__sphinx-8035": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8035",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 8c3509c3b..b984bd4ff 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -859,7 +859,7 @@ class ModuleDocumenter(Documenter):\n         'show-inheritance': bool_option, 'synopsis': identity,\n         'platform': identity, 'deprecated': bool_option,\n         'member-order': member_order_option, 'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n         'imported-members': bool_option, 'ignore-module-all': bool_option\n     }  # type: Dict[str, Callable]\n \n@@ -1279,7 +1279,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         'noindex': bool_option, 'inherited-members': inherited_members_option,\n         'show-inheritance': bool_option, 'member-order': member_order_option,\n         'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n     }  # type: Dict[str, Callable]\n \n     _signature_class = None  # type: Any\n"
  },
  "sphinx-doc__sphinx-8056": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8056",
    "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex b3daa06f1..5462d20ea 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -272,6 +272,14 @@ class GoogleDocstring:\n         fields = []\n         while not self._is_section_break():\n             _name, _type, _desc = self._consume_field(parse_type, prefer_type)\n+            # Support multiple comma-separated names sharing the same type/description\n+            if _name:\n+                # split by comma but keep names like \"x, y\" -> [\"x\",\"y\"]\n+                names = [n.strip() for n in _name.split(',') if n.strip()]\n+                if len(names) > 1:\n+                    for nm in names:\n+                        fields.append((nm, _type, _desc,))\n+                    continue\n             if _name or _type or _desc:\n                 fields.append((_name, _type, _desc,))\n         return fields\n"
  },
  "sphinx-doc__sphinx-8265": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8265",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 378174993..f18d19290 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -388,8 +388,15 @@ def object_description(object: Any) -> str:\n         except TypeError:\n             pass  # Cannot sort frozenset values, fall back to generic repr\n         else:\n-            return \"frozenset({%s})\" % \", \".join(object_description(x)\n-                                                 for x in sorted_values)\n+            return \"frozenset({%s})\" % \", \".join(object_description(x) for x in sorted_values)\n+    if isinstance(object, tuple):\n+        # Ensure tuples are represented with parentheses and with their\n+        # elements rendered via object_description to avoid losing\n+        # nested formatting in signatures.\n+        return '(%s)' % ', '.join(object_description(x) for x in object)\n+    if isinstance(object, list):\n+        # Likewise for lists.\n+        return '[%s]' % ', '.join(object_description(x) for x in object)\n     try:\n         s = repr(object)\n     except Exception as exc:\n"
  },
  "sphinx-doc__sphinx-8269": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8269",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 9b54afc7c..815841e42 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -166,6 +166,7 @@ class CheckExternalLinksBuilder(Builder):\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n+                    response.raise_for_status()\n                     found = check_anchor(response, unquote(anchor))\n \n                     if not found:\n@@ -183,6 +184,7 @@ class CheckExternalLinksBuilder(Builder):\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n                                                 auth=auth_info, **kwargs)\n                         response.raise_for_status()\n+                        response.raise_for_status()\n             except HTTPError as err:\n                 if err.response.status_code == 401:\n                     # We'll take \"Unauthorized\" as working.\n"
  },
  "sphinx-doc__sphinx-8475": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8475",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 1dc0337c3..cc68f53b5 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -172,7 +172,7 @@ class CheckExternalLinksBuilder(Builder):\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\n-                    except HTTPError:\n+                    except (HTTPError, requests.exceptions.TooManyRedirects):\n                         # retry with GET request if that fails, some servers\n                         # don't like HEAD requests.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n"
  },
  "sphinx-doc__sphinx-8548": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8548",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex ddfd2b365..656af32f4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -606,6 +606,25 @@ class Documenter:\n \n                     for i, line in enumerate(self.process_doc(docstrings)):\n                         self.add_line(line, sourcename, i)\n+                else:\n+                    # try to find attribute docs from base classes (inherited attrs)\n+                    parent_obj = getattr(self, 'parent', None)\n+                    if parent_obj is not None:\n+                        try:\n+                            bases = getattr(parent_obj, '__mro__', ())\n+                        except Exception:\n+                            bases = ()\n+                        for base in bases[1:]:\n+                            ns = getattr(base, '__qualname__', None)\n+                            if ns:\n+                                basekey = (ns, self.objpath[-1])\n+                                if basekey in attr_docs:\n+                                    no_docstring = True\n+                                    # make a copy to avoid mutating cache\n+                                    docstrings = [list(attr_docs[basekey])]\n+                                    for i, line in enumerate(self.process_doc(docstrings)):\n+                                        self.add_line(line, sourcename, i)\n+                                    break\n \n         # add content from docstrings\n         if not no_docstring:\n"
  },
  "sphinx-doc__sphinx-8551": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8551",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 79d7e4f46..053578700 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -85,9 +85,16 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n+    # If the type name is unqualified (no dot), make the xref relative to the\n+    # current context (module/class) so that resolution prefers the current\n+    # scope instead of matching any module. If the name is qualified, do not\n+    # provide py:module/py:class so it will be resolved as given.\n     if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+        if \".\" in text:\n+            kwargs = {}\n+        else:\n+            kwargs = {'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')}\n     else:\n         kwargs = {}\n \n"
  },
  "sphinx-doc__sphinx-8638": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8638",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 000e2e8d3..d502d092d 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1162,18 +1162,30 @@ class PythonDomain(Domain):\n                                    self.objects[oname].objtype in objtypes]\n         else:\n             # NOTE: searching for exact match, object type is not considered\n-            if name in self.objects:\n-                newname = name\n-            elif type == 'mod':\n+            # exact matching: prefer the most specific (module+class+name),\n+            # then class-scoped, then module-scoped, then bare name. This\n+            # avoids resolving an instance/class attribute to an unrelated\n+            # global or module-level object with the same short name.\n+            if type == 'mod':\n                 # only exact matches allowed for modules\n-                return []\n-            elif classname and classname + '.' + name in self.objects:\n-                newname = classname + '.' + name\n-            elif modname and modname + '.' + name in self.objects:\n-                newname = modname + '.' + name\n-            elif modname and classname and \\\n-                    modname + '.' + classname + '.' + name in self.objects:\n-                newname = modname + '.' + classname + '.' + name\n+                if name in self.objects:\n+                    newname = name\n+                else:\n+                    return []\n+            else:\n+                # try module + class + name first\n+                if modname and classname and \\\n+                        modname + '.' + classname + '.' + name in self.objects:\n+                    newname = modname + '.' + classname + '.' + name\n+                # then class + name (when ref is inside a class)\n+                elif classname and classname + '.' + name in self.objects:\n+                    newname = classname + '.' + name\n+                # then module + name\n+                elif modname and modname + '.' + name in self.objects:\n+                    newname = modname + '.' + name\n+                # finally bare name\n+                elif name in self.objects:\n+                    newname = name\n         if newname is not None:\n             matches.append((newname, self.objects[newname]))\n         return matches\n"
  },
  "sphinx-doc__sphinx-8721": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8721",
    "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..9ca6135af 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,9 +56,11 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+    # Skip viewcode for epub builders when disabled\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        # mark disabled to avoid generating pages later\n+        env._viewcode_viewcode_disabled_for_epub = True\n         return\n-\n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n@@ -180,6 +182,9 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n \n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    # If viewcode was disabled for epub builds, do not collect/generate module pages\n+    if getattr(env, \"_viewcode_viewcode_disabled_for_epub\", False):\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n"
  },
  "sphinx-doc__sphinx-9229": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9229",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..20db1d890 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1725,7 +1725,8 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     ) -> None:\n         if self.doc_as_attr:\n             try:\n-                more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n+                if not more_content:\n+                    more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n             except AttributeError:\n                 pass  # Invalid class object is passed.\n \n"
  },
  "sphinx-doc__sphinx-9230": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9230",
    "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex d8cb75a5f..62b8c2428 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -28,7 +28,7 @@ logger = logging.getLogger(__name__)\n \n _directive_regex = re.compile(r'\\.\\. \\S+::')\n _google_section_regex = re.compile(r'^(\\s|\\w)+:\\s*$')\n-_google_typed_arg_regex = re.compile(r'(.+?)\\(\\s*(.*[^\\s]+)\\s*\\)')\n+_google_typed_arg_regex = re.compile(r'(.+?)\\(\\s*(.+?)\\s*\\)')\n _numpy_section_regex = re.compile(r'^[=\\-`:\\'\"~^_*+#<>]{2,}\\s*$')\n _single_colon_regex = re.compile(r'(?<!:):(?!:)')\n _xref_or_code_regex = re.compile(\n@@ -1335,4 +1335,4 @@ class NumpyDocstring(GoogleDocstring):\n                 last_had_desc = False\n         lines += ['']\n \n-        return self._format_admonition('seealso', lines)\n+        return self._format_admonition('seealso', lines)\n\\ No newline at end of file\n"
  },
  "sphinx-doc__sphinx-9281": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9281",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex a415a7074..eb42301e6 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -457,6 +457,22 @@ def object_description(object: Any) -> str:\n         else:\n             return \"frozenset({%s})\" % \", \".join(object_description(x)\n                                                  for x in sorted_values)\n+    # Render Enum members in a nicer form for signatures/defaults:\n+    # prefer \"EnumClass.Member\" instead of the repr \"<EnumClass.Member: value>\"\n+    try:\n+        # isinstance(object, enum.Enum) is safe because enum is imported above\n+        if isinstance(object, enum.Enum):\n+            enum_cls = object.__class__\n+            # prefer qualified name if available\n+            qual = getattr(enum_cls, \"__qualname__\", enum_cls.__name__)\n+            module = getattr(enum_cls, \"__module__\", None)\n+            if module and module not in (\"builtins\", \"__builtin__\"):\n+                return \"%s.%s\" % (\"%s.%s\" % (module, qual), object.name)\n+            else:\n+                return \"%s.%s\" % (qual, object.name)\n+    except Exception:\n+        # fall back to generic repr on any problem\n+        pass\n     try:\n         s = repr(object)\n     except Exception as exc:\n"
  },
  "sphinx-doc__sphinx-9320": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9320",
    "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex a40a21073..e98292736 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,7 +223,7 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', allow_empty)\n         if not d['path']:\n             sys.exit(1)\n \n"
  },
  "sphinx-doc__sphinx-9367": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9367",
    "model_patch": "diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex f541ec0a9..392cc7915 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -214,6 +214,9 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n         if node.elts:\n+            # preserve trailing comma for single-element tuples: (1,) not (1)\n+            if len(node.elts) == 1:\n+                return \"(\" + self.visit(node.elts[0]) + \",)\"\n             return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n         else:\n             return \"()\"\n"
  },
  "sphinx-doc__sphinx-9461": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9461",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 23dd9e930..578f96e01 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -249,8 +249,22 @@ def isclassmethod(obj: Any) -> bool:\n     \"\"\"Check if the object is classmethod.\"\"\"\n     if isinstance(obj, classmethod):\n         return True\n+    # staticmethod should not be treated as classmethod\n+    if isinstance(obj, staticmethod):\n+        return False\n+    # bound classmethod on a class or instance\n     elif inspect.ismethod(obj) and obj.__self__ is not None and isclass(obj.__self__):\n         return True\n+    # objects that wrap a function like classmethod (e.g. classmethod(property(...)) on Py<3.10)\n+    # such wrappers sometimes expose '__func__' pointing to the underlying function.\n+    func = getattr(obj, '__func__', None)\n+    # skip bound instance methods (they are not classmethods)\n+    if func is not None and (inspect.isfunction(func) or inspect.ismethod(func)):\n+        selfobj = getattr(obj, '__self__', None)\n+        if selfobj is None or isclass(selfobj):\n+            # If it's a descriptor that behaves like a classmethod (unbound or bound to class),\n+            # consider it a classmethod.\n+            return True\n \n     return False\n \n"
  },
  "sphinx-doc__sphinx-9698": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9698",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex cd02eaad5..1a3bd60c7 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"
  }
}