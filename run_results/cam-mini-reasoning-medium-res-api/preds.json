{
  "django__django-11790": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11790",
    "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex a0cfed0995..7a5fb97bb8 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -192,6 +192,8 @@ class AuthenticationForm(forms.Form):\n         # Set the max length and label for the \"username\" field.\n         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n         self.fields['username'].max_length = self.username_field.max_length or 254\n+        if self.fields['username'].max_length is not None and not self.fields['username'].widget.is_hidden:\n+            self.fields['username'].widget.attrs.setdefault('maxlength', str(self.fields['username'].max_length))\n         if self.fields['username'].label is None:\n             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n \n\n"
  },
  "django__django-11815": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11815",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..823f733f62 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,11 +120,17 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        # If the Enum value is a lazy translation (Promise/LazyObject), serialize\n+        # by member name so migrations remain stable across translations.\n+        from django.utils.functional import LazyObject, Promise\n+        val = self.value.value\n+        if isinstance(val, (Promise, LazyObject)):\n+            name_string = repr(self.value.name)\n+            imports = {'import %s' % module}\n+            return \"%s.%s[%s]\" % (module, enum_class.__name__, name_string), imports\n         v_string, v_imports = serializer_factory(self.value.value).serialize()\n         imports = {'import %s' % module, *v_imports}\n         return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n-\n-\n class FloatSerializer(BaseSimpleSerializer):\n     def serialize(self):\n         if math.isnan(self.value) or math.isinf(self.value):\n\n"
  },
  "django__django-11848": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11848",
    "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..a5c3c589bb 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,16 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n-            else:\n-                year += 1900\n+            # Two-digit year handling per RFC 7231:\n+            # Interpret a two-digit year by comparing it to the current year.\n+            # If the parsed year appears to be more than 50 years in the future,\n+            # treat it as the most recent past year with the same last two digits.\n+            now = datetime.datetime.utcnow().year\n+            base = now - (now % 100)\n+            candidate = base + year\n+            if candidate - now > 50:\n+                candidate -= 100\n+            year = candidate\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n\n"
  },
  "django__django-11880": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11880",
    "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 03cd8af8d7..4cc3133ca0 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -200,6 +200,7 @@ class Field:\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n         result.validators = self.validators[:]\n+        result.error_messages = copy.deepcopy(self.error_messages, memo)\n         return result\n \n \ndiff --git a/repro_deepcopy.py b/repro_deepcopy.py\nnew file mode 100644\nindex 0000000000..47cf9d1d9e\n--- /dev/null\n+++ b/repro_deepcopy.py\n@@ -0,0 +1,8 @@\n+import copy\n+from django.forms import CharField\n+f = CharField()\n+f2 = copy.deepcopy(f)\n+print('before modify original:', f.error_messages.get('required'))\n+f2.error_messages['required'] = 'modified message'\n+print('after modify original:', f.error_messages.get('required'))\n+print('after modify copy    :', f2.error_messages.get('required'))\ndiff --git a/repro_deepcopy2.py b/repro_deepcopy2.py\nnew file mode 100644\nindex 0000000000..701a45b63a\n--- /dev/null\n+++ b/repro_deepcopy2.py\n@@ -0,0 +1,10 @@\n+from django.conf import settings\n+settings.configure(USE_I18N=False)\n+import copy\n+from django.forms import CharField\n+f = CharField()\n+f2 = copy.deepcopy(f)\n+print('before modify original:', f.error_messages.get('required'))\n+f2.error_messages['required'] = 'modified message'\n+print('after modify original:', f.error_messages.get('required'))\n+print('after modify copy    :', f2.error_messages.get('required'))\ndiff --git a/test_deepcopy_error_messages.py b/test_deepcopy_error_messages.py\nnew file mode 100644\nindex 0000000000..d6a68e3dca\n--- /dev/null\n+++ b/test_deepcopy_error_messages.py\n@@ -0,0 +1,19 @@\n+from django.conf import settings\n+settings.configure(USE_I18N=False)\n+from copy import deepcopy\n+from django import forms\n+from django.forms import CharField\n+class ProfileForm(forms.Form):\n+    name = forms.CharField()\n+# Two separate form instances should have independent field.error_messages\n+f1 = ProfileForm()\n+f2 = ProfileForm()\n+orig = f1.fields['name'].error_messages['required']\n+f2.fields['name'].error_messages['required'] = 'changed by f2'\n+assert f1.fields['name'].error_messages['required'] == orig\n+# Direct deepcopy of a Field should also produce independent error_messages\n+cf = CharField()\n+cf2 = deepcopy(cf)\n+cf2.error_messages['required'] = 'modified'\n+assert cf.error_messages['required'] != cf2.error_messages['required']\n+print('ALL TESTS PASSED')\n\n"
  },
  "django__django-11885": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11885",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..822a0521e1 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -309,10 +309,39 @@ class Collector:\n                         sender=model, instance=obj, using=self.using\n                     )\n \n-            # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+            # fast deletes - combine fast delete querysets by model to reduce DB roundtrips\n+            if self.fast_deletes:\n+                groups = {}\n+                for qs in self.fast_deletes:\n+                    groups.setdefault(qs.model, []).append(qs)\n+                for model, qss in groups.items():\n+                    if len(qss) == 1:\n+                        qs = qss[0]\n+                        count = qs._raw_delete(using=self.using)\n+                        deleted_counter[qs.model._meta.label] += count\n+                        continue\n+                    combined = sql.DeleteQuery(model)\n+                    combined.get_initial_alias()\n+                    combined.where = combined.where_class()\n+                    skip_all = False\n+                    for i, qs in enumerate(qss):\n+                        w = qs.query.where\n+                        if not w:\n+                            count = qs._raw_delete(using=self.using)\n+                            deleted_counter[qs.model._meta.label] += count\n+                            skip_all = True\n+                            break\n+                        if i == 0:\n+                            try:\n+                                combined.where = w.clone()\n+                            except Exception:\n+                                combined.where = w\n+                        else:\n+                            combined.where.add(w, 'OR')\n+                    if skip_all:\n+                        continue\n+                    count = combined.do_query(combined.get_meta().db_table, combined.where, using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\ndiff --git a/repro_delete.py b/repro_delete.py\nnew file mode 100644\nindex 0000000000..6b04525498\n--- /dev/null\n+++ b/repro_delete.py\n@@ -0,0 +1,36 @@\n+import os\n+from django.conf import settings\n+def main():\n+    if not settings.configured:\n+        settings.configure(\n+            DEBUG=True,\n+            DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+            INSTALLED_APPS=['reproapp'],\n+            MIDDLEWARE=[],\n+        )\n+    import django\n+    django.setup()\n+    from reproapp.models import Person, User, Entry\n+    from django.db import connection\n+    # create tables\n+    with connection.schema_editor() as editor:\n+        editor.create_model(User)\n+        editor.create_model(Person)\n+        editor.create_model(Person.friends.through)\n+        editor.create_model(Entry)\n+    # create instances\n+    u = User.objects.create()\n+    Entry.objects.create(created_by=u, updated_by=u)\n+    p1 = Person.objects.create()\n+    p2 = Person.objects.create()\n+    p1.friends.add(p2)\n+    # clear queries log\n+    connection.queries_log.clear() if hasattr(connection, 'queries_log') else None\n+    connection.queries.clear()\n+    # delete a person and a user to trigger fast deletes\n+    p1.delete()\n+    u.delete()\n+    for q in connection.queries:\n+        print(q.get('sql') or q.get('raw_sql') or q)\n+if __name__ == '__main__':\n+    main()\ndiff --git a/repro_delete2.py b/repro_delete2.py\nnew file mode 100644\nindex 0000000000..12fee57f11\n--- /dev/null\n+++ b/repro_delete2.py\n@@ -0,0 +1,39 @@\n+from django.conf import settings\n+def main():\n+    if not settings.configured:\n+        settings.configure(\n+            DEBUG=True,\n+            DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+            INSTALLED_APPS=['reproapp'],\n+            MIDDLEWARE=[],\n+        )\n+    import django\n+    django.setup()\n+    from reproapp.models import Person, User, Entry\n+    from django.db import connection\n+    with connection.schema_editor() as editor:\n+        existing = connection.introspection.table_names()\n+        tables = []\n+        tables += [User._meta.db_table, Person._meta.db_table, Entry._meta.db_table]\n+        tables += [Person.friends.through._meta.db_table]\n+        for t in tables:\n+            try:\n+                editor.execute('DROP TABLE IF EXISTS \"%s\"' % t)\n+            except Exception:\n+                pass\n+        editor.create_model(User)\n+        editor.create_model(Person)\n+        editor.create_model(Person.friends.through)\n+        editor.create_model(Entry)\n+    u = User.objects.create()\n+    Entry.objects.create(created_by=u, updated_by=u)\n+    p1 = Person.objects.create()\n+    p2 = Person.objects.create()\n+    p1.friends.add(p2)\n+    connection.queries.clear()\n+    p1.delete()\n+    u.delete()\n+    for q in connection.queries:\n+        print(q.get('sql') or q.get('raw_sql') or q)\n+if __name__ == '__main__':\n+    main()\ndiff --git a/reproapp/__init__.py b/reproapp/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/reproapp/models.py b/reproapp/models.py\nnew file mode 100644\nindex 0000000000..935a5ea700\n--- /dev/null\n+++ b/reproapp/models.py\n@@ -0,0 +1,8 @@\n+from django.db import models\n+class Person(models.Model):\n+    friends = models.ManyToManyField('self')\n+class User(models.Model):\n+    pass\n+class Entry(models.Model):\n+    created_by = models.ForeignKey(User, related_name='+', on_delete=models.CASCADE)\n+    updated_by = models.ForeignKey(User, related_name='+', on_delete=models.CASCADE)\n\n"
  },
  "django__django-11951": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11951",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 794e0faae7..92349cd0c5 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1209,7 +1209,8 @@ class QuerySet:\n         if ignore_conflicts and not connections[self.db].features.supports_ignore_conflicts:\n             raise NotSupportedError('This database backend does not support ignoring conflicts.')\n         ops = connections[self.db].ops\n-        batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))\n+        max_batch_size = max(ops.bulk_batch_size(fields, objs), 1)\n+        batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n         inserted_rows = []\n         bulk_return = connections[self.db].features.can_return_rows_from_bulk_insert\n         for item in [objs[i:i + batch_size] for i in range(0, len(objs), batch_size)]:\ndiff --git a/django/db/models/query.py.bak b/django/db/models/query.py.bak\nnew file mode 100644\nindex 0000000000..794e0faae7\n--- /dev/null\n+++ b/django/db/models/query.py.bak\n@@ -0,0 +1,1922 @@\n+\"\"\"\n+The main QuerySet implementation. This provides the public API for the ORM.\n+\"\"\"\n+\n+import copy\n+import operator\n+import warnings\n+from collections import namedtuple\n+from functools import lru_cache\n+from itertools import chain\n+\n+from django.conf import settings\n+from django.core import exceptions\n+from django.db import (\n+    DJANGO_VERSION_PICKLE_KEY, IntegrityError, connections, router,\n+    transaction,\n+)\n+from django.db.models import DateField, DateTimeField, sql\n+from django.db.models.constants import LOOKUP_SEP\n+from django.db.models.deletion import Collector\n+from django.db.models.expressions import Case, Expression, F, Value, When\n+from django.db.models.fields import AutoField\n+from django.db.models.functions import Cast, Trunc\n+from django.db.models.query_utils import FilteredRelation, InvalidQuery, Q\n+from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE\n+from django.db.utils import NotSupportedError\n+from django.utils import timezone\n+from django.utils.functional import cached_property, partition\n+from django.utils.version import get_version\n+\n+# The maximum number of results to fetch in a get() query.\n+MAX_GET_RESULTS = 21\n+\n+# The maximum number of items to display in a QuerySet.__repr__\n+REPR_OUTPUT_SIZE = 20\n+\n+\n+class BaseIterable:\n+    def __init__(self, queryset, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n+        self.queryset = queryset\n+        self.chunked_fetch = chunked_fetch\n+        self.chunk_size = chunk_size\n+\n+\n+class ModelIterable(BaseIterable):\n+    \"\"\"Iterable that yields a model instance for each row.\"\"\"\n+\n+    def __iter__(self):\n+        queryset = self.queryset\n+        db = queryset.db\n+        compiler = queryset.query.get_compiler(using=db)\n+        # Execute the query. This will also fill compiler.select, klass_info,\n+        # and annotations.\n+        results = compiler.execute_sql(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n+        select, klass_info, annotation_col_map = (compiler.select, compiler.klass_info,\n+                                                  compiler.annotation_col_map)\n+        model_cls = klass_info['model']\n+        select_fields = klass_info['select_fields']\n+        model_fields_start, model_fields_end = select_fields[0], select_fields[-1] + 1\n+        init_list = [f[0].target.attname\n+                     for f in select[model_fields_start:model_fields_end]]\n+        related_populators = get_related_populators(klass_info, select, db)\n+        known_related_objects = [\n+            (field, related_objs, operator.attrgetter(*[\n+                field.attname\n+                if from_field == 'self' else\n+                queryset.model._meta.get_field(from_field).attname\n+                for from_field in field.from_fields\n+            ])) for field, related_objs in queryset._known_related_objects.items()\n+        ]\n+        for row in compiler.results_iter(results):\n+            obj = model_cls.from_db(db, init_list, row[model_fields_start:model_fields_end])\n+            for rel_populator in related_populators:\n+                rel_populator.populate(row, obj)\n+            if annotation_col_map:\n+                for attr_name, col_pos in annotation_col_map.items():\n+                    setattr(obj, attr_name, row[col_pos])\n+\n+            # Add the known related objects to the model.\n+            for field, rel_objs, rel_getter in known_related_objects:\n+                # Avoid overwriting objects loaded by, e.g., select_related().\n+                if field.is_cached(obj):\n+                    continue\n+                rel_obj_id = rel_getter(obj)\n+                try:\n+                    rel_obj = rel_objs[rel_obj_id]\n+                except KeyError:\n+                    pass  # May happen in qs1 | qs2 scenarios.\n+                else:\n+                    setattr(obj, field.name, rel_obj)\n+\n+            yield obj\n+\n+\n+class ValuesIterable(BaseIterable):\n+    \"\"\"\n+    Iterable returned by QuerySet.values() that yields a dict for each row.\n+    \"\"\"\n+\n+    def __iter__(self):\n+        queryset = self.queryset\n+        query = queryset.query\n+        compiler = query.get_compiler(queryset.db)\n+\n+        # extra(select=...) cols are always at the start of the row.\n+        names = [\n+            *query.extra_select,\n+            *query.values_select,\n+            *query.annotation_select,\n+        ]\n+        indexes = range(len(names))\n+        for row in compiler.results_iter(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size):\n+            yield {names[i]: row[i] for i in indexes}\n+\n+\n+class ValuesListIterable(BaseIterable):\n+    \"\"\"\n+    Iterable returned by QuerySet.values_list(flat=False) that yields a tuple\n+    for each row.\n+    \"\"\"\n+\n+    def __iter__(self):\n+        queryset = self.queryset\n+        query = queryset.query\n+        compiler = query.get_compiler(queryset.db)\n+\n+        if queryset._fields:\n+            # extra(select=...) cols are always at the start of the row.\n+            names = [\n+                *query.extra_select,\n+                *query.values_select,\n+                *query.annotation_select,\n+            ]\n+            fields = [*queryset._fields, *(f for f in query.annotation_select if f not in queryset._fields)]\n+            if fields != names:\n+                # Reorder according to fields.\n+                index_map = {name: idx for idx, name in enumerate(names)}\n+                rowfactory = operator.itemgetter(*[index_map[f] for f in fields])\n+                return map(\n+                    rowfactory,\n+                    compiler.results_iter(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n+                )\n+        return compiler.results_iter(tuple_expected=True, chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n+\n+\n+class NamedValuesListIterable(ValuesListIterable):\n+    \"\"\"\n+    Iterable returned by QuerySet.values_list(named=True) that yields a\n+    namedtuple for each row.\n+    \"\"\"\n+\n+    @staticmethod\n+    @lru_cache()\n+    def create_namedtuple_class(*names):\n+        # Cache namedtuple() with @lru_cache() since it's too slow to be\n+        # called for every QuerySet evaluation.\n+        return namedtuple('Row', names)\n+\n+    def __iter__(self):\n+        queryset = self.queryset\n+        if queryset._fields:\n+            names = queryset._fields\n+        else:\n+            query = queryset.query\n+            names = [*query.extra_select, *query.values_select, *query.annotation_select]\n+        tuple_class = self.create_namedtuple_class(*names)\n+        new = tuple.__new__\n+        for row in super().__iter__():\n+            yield new(tuple_class, row)\n+\n+\n+class FlatValuesListIterable(BaseIterable):\n+    \"\"\"\n+    Iterable returned by QuerySet.values_list(flat=True) that yields single\n+    values.\n+    \"\"\"\n+\n+    def __iter__(self):\n+        queryset = self.queryset\n+        compiler = queryset.query.get_compiler(queryset.db)\n+        for row in compiler.results_iter(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size):\n+            yield row[0]\n+\n+\n+class QuerySet:\n+    \"\"\"Represent a lazy database lookup for a set of objects.\"\"\"\n+\n+    def __init__(self, model=None, query=None, using=None, hints=None):\n+        self.model = model\n+        self._db = using\n+        self._hints = hints or {}\n+        self.query = query or sql.Query(self.model)\n+        self._result_cache = None\n+        self._sticky_filter = False\n+        self._for_write = False\n+        self._prefetch_related_lookups = ()\n+        self._prefetch_done = False\n+        self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\n+        self._iterable_class = ModelIterable\n+        self._fields = None\n+\n+    def as_manager(cls):\n+        # Address the circular dependency between `Queryset` and `Manager`.\n+        from django.db.models.manager import Manager\n+        manager = Manager.from_queryset(cls)()\n+        manager._built_with_as_manager = True\n+        return manager\n+    as_manager.queryset_only = True\n+    as_manager = classmethod(as_manager)\n+\n+    ########################\n+    # PYTHON MAGIC METHODS #\n+    ########################\n+\n+    def __deepcopy__(self, memo):\n+        \"\"\"Don't populate the QuerySet's cache.\"\"\"\n+        obj = self.__class__()\n+        for k, v in self.__dict__.items():\n+            if k == '_result_cache':\n+                obj.__dict__[k] = None\n+            else:\n+                obj.__dict__[k] = copy.deepcopy(v, memo)\n+        return obj\n+\n+    def __getstate__(self):\n+        # Force the cache to be fully populated.\n+        self._fetch_all()\n+        return {**self.__dict__, DJANGO_VERSION_PICKLE_KEY: get_version()}\n+\n+    def __setstate__(self, state):\n+        msg = None\n+        pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)\n+        if pickled_version:\n+            current_version = get_version()\n+            if current_version != pickled_version:\n+                msg = (\n+                    \"Pickled queryset instance's Django version %s does not \"\n+                    \"match the current version %s.\" % (pickled_version, current_version)\n+                )\n+        else:\n+            msg = \"Pickled queryset instance's Django version is not specified.\"\n+\n+        if msg:\n+            warnings.warn(msg, RuntimeWarning, stacklevel=2)\n+\n+        self.__dict__.update(state)\n+\n+    def __repr__(self):\n+        data = list(self[:REPR_OUTPUT_SIZE + 1])\n+        if len(data) > REPR_OUTPUT_SIZE:\n+            data[-1] = \"...(remaining elements truncated)...\"\n+        return '<%s %r>' % (self.__class__.__name__, data)\n+\n+    def __len__(self):\n+        self._fetch_all()\n+        return len(self._result_cache)\n+\n+    def __iter__(self):\n+        \"\"\"\n+        The queryset iterator protocol uses three nested iterators in the\n+        default case:\n+            1. sql.compiler.execute_sql()\n+               - Returns 100 rows at time (constants.GET_ITERATOR_CHUNK_SIZE)\n+                 using cursor.fetchmany(). This part is responsible for\n+                 doing some column masking, and returning the rows in chunks.\n+            2. sql.compiler.results_iter()\n+               - Returns one row at time. At this point the rows are still just\n+                 tuples. In some cases the return values are converted to\n+                 Python values at this location.\n+            3. self.iterator()\n+               - Responsible for turning the rows into model objects.\n+        \"\"\"\n+        self._fetch_all()\n+        return iter(self._result_cache)\n+\n+    def __bool__(self):\n+        self._fetch_all()\n+        return bool(self._result_cache)\n+\n+    def __getitem__(self, k):\n+        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n+        if not isinstance(k, (int, slice)):\n+            raise TypeError(\n+                'QuerySet indices must be integers or slices, not %s.'\n+                % type(k).__name__\n+            )\n+        assert ((not isinstance(k, slice) and (k >= 0)) or\n+                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n+                 (k.stop is None or k.stop >= 0))), \\\n+            \"Negative indexing is not supported.\"\n+\n+        if self._result_cache is not None:\n+            return self._result_cache[k]\n+\n+        if isinstance(k, slice):\n+            qs = self._chain()\n+            if k.start is not None:\n+                start = int(k.start)\n+            else:\n+                start = None\n+            if k.stop is not None:\n+                stop = int(k.stop)\n+            else:\n+                stop = None\n+            qs.query.set_limits(start, stop)\n+            return list(qs)[::k.step] if k.step else qs\n+\n+        qs = self._chain()\n+        qs.query.set_limits(k, k + 1)\n+        qs._fetch_all()\n+        return qs._result_cache[0]\n+\n+    def __and__(self, other):\n+        self._merge_sanity_check(other)\n+        if isinstance(other, EmptyQuerySet):\n+            return other\n+        if isinstance(self, EmptyQuerySet):\n+            return self\n+        combined = self._chain()\n+        combined._merge_known_related_objects(other)\n+        combined.query.combine(other.query, sql.AND)\n+        return combined\n+\n+    def __or__(self, other):\n+        self._merge_sanity_check(other)\n+        if isinstance(self, EmptyQuerySet):\n+            return other\n+        if isinstance(other, EmptyQuerySet):\n+            return self\n+        query = self if self.query.can_filter() else self.model._base_manager.filter(pk__in=self.values('pk'))\n+        combined = query._chain()\n+        combined._merge_known_related_objects(other)\n+        if not other.query.can_filter():\n+            other = other.model._base_manager.filter(pk__in=other.values('pk'))\n+        combined.query.combine(other.query, sql.OR)\n+        return combined\n+\n+    ####################################\n+    # METHODS THAT DO DATABASE QUERIES #\n+    ####################################\n+\n+    def _iterator(self, use_chunked_fetch, chunk_size):\n+        yield from self._iterable_class(self, chunked_fetch=use_chunked_fetch, chunk_size=chunk_size)\n+\n+    def iterator(self, chunk_size=2000):\n+        \"\"\"\n+        An iterator over the results from applying this QuerySet to the\n+        database.\n+        \"\"\"\n+        if chunk_size <= 0:\n+            raise ValueError('Chunk size must be strictly positive.')\n+        use_chunked_fetch = not connections[self.db].settings_dict.get('DISABLE_SERVER_SIDE_CURSORS')\n+        return self._iterator(use_chunked_fetch, chunk_size)\n+\n+    def aggregate(self, *args, **kwargs):\n+        \"\"\"\n+        Return a dictionary containing the calculations (aggregation)\n+        over the current queryset.\n+\n+        If args is present the expression is passed as a kwarg using\n+        the Aggregate object's default alias.\n+        \"\"\"\n+        if self.query.distinct_fields:\n+            raise NotImplementedError(\"aggregate() + distinct(fields) not implemented.\")\n+        self._validate_values_are_expressions((*args, *kwargs.values()), method_name='aggregate')\n+        for arg in args:\n+            # The default_alias property raises TypeError if default_alias\n+            # can't be set automatically or AttributeError if it isn't an\n+            # attribute.\n+            try:\n+                arg.default_alias\n+            except (AttributeError, TypeError):\n+                raise TypeError(\"Complex aggregates require an alias\")\n+            kwargs[arg.default_alias] = arg\n+\n+        query = self.query.chain()\n+        for (alias, aggregate_expr) in kwargs.items():\n+            query.add_annotation(aggregate_expr, alias, is_summary=True)\n+            if not query.annotations[alias].contains_aggregate:\n+                raise TypeError(\"%s is not an aggregate expression\" % alias)\n+        return query.get_aggregation(self.db, kwargs)\n+\n+    def count(self):\n+        \"\"\"\n+        Perform a SELECT COUNT() and return the number of records as an\n+        integer.\n+\n+        If the QuerySet is already fully cached, return the length of the\n+        cached results set to avoid multiple SELECT COUNT(*) calls.\n+        \"\"\"\n+        if self._result_cache is not None:\n+            return len(self._result_cache)\n+\n+        return self.query.get_count(using=self.db)\n+\n+    def get(self, *args, **kwargs):\n+        \"\"\"\n+        Perform the query and return a single object matching the given\n+        keyword arguments.\n+        \"\"\"\n+        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)\n+        if self.query.can_filter() and not self.query.distinct_fields:\n+            clone = clone.order_by()\n+        limit = None\n+        if not clone.query.select_for_update or connections[clone.db].features.supports_select_for_update_with_limit:\n+            limit = MAX_GET_RESULTS\n+            clone.query.set_limits(high=limit)\n+        num = len(clone)\n+        if num == 1:\n+            return clone._result_cache[0]\n+        if not num:\n+            raise self.model.DoesNotExist(\n+                \"%s matching query does not exist.\" %\n+                self.model._meta.object_name\n+            )\n+        raise self.model.MultipleObjectsReturned(\n+            'get() returned more than one %s -- it returned %s!' % (\n+                self.model._meta.object_name,\n+                num if not limit or num < limit else 'more than %s' % (limit - 1),\n+            )\n+        )\n+\n+    def create(self, **kwargs):\n+        \"\"\"\n+        Create a new object with the given kwargs, saving it to the database\n+        and returning the created object.\n+        \"\"\"\n+        obj = self.model(**kwargs)\n+        self._for_write = True\n+        obj.save(force_insert=True, using=self.db)\n+        return obj\n+\n+    def _populate_pk_values(self, objs):\n+        for obj in objs:\n+            if obj.pk is None:\n+                obj.pk = obj._meta.pk.get_pk_value_on_save(obj)\n+\n+    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n+        \"\"\"\n+        Insert each of the instances into the database. Do *not* call\n+        save() on each of the instances, do not send any pre/post_save\n+        signals, and do not set the primary key attribute if it is an\n+        autoincrement field (except if features.can_return_rows_from_bulk_insert=True).\n+        Multi-table models are not supported.\n+        \"\"\"\n+        # When you bulk insert you don't get the primary keys back (if it's an\n+        # autoincrement, except if can_return_rows_from_bulk_insert=True), so\n+        # you can't insert into the child tables which references this. There\n+        # are two workarounds:\n+        # 1) This could be implemented if you didn't have an autoincrement pk\n+        # 2) You could do it by doing O(n) normal inserts into the parent\n+        #    tables to get the primary keys back and then doing a single bulk\n+        #    insert into the childmost table.\n+        # We currently set the primary keys on the objects when using\n+        # PostgreSQL via the RETURNING ID clause. It should be possible for\n+        # Oracle as well, but the semantics for extracting the primary keys is\n+        # trickier so it's not done yet.\n+        assert batch_size is None or batch_size > 0\n+        # Check that the parents share the same concrete model with the our\n+        # model to detect the inheritance pattern ConcreteGrandParent ->\n+        # MultiTableParent -> ProxyChild. Simply checking self.model._meta.proxy\n+        # would not identify that case as involving multiple tables.\n+        for parent in self.model._meta.get_parent_list():\n+            if parent._meta.concrete_model is not self.model._meta.concrete_model:\n+                raise ValueError(\"Can't bulk create a multi-table inherited model\")\n+        if not objs:\n+            return objs\n+        self._for_write = True\n+        connection = connections[self.db]\n+        opts = self.model._meta\n+        fields = opts.concrete_fields\n+        objs = list(objs)\n+        self._populate_pk_values(objs)\n+        with transaction.atomic(using=self.db, savepoint=False):\n+            objs_with_pk, objs_without_pk = partition(lambda o: o.pk is None, objs)\n+            if objs_with_pk:\n+                returned_columns = self._batched_insert(\n+                    objs_with_pk, fields, batch_size, ignore_conflicts=ignore_conflicts,\n+                )\n+                for obj_with_pk, results in zip(objs_with_pk, returned_columns):\n+                    for result, field in zip(results, opts.db_returning_fields):\n+                        if field != opts.pk:\n+                            setattr(obj_with_pk, field.attname, result)\n+                for obj_with_pk in objs_with_pk:\n+                    obj_with_pk._state.adding = False\n+                    obj_with_pk._state.db = self.db\n+            if objs_without_pk:\n+                fields = [f for f in fields if not isinstance(f, AutoField)]\n+                returned_columns = self._batched_insert(\n+                    objs_without_pk, fields, batch_size, ignore_conflicts=ignore_conflicts,\n+                )\n+                if connection.features.can_return_rows_from_bulk_insert and not ignore_conflicts:\n+                    assert len(returned_columns) == len(objs_without_pk)\n+                for obj_without_pk, results in zip(objs_without_pk, returned_columns):\n+                    for result, field in zip(results, opts.db_returning_fields):\n+                        setattr(obj_without_pk, field.attname, result)\n+                    obj_without_pk._state.adding = False\n+                    obj_without_pk._state.db = self.db\n+\n+        return objs\n+\n+    def bulk_update(self, objs, fields, batch_size=None):\n+        \"\"\"\n+        Update the given fields in each of the given objects in the database.\n+        \"\"\"\n+        if batch_size is not None and batch_size < 0:\n+            raise ValueError('Batch size must be a positive integer.')\n+        if not fields:\n+            raise ValueError('Field names must be given to bulk_update().')\n+        objs = tuple(objs)\n+        if any(obj.pk is None for obj in objs):\n+            raise ValueError('All bulk_update() objects must have a primary key set.')\n+        fields = [self.model._meta.get_field(name) for name in fields]\n+        if any(not f.concrete or f.many_to_many for f in fields):\n+            raise ValueError('bulk_update() can only be used with concrete fields.')\n+        if any(f.primary_key for f in fields):\n+            raise ValueError('bulk_update() cannot be used with primary key fields.')\n+        if not objs:\n+            return\n+        # PK is used twice in the resulting update query, once in the filter\n+        # and once in the WHEN. Each field will also have one CAST.\n+        max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n+        batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n+        requires_casting = connections[self.db].features.requires_casted_case_in_updates\n+        batches = (objs[i:i + batch_size] for i in range(0, len(objs), batch_size))\n+        updates = []\n+        for batch_objs in batches:\n+            update_kwargs = {}\n+            for field in fields:\n+                when_statements = []\n+                for obj in batch_objs:\n+                    attr = getattr(obj, field.attname)\n+                    if not isinstance(attr, Expression):\n+                        attr = Value(attr, output_field=field)\n+                    when_statements.append(When(pk=obj.pk, then=attr))\n+                case_statement = Case(*when_statements, output_field=field)\n+                if requires_casting:\n+                    case_statement = Cast(case_statement, output_field=field)\n+                update_kwargs[field.attname] = case_statement\n+            updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+        with transaction.atomic(using=self.db, savepoint=False):\n+            for pks, update_kwargs in updates:\n+                self.filter(pk__in=pks).update(**update_kwargs)\n+    bulk_update.alters_data = True\n+\n+    def get_or_create(self, defaults=None, **kwargs):\n+        \"\"\"\n+        Look up an object with the given kwargs, creating one if necessary.\n+        Return a tuple of (object, created), where created is a boolean\n+        specifying whether an object was created.\n+        \"\"\"\n+        # The get() needs to be targeted at the write database in order\n+        # to avoid potential transaction consistency problems.\n+        self._for_write = True\n+        try:\n+            return self.get(**kwargs), False\n+        except self.model.DoesNotExist:\n+            params = self._extract_model_params(defaults, **kwargs)\n+            return self._create_object_from_params(kwargs, params)\n+\n+    def update_or_create(self, defaults=None, **kwargs):\n+        \"\"\"\n+        Look up an object with the given kwargs, updating one with defaults\n+        if it exists, otherwise create a new one.\n+        Return a tuple (object, created), where created is a boolean\n+        specifying whether an object was created.\n+        \"\"\"\n+        defaults = defaults or {}\n+        self._for_write = True\n+        with transaction.atomic(using=self.db):\n+            try:\n+                obj = self.select_for_update().get(**kwargs)\n+            except self.model.DoesNotExist:\n+                params = self._extract_model_params(defaults, **kwargs)\n+                # Lock the row so that a concurrent update is blocked until\n+                # after update_or_create() has performed its save.\n+                obj, created = self._create_object_from_params(kwargs, params, lock=True)\n+                if created:\n+                    return obj, created\n+            for k, v in defaults.items():\n+                setattr(obj, k, v() if callable(v) else v)\n+            obj.save(using=self.db)\n+        return obj, False\n+\n+    def _create_object_from_params(self, lookup, params, lock=False):\n+        \"\"\"\n+        Try to create an object using passed params. Used by get_or_create()\n+        and update_or_create().\n+        \"\"\"\n+        try:\n+            with transaction.atomic(using=self.db):\n+                params = {k: v() if callable(v) else v for k, v in params.items()}\n+                obj = self.create(**params)\n+            return obj, True\n+        except IntegrityError as e:\n+            try:\n+                qs = self.select_for_update() if lock else self\n+                return qs.get(**lookup), False\n+            except self.model.DoesNotExist:\n+                pass\n+            raise e\n+\n+    def _extract_model_params(self, defaults, **kwargs):\n+        \"\"\"\n+        Prepare `params` for creating a model instance based on the given\n+        kwargs; for use by get_or_create() and update_or_create().\n+        \"\"\"\n+        defaults = defaults or {}\n+        params = {k: v for k, v in kwargs.items() if LOOKUP_SEP not in k}\n+        params.update(defaults)\n+        property_names = self.model._meta._property_names\n+        invalid_params = []\n+        for param in params:\n+            try:\n+                self.model._meta.get_field(param)\n+            except exceptions.FieldDoesNotExist:\n+                # It's okay to use a model's property if it has a setter.\n+                if not (param in property_names and getattr(self.model, param).fset):\n+                    invalid_params.append(param)\n+        if invalid_params:\n+            raise exceptions.FieldError(\n+                \"Invalid field name(s) for model %s: '%s'.\" % (\n+                    self.model._meta.object_name,\n+                    \"', '\".join(sorted(invalid_params)),\n+                ))\n+        return params\n+\n+    def _earliest(self, *fields):\n+        \"\"\"\n+        Return the earliest object according to fields (if given) or by the\n+        model's Meta.get_latest_by.\n+        \"\"\"\n+        if fields:\n+            order_by = fields\n+        else:\n+            order_by = getattr(self.model._meta, 'get_latest_by')\n+            if order_by and not isinstance(order_by, (tuple, list)):\n+                order_by = (order_by,)\n+        if order_by is None:\n+            raise ValueError(\n+                \"earliest() and latest() require either fields as positional \"\n+                \"arguments or 'get_latest_by' in the model's Meta.\"\n+            )\n+\n+        assert not self.query.is_sliced, \\\n+            \"Cannot change a query once a slice has been taken.\"\n+        obj = self._chain()\n+        obj.query.set_limits(high=1)\n+        obj.query.clear_ordering(force_empty=True)\n+        obj.query.add_ordering(*order_by)\n+        return obj.get()\n+\n+    def earliest(self, *fields):\n+        return self._earliest(*fields)\n+\n+    def latest(self, *fields):\n+        return self.reverse()._earliest(*fields)\n+\n+    def first(self):\n+        \"\"\"Return the first object of a query or None if no match is found.\"\"\"\n+        for obj in (self if self.ordered else self.order_by('pk'))[:1]:\n+            return obj\n+\n+    def last(self):\n+        \"\"\"Return the last object of a query or None if no match is found.\"\"\"\n+        for obj in (self.reverse() if self.ordered else self.order_by('-pk'))[:1]:\n+            return obj\n+\n+    def in_bulk(self, id_list=None, *, field_name='pk'):\n+        \"\"\"\n+        Return a dictionary mapping each of the given IDs to the object with\n+        that ID. If `id_list` isn't provided, evaluate the entire QuerySet.\n+        \"\"\"\n+        assert not self.query.is_sliced, \\\n+            \"Cannot use 'limit' or 'offset' with in_bulk\"\n+        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n+            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+        if id_list is not None:\n+            if not id_list:\n+                return {}\n+            filter_key = '{}__in'.format(field_name)\n+            batch_size = connections[self.db].features.max_query_params\n+            id_list = tuple(id_list)\n+            # If the database has a limit on the number of query parameters\n+            # (e.g. SQLite), retrieve objects in batches if necessary.\n+            if batch_size and batch_size < len(id_list):\n+                qs = ()\n+                for offset in range(0, len(id_list), batch_size):\n+                    batch = id_list[offset:offset + batch_size]\n+                    qs += tuple(self.filter(**{filter_key: batch}).order_by())\n+            else:\n+                qs = self.filter(**{filter_key: id_list}).order_by()\n+        else:\n+            qs = self._chain()\n+        return {getattr(obj, field_name): obj for obj in qs}\n+\n+    def delete(self):\n+        \"\"\"Delete the records in the current QuerySet.\"\"\"\n+        assert not self.query.is_sliced, \\\n+            \"Cannot use 'limit' or 'offset' with delete.\"\n+\n+        if self._fields is not None:\n+            raise TypeError(\"Cannot call delete() after .values() or .values_list()\")\n+\n+        del_query = self._chain()\n+\n+        # The delete is actually 2 queries - one to find related objects,\n+        # and one to delete. Make sure that the discovery of related\n+        # objects is performed on the same database as the deletion.\n+        del_query._for_write = True\n+\n+        # Disable non-supported fields.\n+        del_query.query.select_for_update = False\n+        del_query.query.select_related = False\n+        del_query.query.clear_ordering(force_empty=True)\n+\n+        collector = Collector(using=del_query.db)\n+        collector.collect(del_query)\n+        deleted, _rows_count = collector.delete()\n+\n+        # Clear the result cache, in case this QuerySet gets reused.\n+        self._result_cache = None\n+        return deleted, _rows_count\n+\n+    delete.alters_data = True\n+    delete.queryset_only = True\n+\n+    def _raw_delete(self, using):\n+        \"\"\"\n+        Delete objects found from the given queryset in single direct SQL\n+        query. No signals are sent and there is no protection for cascades.\n+        \"\"\"\n+        return sql.DeleteQuery(self.model).delete_qs(self, using)\n+    _raw_delete.alters_data = True\n+\n+    def update(self, **kwargs):\n+        \"\"\"\n+        Update all elements in the current QuerySet, setting all the given\n+        fields to the appropriate values.\n+        \"\"\"\n+        assert not self.query.is_sliced, \\\n+            \"Cannot update a query once a slice has been taken.\"\n+        self._for_write = True\n+        query = self.query.chain(sql.UpdateQuery)\n+        query.add_update_values(kwargs)\n+        # Clear any annotations so that they won't be present in subqueries.\n+        query.annotations = {}\n+        with transaction.mark_for_rollback_on_error(using=self.db):\n+            rows = query.get_compiler(self.db).execute_sql(CURSOR)\n+        self._result_cache = None\n+        return rows\n+    update.alters_data = True\n+\n+    def _update(self, values):\n+        \"\"\"\n+        A version of update() that accepts field objects instead of field names.\n+        Used primarily for model saving and not intended for use by general\n+        code (it requires too much poking around at model internals to be\n+        useful at that level).\n+        \"\"\"\n+        assert not self.query.is_sliced, \\\n+            \"Cannot update a query once a slice has been taken.\"\n+        query = self.query.chain(sql.UpdateQuery)\n+        query.add_update_fields(values)\n+        # Clear any annotations so that they won't be present in subqueries.\n+        query.annotations = {}\n+        self._result_cache = None\n+        return query.get_compiler(self.db).execute_sql(CURSOR)\n+    _update.alters_data = True\n+    _update.queryset_only = False\n+\n+    def exists(self):\n+        if self._result_cache is None:\n+            return self.query.has_results(using=self.db)\n+        return bool(self._result_cache)\n+\n+    def _prefetch_related_objects(self):\n+        # This method can only be called once the result cache has been filled.\n+        prefetch_related_objects(self._result_cache, *self._prefetch_related_lookups)\n+        self._prefetch_done = True\n+\n+    def explain(self, *, format=None, **options):\n+        return self.query.explain(using=self.db, format=format, **options)\n+\n+    ##################################################\n+    # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #\n+    ##################################################\n+\n+    def raw(self, raw_query, params=None, translations=None, using=None):\n+        if using is None:\n+            using = self.db\n+        qs = RawQuerySet(raw_query, model=self.model, params=params, translations=translations, using=using)\n+        qs._prefetch_related_lookups = self._prefetch_related_lookups[:]\n+        return qs\n+\n+    def _values(self, *fields, **expressions):\n+        clone = self._chain()\n+        if expressions:\n+            clone = clone.annotate(**expressions)\n+        clone._fields = fields\n+        clone.query.set_values(fields)\n+        return clone\n+\n+    def values(self, *fields, **expressions):\n+        fields += tuple(expressions)\n+        clone = self._values(*fields, **expressions)\n+        clone._iterable_class = ValuesIterable\n+        return clone\n+\n+    def values_list(self, *fields, flat=False, named=False):\n+        if flat and named:\n+            raise TypeError(\"'flat' and 'named' can't be used together.\")\n+        if flat and len(fields) > 1:\n+            raise TypeError(\"'flat' is not valid when values_list is called with more than one field.\")\n+\n+        field_names = {f for f in fields if not hasattr(f, 'resolve_expression')}\n+        _fields = []\n+        expressions = {}\n+        counter = 1\n+        for field in fields:\n+            if hasattr(field, 'resolve_expression'):\n+                field_id_prefix = getattr(field, 'default_alias', field.__class__.__name__.lower())\n+                while True:\n+                    field_id = field_id_prefix + str(counter)\n+                    counter += 1\n+                    if field_id not in field_names:\n+                        break\n+                expressions[field_id] = field\n+                _fields.append(field_id)\n+            else:\n+                _fields.append(field)\n+\n+        clone = self._values(*_fields, **expressions)\n+        clone._iterable_class = (\n+            NamedValuesListIterable if named\n+            else FlatValuesListIterable if flat\n+            else ValuesListIterable\n+        )\n+        return clone\n+\n+    def dates(self, field_name, kind, order='ASC'):\n+        \"\"\"\n+        Return a list of date objects representing all available dates for\n+        the given field_name, scoped to 'kind'.\n+        \"\"\"\n+        assert kind in ('year', 'month', 'week', 'day'), \\\n+            \"'kind' must be one of 'year', 'month', 'week', or 'day'.\"\n+        assert order in ('ASC', 'DESC'), \\\n+            \"'order' must be either 'ASC' or 'DESC'.\"\n+        return self.annotate(\n+            datefield=Trunc(field_name, kind, output_field=DateField()),\n+            plain_field=F(field_name)\n+        ).values_list(\n+            'datefield', flat=True\n+        ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datefield')\n+\n+    def datetimes(self, field_name, kind, order='ASC', tzinfo=None):\n+        \"\"\"\n+        Return a list of datetime objects representing all available\n+        datetimes for the given field_name, scoped to 'kind'.\n+        \"\"\"\n+        assert kind in ('year', 'month', 'week', 'day', 'hour', 'minute', 'second'), \\\n+            \"'kind' must be one of 'year', 'month', 'week', 'day', 'hour', 'minute', or 'second'.\"\n+        assert order in ('ASC', 'DESC'), \\\n+            \"'order' must be either 'ASC' or 'DESC'.\"\n+        if settings.USE_TZ:\n+            if tzinfo is None:\n+                tzinfo = timezone.get_current_timezone()\n+        else:\n+            tzinfo = None\n+        return self.annotate(\n+            datetimefield=Trunc(field_name, kind, output_field=DateTimeField(), tzinfo=tzinfo),\n+            plain_field=F(field_name)\n+        ).values_list(\n+            'datetimefield', flat=True\n+        ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n+\n+    ##################################################################\n+    # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n+    ##################################################################\n+\n+    def all(self):\n+        \"\"\"\n+        Return a new QuerySet that is a copy of the current one. This allows a\n+        QuerySet to proxy for a model manager in some cases.\n+        \"\"\"\n+        return self._chain()\n+\n+    def filter(self, *args, **kwargs):\n+        \"\"\"\n+        Return a new QuerySet instance with the args ANDed to the existing\n+        set.\n+        \"\"\"\n+        self._not_support_combined_queries('filter')\n+        return self._filter_or_exclude(False, *args, **kwargs)\n+\n+    def exclude(self, *args, **kwargs):\n+        \"\"\"\n+        Return a new QuerySet instance with NOT (args) ANDed to the existing\n+        set.\n+        \"\"\"\n+        self._not_support_combined_queries('exclude')\n+        return self._filter_or_exclude(True, *args, **kwargs)\n+\n+    def _filter_or_exclude(self, negate, *args, **kwargs):\n+        if args or kwargs:\n+            assert not self.query.is_sliced, \\\n+                \"Cannot filter a query once a slice has been taken.\"\n+\n+        clone = self._chain()\n+        if negate:\n+            clone.query.add_q(~Q(*args, **kwargs))\n+        else:\n+            clone.query.add_q(Q(*args, **kwargs))\n+        return clone\n+\n+    def complex_filter(self, filter_obj):\n+        \"\"\"\n+        Return a new QuerySet instance with filter_obj added to the filters.\n+\n+        filter_obj can be a Q object or a dictionary of keyword lookup\n+        arguments.\n+\n+        This exists to support framework features such as 'limit_choices_to',\n+        and usually it will be more natural to use other methods.\n+        \"\"\"\n+        if isinstance(filter_obj, Q):\n+            clone = self._chain()\n+            clone.query.add_q(filter_obj)\n+            return clone\n+        else:\n+            return self._filter_or_exclude(None, **filter_obj)\n+\n+    def _combinator_query(self, combinator, *other_qs, all=False):\n+        # Clone the query to inherit the select list and everything\n+        clone = self._chain()\n+        # Clear limits and ordering so they can be reapplied\n+        clone.query.clear_ordering(True)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+\n+    def union(self, *other_qs, all=False):\n+        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+        if isinstance(self, EmptyQuerySet):\n+            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n+        return self._combinator_query('union', *other_qs, all=all)\n+\n+    def intersection(self, *other_qs):\n+        # If any query is an EmptyQuerySet, return it.\n+        if isinstance(self, EmptyQuerySet):\n+            return self\n+        for other in other_qs:\n+            if isinstance(other, EmptyQuerySet):\n+                return other\n+        return self._combinator_query('intersection', *other_qs)\n+\n+    def difference(self, *other_qs):\n+        # If the query is an EmptyQuerySet, return it.\n+        if isinstance(self, EmptyQuerySet):\n+            return self\n+        return self._combinator_query('difference', *other_qs)\n+\n+    def select_for_update(self, nowait=False, skip_locked=False, of=()):\n+        \"\"\"\n+        Return a new QuerySet instance that will select objects with a\n+        FOR UPDATE lock.\n+        \"\"\"\n+        if nowait and skip_locked:\n+            raise ValueError('The nowait option cannot be used with skip_locked.')\n+        obj = self._chain()\n+        obj._for_write = True\n+        obj.query.select_for_update = True\n+        obj.query.select_for_update_nowait = nowait\n+        obj.query.select_for_update_skip_locked = skip_locked\n+        obj.query.select_for_update_of = of\n+        return obj\n+\n+    def select_related(self, *fields):\n+        \"\"\"\n+        Return a new QuerySet instance that will select related objects.\n+\n+        If fields are specified, they must be ForeignKey fields and only those\n+        related objects are included in the selection.\n+\n+        If select_related(None) is called, clear the list.\n+        \"\"\"\n+        self._not_support_combined_queries('select_related')\n+        if self._fields is not None:\n+            raise TypeError(\"Cannot call select_related() after .values() or .values_list()\")\n+\n+        obj = self._chain()\n+        if fields == (None,):\n+            obj.query.select_related = False\n+        elif fields:\n+            obj.query.add_select_related(fields)\n+        else:\n+            obj.query.select_related = True\n+        return obj\n+\n+    def prefetch_related(self, *lookups):\n+        \"\"\"\n+        Return a new QuerySet instance that will prefetch the specified\n+        Many-To-One and Many-To-Many related objects when the QuerySet is\n+        evaluated.\n+\n+        When prefetch_related() is called more than once, append to the list of\n+        prefetch lookups. If prefetch_related(None) is called, clear the list.\n+        \"\"\"\n+        self._not_support_combined_queries('prefetch_related')\n+        clone = self._chain()\n+        if lookups == (None,):\n+            clone._prefetch_related_lookups = ()\n+        else:\n+            for lookup in lookups:\n+                if isinstance(lookup, Prefetch):\n+                    lookup = lookup.prefetch_to\n+                lookup = lookup.split(LOOKUP_SEP, 1)[0]\n+                if lookup in self.query._filtered_relations:\n+                    raise ValueError('prefetch_related() is not supported with FilteredRelation.')\n+            clone._prefetch_related_lookups = clone._prefetch_related_lookups + lookups\n+        return clone\n+\n+    def annotate(self, *args, **kwargs):\n+        \"\"\"\n+        Return a query set in which the returned objects have been annotated\n+        with extra data or aggregations.\n+        \"\"\"\n+        self._not_support_combined_queries('annotate')\n+        self._validate_values_are_expressions(args + tuple(kwargs.values()), method_name='annotate')\n+        annotations = {}\n+        for arg in args:\n+            # The default_alias property may raise a TypeError.\n+            try:\n+                if arg.default_alias in kwargs:\n+                    raise ValueError(\"The named annotation '%s' conflicts with the \"\n+                                     \"default name for another annotation.\"\n+                                     % arg.default_alias)\n+            except TypeError:\n+                raise TypeError(\"Complex annotations require an alias\")\n+            annotations[arg.default_alias] = arg\n+        annotations.update(kwargs)\n+\n+        clone = self._chain()\n+        names = self._fields\n+        if names is None:\n+            names = set(chain.from_iterable(\n+                (field.name, field.attname) if hasattr(field, 'attname') else (field.name,)\n+                for field in self.model._meta.get_fields()\n+            ))\n+\n+        for alias, annotation in annotations.items():\n+            if alias in names:\n+                raise ValueError(\"The annotation '%s' conflicts with a field on \"\n+                                 \"the model.\" % alias)\n+            if isinstance(annotation, FilteredRelation):\n+                clone.query.add_filtered_relation(annotation, alias)\n+            else:\n+                clone.query.add_annotation(annotation, alias, is_summary=False)\n+\n+        for alias, annotation in clone.query.annotations.items():\n+            if alias in annotations and annotation.contains_aggregate:\n+                if clone._fields is None:\n+                    clone.query.group_by = True\n+                else:\n+                    clone.query.set_group_by()\n+                break\n+\n+        return clone\n+\n+    def order_by(self, *field_names):\n+        \"\"\"Return a new QuerySet instance with the ordering changed.\"\"\"\n+        assert not self.query.is_sliced, \\\n+            \"Cannot reorder a query once a slice has been taken.\"\n+        obj = self._chain()\n+        obj.query.clear_ordering(force_empty=False)\n+        obj.query.add_ordering(*field_names)\n+        return obj\n+\n+    def distinct(self, *field_names):\n+        \"\"\"\n+        Return a new QuerySet instance that will select only distinct results.\n+        \"\"\"\n+        assert not self.query.is_sliced, \\\n+            \"Cannot create distinct fields once a slice has been taken.\"\n+        obj = self._chain()\n+        obj.query.add_distinct_fields(*field_names)\n+        return obj\n+\n+    def extra(self, select=None, where=None, params=None, tables=None,\n+              order_by=None, select_params=None):\n+        \"\"\"Add extra SQL fragments to the query.\"\"\"\n+        self._not_support_combined_queries('extra')\n+        assert not self.query.is_sliced, \\\n+            \"Cannot change a query once a slice has been taken\"\n+        clone = self._chain()\n+        clone.query.add_extra(select, select_params, where, params, tables, order_by)\n+        return clone\n+\n+    def reverse(self):\n+        \"\"\"Reverse the ordering of the QuerySet.\"\"\"\n+        if self.query.is_sliced:\n+            raise TypeError('Cannot reverse a query once a slice has been taken.')\n+        clone = self._chain()\n+        clone.query.standard_ordering = not clone.query.standard_ordering\n+        return clone\n+\n+    def defer(self, *fields):\n+        \"\"\"\n+        Defer the loading of data for certain fields until they are accessed.\n+        Add the set of deferred fields to any existing set of deferred fields.\n+        The only exception to this is if None is passed in as the only\n+        parameter, in which case removal all deferrals.\n+        \"\"\"\n+        self._not_support_combined_queries('defer')\n+        if self._fields is not None:\n+            raise TypeError(\"Cannot call defer() after .values() or .values_list()\")\n+        clone = self._chain()\n+        if fields == (None,):\n+            clone.query.clear_deferred_loading()\n+        else:\n+            clone.query.add_deferred_loading(fields)\n+        return clone\n+\n+    def only(self, *fields):\n+        \"\"\"\n+        Essentially, the opposite of defer(). Only the fields passed into this\n+        method and that are not already specified as deferred are loaded\n+        immediately when the queryset is evaluated.\n+        \"\"\"\n+        self._not_support_combined_queries('only')\n+        if self._fields is not None:\n+            raise TypeError(\"Cannot call only() after .values() or .values_list()\")\n+        if fields == (None,):\n+            # Can only pass None to defer(), not only(), as the rest option.\n+            # That won't stop people trying to do this, so let's be explicit.\n+            raise TypeError(\"Cannot pass None as an argument to only().\")\n+        for field in fields:\n+            field = field.split(LOOKUP_SEP, 1)[0]\n+            if field in self.query._filtered_relations:\n+                raise ValueError('only() is not supported with FilteredRelation.')\n+        clone = self._chain()\n+        clone.query.add_immediate_loading(fields)\n+        return clone\n+\n+    def using(self, alias):\n+        \"\"\"Select which database this QuerySet should execute against.\"\"\"\n+        clone = self._chain()\n+        clone._db = alias\n+        return clone\n+\n+    ###################################\n+    # PUBLIC INTROSPECTION ATTRIBUTES #\n+    ###################################\n+\n+    @property\n+    def ordered(self):\n+        \"\"\"\n+        Return True if the QuerySet is ordered -- i.e. has an order_by()\n+        clause or a default ordering on the model (or is empty).\n+        \"\"\"\n+        if isinstance(self, EmptyQuerySet):\n+            return True\n+        if self.query.extra_order_by or self.query.order_by:\n+            return True\n+        elif self.query.default_ordering and self.query.get_meta().ordering:\n+            return True\n+        else:\n+            return False\n+\n+    @property\n+    def db(self):\n+        \"\"\"Return the database used if this query is executed now.\"\"\"\n+        if self._for_write:\n+            return self._db or router.db_for_write(self.model, **self._hints)\n+        return self._db or router.db_for_read(self.model, **self._hints)\n+\n+    ###################\n+    # PRIVATE METHODS #\n+    ###################\n+\n+    def _insert(self, objs, fields, returning_fields=None, raw=False, using=None, ignore_conflicts=False):\n+        \"\"\"\n+        Insert a new record for the given model. This provides an interface to\n+        the InsertQuery class and is how Model.save() is implemented.\n+        \"\"\"\n+        self._for_write = True\n+        if using is None:\n+            using = self.db\n+        query = sql.InsertQuery(self.model, ignore_conflicts=ignore_conflicts)\n+        query.insert_values(fields, objs, raw=raw)\n+        return query.get_compiler(using=using).execute_sql(returning_fields)\n+    _insert.alters_data = True\n+    _insert.queryset_only = False\n+\n+    def _batched_insert(self, objs, fields, batch_size, ignore_conflicts=False):\n+        \"\"\"\n+        Helper method for bulk_create() to insert objs one batch at a time.\n+        \"\"\"\n+        if ignore_conflicts and not connections[self.db].features.supports_ignore_conflicts:\n+            raise NotSupportedError('This database backend does not support ignoring conflicts.')\n+        ops = connections[self.db].ops\n+        batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))\n+        inserted_rows = []\n+        bulk_return = connections[self.db].features.can_return_rows_from_bulk_insert\n+        for item in [objs[i:i + batch_size] for i in range(0, len(objs), batch_size)]:\n+            if bulk_return and not ignore_conflicts:\n+                inserted_columns = self._insert(\n+                    item, fields=fields, using=self.db,\n+                    returning_fields=self.model._meta.db_returning_fields,\n+                    ignore_conflicts=ignore_conflicts,\n+                )\n+                if isinstance(inserted_columns, list):\n+                    inserted_rows.extend(inserted_columns)\n+                else:\n+                    inserted_rows.append(inserted_columns)\n+            else:\n+                self._insert(item, fields=fields, using=self.db, ignore_conflicts=ignore_conflicts)\n+        return inserted_rows\n+\n+    def _chain(self, **kwargs):\n+        \"\"\"\n+        Return a copy of the current QuerySet that's ready for another\n+        operation.\n+        \"\"\"\n+        obj = self._clone()\n+        if obj._sticky_filter:\n+            obj.query.filter_is_sticky = True\n+            obj._sticky_filter = False\n+        obj.__dict__.update(kwargs)\n+        return obj\n+\n+    def _clone(self):\n+        \"\"\"\n+        Return a copy of the current QuerySet. A lightweight alternative\n+        to deepcopy().\n+        \"\"\"\n+        c = self.__class__(model=self.model, query=self.query.chain(), using=self._db, hints=self._hints)\n+        c._sticky_filter = self._sticky_filter\n+        c._for_write = self._for_write\n+        c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n+        c._known_related_objects = self._known_related_objects\n+        c._iterable_class = self._iterable_class\n+        c._fields = self._fields\n+        return c\n+\n+    def _fetch_all(self):\n+        if self._result_cache is None:\n+            self._result_cache = list(self._iterable_class(self))\n+        if self._prefetch_related_lookups and not self._prefetch_done:\n+            self._prefetch_related_objects()\n+\n+    def _next_is_sticky(self):\n+        \"\"\"\n+        Indicate that the next filter call and the one following that should\n+        be treated as a single filter. This is only important when it comes to\n+        determining when to reuse tables for many-to-many filters. Required so\n+        that we can filter naturally on the results of related managers.\n+\n+        This doesn't return a clone of the current QuerySet (it returns\n+        \"self\"). The method is only used internally and should be immediately\n+        followed by a filter() that does create a clone.\n+        \"\"\"\n+        self._sticky_filter = True\n+        return self\n+\n+    def _merge_sanity_check(self, other):\n+        \"\"\"Check that two QuerySet classes may be merged.\"\"\"\n+        if self._fields is not None and (\n+                set(self.query.values_select) != set(other.query.values_select) or\n+                set(self.query.extra_select) != set(other.query.extra_select) or\n+                set(self.query.annotation_select) != set(other.query.annotation_select)):\n+            raise TypeError(\n+                \"Merging '%s' classes must involve the same values in each case.\"\n+                % self.__class__.__name__\n+            )\n+\n+    def _merge_known_related_objects(self, other):\n+        \"\"\"\n+        Keep track of all known related objects from either QuerySet instance.\n+        \"\"\"\n+        for field, objects in other._known_related_objects.items():\n+            self._known_related_objects.setdefault(field, {}).update(objects)\n+\n+    def resolve_expression(self, *args, **kwargs):\n+        if self._fields and len(self._fields) > 1:\n+            # values() queryset can only be used as nested queries\n+            # if they are set up to select only a single field.\n+            raise TypeError('Cannot use multi-field values as a filter value.')\n+        query = self.query.resolve_expression(*args, **kwargs)\n+        query._db = self._db\n+        return query\n+    resolve_expression.queryset_only = True\n+\n+    def _add_hints(self, **hints):\n+        \"\"\"\n+        Update hinting information for use by routers. Add new key/values or\n+        overwrite existing key/values.\n+        \"\"\"\n+        self._hints.update(hints)\n+\n+    def _has_filters(self):\n+        \"\"\"\n+        Check if this QuerySet has any filtering going on. This isn't\n+        equivalent with checking if all objects are present in results, for\n+        example, qs[1:]._has_filters() -> False.\n+        \"\"\"\n+        return self.query.has_filters()\n+\n+    @staticmethod\n+    def _validate_values_are_expressions(values, method_name):\n+        invalid_args = sorted(str(arg) for arg in values if not hasattr(arg, 'resolve_expression'))\n+        if invalid_args:\n+            raise TypeError(\n+                'QuerySet.%s() received non-expression(s): %s.' % (\n+                    method_name,\n+                    ', '.join(invalid_args),\n+                )\n+            )\n+\n+    def _not_support_combined_queries(self, operation_name):\n+        if self.query.combinator:\n+            raise NotSupportedError(\n+                'Calling QuerySet.%s() after %s() is not supported.'\n+                % (operation_name, self.query.combinator)\n+            )\n+\n+\n+class InstanceCheckMeta(type):\n+    def __instancecheck__(self, instance):\n+        return isinstance(instance, QuerySet) and instance.query.is_empty()\n+\n+\n+class EmptyQuerySet(metaclass=InstanceCheckMeta):\n+    \"\"\"\n+    Marker class to checking if a queryset is empty by .none():\n+        isinstance(qs.none(), EmptyQuerySet) -> True\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        raise TypeError(\"EmptyQuerySet can't be instantiated\")\n+\n+\n+class RawQuerySet:\n+    \"\"\"\n+    Provide an iterator which converts the results of raw SQL queries into\n+    annotated model instances.\n+    \"\"\"\n+    def __init__(self, raw_query, model=None, query=None, params=None,\n+                 translations=None, using=None, hints=None):\n+        self.raw_query = raw_query\n+        self.model = model\n+        self._db = using\n+        self._hints = hints or {}\n+        self.query = query or sql.RawQuery(sql=raw_query, using=self.db, params=params)\n+        self.params = params or ()\n+        self.translations = translations or {}\n+        self._result_cache = None\n+        self._prefetch_related_lookups = ()\n+        self._prefetch_done = False\n+\n+    def resolve_model_init_order(self):\n+        \"\"\"Resolve the init field names and value positions.\"\"\"\n+        converter = connections[self.db].introspection.identifier_converter\n+        model_init_fields = [f for f in self.model._meta.fields if converter(f.column) in self.columns]\n+        annotation_fields = [(column, pos) for pos, column in enumerate(self.columns)\n+                             if column not in self.model_fields]\n+        model_init_order = [self.columns.index(converter(f.column)) for f in model_init_fields]\n+        model_init_names = [f.attname for f in model_init_fields]\n+        return model_init_names, model_init_order, annotation_fields\n+\n+    def prefetch_related(self, *lookups):\n+        \"\"\"Same as QuerySet.prefetch_related()\"\"\"\n+        clone = self._clone()\n+        if lookups == (None,):\n+            clone._prefetch_related_lookups = ()\n+        else:\n+            clone._prefetch_related_lookups = clone._prefetch_related_lookups + lookups\n+        return clone\n+\n+    def _prefetch_related_objects(self):\n+        prefetch_related_objects(self._result_cache, *self._prefetch_related_lookups)\n+        self._prefetch_done = True\n+\n+    def _clone(self):\n+        \"\"\"Same as QuerySet._clone()\"\"\"\n+        c = self.__class__(\n+            self.raw_query, model=self.model, query=self.query, params=self.params,\n+            translations=self.translations, using=self._db, hints=self._hints\n+        )\n+        c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n+        return c\n+\n+    def _fetch_all(self):\n+        if self._result_cache is None:\n+            self._result_cache = list(self.iterator())\n+        if self._prefetch_related_lookups and not self._prefetch_done:\n+            self._prefetch_related_objects()\n+\n+    def __len__(self):\n+        self._fetch_all()\n+        return len(self._result_cache)\n+\n+    def __bool__(self):\n+        self._fetch_all()\n+        return bool(self._result_cache)\n+\n+    def __iter__(self):\n+        self._fetch_all()\n+        return iter(self._result_cache)\n+\n+    def iterator(self):\n+        # Cache some things for performance reasons outside the loop.\n+        db = self.db\n+        compiler = connections[db].ops.compiler('SQLCompiler')(\n+            self.query, connections[db], db\n+        )\n+\n+        query = iter(self.query)\n+\n+        try:\n+            model_init_names, model_init_pos, annotation_fields = self.resolve_model_init_order()\n+            if self.model._meta.pk.attname not in model_init_names:\n+                raise InvalidQuery('Raw query must include the primary key')\n+            model_cls = self.model\n+            fields = [self.model_fields.get(c) for c in self.columns]\n+            converters = compiler.get_converters([\n+                f.get_col(f.model._meta.db_table) if f else None for f in fields\n+            ])\n+            if converters:\n+                query = compiler.apply_converters(query, converters)\n+            for values in query:\n+                # Associate fields to values\n+                model_init_values = [values[pos] for pos in model_init_pos]\n+                instance = model_cls.from_db(db, model_init_names, model_init_values)\n+                if annotation_fields:\n+                    for column, pos in annotation_fields:\n+                        setattr(instance, column, values[pos])\n+                yield instance\n+        finally:\n+            # Done iterating the Query. If it has its own cursor, close it.\n+            if hasattr(self.query, 'cursor') and self.query.cursor:\n+                self.query.cursor.close()\n+\n+    def __repr__(self):\n+        return \"<%s: %s>\" % (self.__class__.__name__, self.query)\n+\n+    def __getitem__(self, k):\n+        return list(self)[k]\n+\n+    @property\n+    def db(self):\n+        \"\"\"Return the database used if this query is executed now.\"\"\"\n+        return self._db or router.db_for_read(self.model, **self._hints)\n+\n+    def using(self, alias):\n+        \"\"\"Select the database this RawQuerySet should execute against.\"\"\"\n+        return RawQuerySet(\n+            self.raw_query, model=self.model,\n+            query=self.query.chain(using=alias),\n+            params=self.params, translations=self.translations,\n+            using=alias,\n+        )\n+\n+    @cached_property\n+    def columns(self):\n+        \"\"\"\n+        A list of model field names in the order they'll appear in the\n+        query results.\n+        \"\"\"\n+        columns = self.query.get_columns()\n+        # Adjust any column names which don't match field names\n+        for (query_name, model_name) in self.translations.items():\n+            # Ignore translations for nonexistent column names\n+            try:\n+                index = columns.index(query_name)\n+            except ValueError:\n+                pass\n+            else:\n+                columns[index] = model_name\n+        return columns\n+\n+    @cached_property\n+    def model_fields(self):\n+        \"\"\"A dict mapping column names to model field names.\"\"\"\n+        converter = connections[self.db].introspection.identifier_converter\n+        model_fields = {}\n+        for field in self.model._meta.fields:\n+            name, column = field.get_attname_column()\n+            model_fields[converter(column)] = field\n+        return model_fields\n+\n+\n+class Prefetch:\n+    def __init__(self, lookup, queryset=None, to_attr=None):\n+        # `prefetch_through` is the path we traverse to perform the prefetch.\n+        self.prefetch_through = lookup\n+        # `prefetch_to` is the path to the attribute that stores the result.\n+        self.prefetch_to = lookup\n+        if queryset is not None and not issubclass(queryset._iterable_class, ModelIterable):\n+            raise ValueError('Prefetch querysets cannot use values().')\n+        if to_attr:\n+            self.prefetch_to = LOOKUP_SEP.join(lookup.split(LOOKUP_SEP)[:-1] + [to_attr])\n+\n+        self.queryset = queryset\n+        self.to_attr = to_attr\n+\n+    def __getstate__(self):\n+        obj_dict = self.__dict__.copy()\n+        if self.queryset is not None:\n+            # Prevent the QuerySet from being evaluated\n+            obj_dict['queryset'] = self.queryset._chain(\n+                _result_cache=[],\n+                _prefetch_done=True,\n+            )\n+        return obj_dict\n+\n+    def add_prefix(self, prefix):\n+        self.prefetch_through = prefix + LOOKUP_SEP + self.prefetch_through\n+        self.prefetch_to = prefix + LOOKUP_SEP + self.prefetch_to\n+\n+    def get_current_prefetch_to(self, level):\n+        return LOOKUP_SEP.join(self.prefetch_to.split(LOOKUP_SEP)[:level + 1])\n+\n+    def get_current_to_attr(self, level):\n+        parts = self.prefetch_to.split(LOOKUP_SEP)\n+        to_attr = parts[level]\n+        as_attr = self.to_attr and level == len(parts) - 1\n+        return to_attr, as_attr\n+\n+    def get_current_queryset(self, level):\n+        if self.get_current_prefetch_to(level) == self.prefetch_to:\n+            return self.queryset\n+        return None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Prefetch):\n+            return NotImplemented\n+        return self.prefetch_to == other.prefetch_to\n+\n+    def __hash__(self):\n+        return hash((self.__class__, self.prefetch_to))\n+\n+\n+def normalize_prefetch_lookups(lookups, prefix=None):\n+    \"\"\"Normalize lookups into Prefetch objects.\"\"\"\n+    ret = []\n+    for lookup in lookups:\n+        if not isinstance(lookup, Prefetch):\n+            lookup = Prefetch(lookup)\n+        if prefix:\n+            lookup.add_prefix(prefix)\n+        ret.append(lookup)\n+    return ret\n+\n+\n+def prefetch_related_objects(model_instances, *related_lookups):\n+    \"\"\"\n+    Populate prefetched object caches for a list of model instances based on\n+    the lookups/Prefetch instances given.\n+    \"\"\"\n+    if not model_instances:\n+        return  # nothing to do\n+\n+    # We need to be able to dynamically add to the list of prefetch_related\n+    # lookups that we look up (see below).  So we need some book keeping to\n+    # ensure we don't do duplicate work.\n+    done_queries = {}    # dictionary of things like 'foo__bar': [results]\n+\n+    auto_lookups = set()  # we add to this as we go through.\n+    followed_descriptors = set()  # recursion protection\n+\n+    all_lookups = normalize_prefetch_lookups(reversed(related_lookups))\n+    while all_lookups:\n+        lookup = all_lookups.pop()\n+        if lookup.prefetch_to in done_queries:\n+            if lookup.queryset is not None:\n+                raise ValueError(\"'%s' lookup was already seen with a different queryset. \"\n+                                 \"You may need to adjust the ordering of your lookups.\" % lookup.prefetch_to)\n+\n+            continue\n+\n+        # Top level, the list of objects to decorate is the result cache\n+        # from the primary QuerySet. It won't be for deeper levels.\n+        obj_list = model_instances\n+\n+        through_attrs = lookup.prefetch_through.split(LOOKUP_SEP)\n+        for level, through_attr in enumerate(through_attrs):\n+            # Prepare main instances\n+            if not obj_list:\n+                break\n+\n+            prefetch_to = lookup.get_current_prefetch_to(level)\n+            if prefetch_to in done_queries:\n+                # Skip any prefetching, and any object preparation\n+                obj_list = done_queries[prefetch_to]\n+                continue\n+\n+            # Prepare objects:\n+            good_objects = True\n+            for obj in obj_list:\n+                # Since prefetching can re-use instances, it is possible to have\n+                # the same instance multiple times in obj_list, so obj might\n+                # already be prepared.\n+                if not hasattr(obj, '_prefetched_objects_cache'):\n+                    try:\n+                        obj._prefetched_objects_cache = {}\n+                    except (AttributeError, TypeError):\n+                        # Must be an immutable object from\n+                        # values_list(flat=True), for example (TypeError) or\n+                        # a QuerySet subclass that isn't returning Model\n+                        # instances (AttributeError), either in Django or a 3rd\n+                        # party. prefetch_related() doesn't make sense, so quit.\n+                        good_objects = False\n+                        break\n+            if not good_objects:\n+                break\n+\n+            # Descend down tree\n+\n+            # We assume that objects retrieved are homogeneous (which is the premise\n+            # of prefetch_related), so what applies to first object applies to all.\n+            first_obj = obj_list[0]\n+            to_attr = lookup.get_current_to_attr(level)[0]\n+            prefetcher, descriptor, attr_found, is_fetched = get_prefetcher(first_obj, through_attr, to_attr)\n+\n+            if not attr_found:\n+                raise AttributeError(\"Cannot find '%s' on %s object, '%s' is an invalid \"\n+                                     \"parameter to prefetch_related()\" %\n+                                     (through_attr, first_obj.__class__.__name__, lookup.prefetch_through))\n+\n+            if level == len(through_attrs) - 1 and prefetcher is None:\n+                # Last one, this *must* resolve to something that supports\n+                # prefetching, otherwise there is no point adding it and the\n+                # developer asking for it has made a mistake.\n+                raise ValueError(\"'%s' does not resolve to an item that supports \"\n+                                 \"prefetching - this is an invalid parameter to \"\n+                                 \"prefetch_related().\" % lookup.prefetch_through)\n+\n+            if prefetcher is not None and not is_fetched:\n+                obj_list, additional_lookups = prefetch_one_level(obj_list, prefetcher, lookup, level)\n+                # We need to ensure we don't keep adding lookups from the\n+                # same relationships to stop infinite recursion. So, if we\n+                # are already on an automatically added lookup, don't add\n+                # the new lookups from relationships we've seen already.\n+                if not (prefetch_to in done_queries and lookup in auto_lookups and descriptor in followed_descriptors):\n+                    done_queries[prefetch_to] = obj_list\n+                    new_lookups = normalize_prefetch_lookups(reversed(additional_lookups), prefetch_to)\n+                    auto_lookups.update(new_lookups)\n+                    all_lookups.extend(new_lookups)\n+                followed_descriptors.add(descriptor)\n+            else:\n+                # Either a singly related object that has already been fetched\n+                # (e.g. via select_related), or hopefully some other property\n+                # that doesn't support prefetching but needs to be traversed.\n+\n+                # We replace the current list of parent objects with the list\n+                # of related objects, filtering out empty or missing values so\n+                # that we can continue with nullable or reverse relations.\n+                new_obj_list = []\n+                for obj in obj_list:\n+                    if through_attr in getattr(obj, '_prefetched_objects_cache', ()):\n+                        # If related objects have been prefetched, use the\n+                        # cache rather than the object's through_attr.\n+                        new_obj = list(obj._prefetched_objects_cache.get(through_attr))\n+                    else:\n+                        try:\n+                            new_obj = getattr(obj, through_attr)\n+                        except exceptions.ObjectDoesNotExist:\n+                            continue\n+                    if new_obj is None:\n+                        continue\n+                    # We special-case `list` rather than something more generic\n+                    # like `Iterable` because we don't want to accidentally match\n+                    # user models that define __iter__.\n+                    if isinstance(new_obj, list):\n+                        new_obj_list.extend(new_obj)\n+                    else:\n+                        new_obj_list.append(new_obj)\n+                obj_list = new_obj_list\n+\n+\n+def get_prefetcher(instance, through_attr, to_attr):\n+    \"\"\"\n+    For the attribute 'through_attr' on the given instance, find\n+    an object that has a get_prefetch_queryset().\n+    Return a 4 tuple containing:\n+    (the object with get_prefetch_queryset (or None),\n+     the descriptor object representing this relationship (or None),\n+     a boolean that is False if the attribute was not found at all,\n+     a boolean that is True if the attribute has already been fetched)\n+    \"\"\"\n+    prefetcher = None\n+    is_fetched = False\n+\n+    # For singly related objects, we have to avoid getting the attribute\n+    # from the object, as this will trigger the query. So we first try\n+    # on the class, in order to get the descriptor object.\n+    rel_obj_descriptor = getattr(instance.__class__, through_attr, None)\n+    if rel_obj_descriptor is None:\n+        attr_found = hasattr(instance, through_attr)\n+    else:\n+        attr_found = True\n+        if rel_obj_descriptor:\n+            # singly related object, descriptor object has the\n+            # get_prefetch_queryset() method.\n+            if hasattr(rel_obj_descriptor, 'get_prefetch_queryset'):\n+                prefetcher = rel_obj_descriptor\n+                if rel_obj_descriptor.is_cached(instance):\n+                    is_fetched = True\n+            else:\n+                # descriptor doesn't support prefetching, so we go ahead and get\n+                # the attribute on the instance rather than the class to\n+                # support many related managers\n+                rel_obj = getattr(instance, through_attr)\n+                if hasattr(rel_obj, 'get_prefetch_queryset'):\n+                    prefetcher = rel_obj\n+                if through_attr != to_attr:\n+                    # Special case cached_property instances because hasattr\n+                    # triggers attribute computation and assignment.\n+                    if isinstance(getattr(instance.__class__, to_attr, None), cached_property):\n+                        is_fetched = to_attr in instance.__dict__\n+                    else:\n+                        is_fetched = hasattr(instance, to_attr)\n+                else:\n+                    is_fetched = through_attr in instance._prefetched_objects_cache\n+    return prefetcher, rel_obj_descriptor, attr_found, is_fetched\n+\n+\n+def prefetch_one_level(instances, prefetcher, lookup, level):\n+    \"\"\"\n+    Helper function for prefetch_related_objects().\n+\n+    Run prefetches on all instances using the prefetcher object,\n+    assigning results to relevant caches in instance.\n+\n+    Return the prefetched objects along with any additional prefetches that\n+    must be done due to prefetch_related lookups found from default managers.\n+    \"\"\"\n+    # prefetcher must have a method get_prefetch_queryset() which takes a list\n+    # of instances, and returns a tuple:\n+\n+    # (queryset of instances of self.model that are related to passed in instances,\n+    #  callable that gets value to be matched for returned instances,\n+    #  callable that gets value to be matched for passed in instances,\n+    #  boolean that is True for singly related objects,\n+    #  cache or field name to assign to,\n+    #  boolean that is True when the previous argument is a cache name vs a field name).\n+\n+    # The 'values to be matched' must be hashable as they will be used\n+    # in a dictionary.\n+\n+    rel_qs, rel_obj_attr, instance_attr, single, cache_name, is_descriptor = (\n+        prefetcher.get_prefetch_queryset(instances, lookup.get_current_queryset(level)))\n+    # We have to handle the possibility that the QuerySet we just got back\n+    # contains some prefetch_related lookups. We don't want to trigger the\n+    # prefetch_related functionality by evaluating the query. Rather, we need\n+    # to merge in the prefetch_related lookups.\n+    # Copy the lookups in case it is a Prefetch object which could be reused\n+    # later (happens in nested prefetch_related).\n+    additional_lookups = [\n+        copy.copy(additional_lookup) for additional_lookup\n+        in getattr(rel_qs, '_prefetch_related_lookups', ())\n+    ]\n+    if additional_lookups:\n+        # Don't need to clone because the manager should have given us a fresh\n+        # instance, so we access an internal instead of using public interface\n+        # for performance reasons.\n+        rel_qs._prefetch_related_lookups = ()\n+\n+    all_related_objects = list(rel_qs)\n+\n+    rel_obj_cache = {}\n+    for rel_obj in all_related_objects:\n+        rel_attr_val = rel_obj_attr(rel_obj)\n+        rel_obj_cache.setdefault(rel_attr_val, []).append(rel_obj)\n+\n+    to_attr, as_attr = lookup.get_current_to_attr(level)\n+    # Make sure `to_attr` does not conflict with a field.\n+    if as_attr and instances:\n+        # We assume that objects retrieved are homogeneous (which is the premise\n+        # of prefetch_related), so what applies to first object applies to all.\n+        model = instances[0].__class__\n+        try:\n+            model._meta.get_field(to_attr)\n+        except exceptions.FieldDoesNotExist:\n+            pass\n+        else:\n+            msg = 'to_attr={} conflicts with a field on the {} model.'\n+            raise ValueError(msg.format(to_attr, model.__name__))\n+\n+    # Whether or not we're prefetching the last part of the lookup.\n+    leaf = len(lookup.prefetch_through.split(LOOKUP_SEP)) - 1 == level\n+\n+    for obj in instances:\n+        instance_attr_val = instance_attr(obj)\n+        vals = rel_obj_cache.get(instance_attr_val, [])\n+\n+        if single:\n+            val = vals[0] if vals else None\n+            if as_attr:\n+                # A to_attr has been given for the prefetch.\n+                setattr(obj, to_attr, val)\n+            elif is_descriptor:\n+                # cache_name points to a field name in obj.\n+                # This field is a descriptor for a related object.\n+                setattr(obj, cache_name, val)\n+            else:\n+                # No to_attr has been given for this prefetch operation and the\n+                # cache_name does not point to a descriptor. Store the value of\n+                # the field in the object's field cache.\n+                obj._state.fields_cache[cache_name] = val\n+        else:\n+            if as_attr:\n+                setattr(obj, to_attr, vals)\n+            else:\n+                manager = getattr(obj, to_attr)\n+                if leaf and lookup.queryset is not None:\n+                    qs = manager._apply_rel_filters(lookup.queryset)\n+                else:\n+                    qs = manager.get_queryset()\n+                qs._result_cache = vals\n+                # We don't want the individual qs doing prefetch_related now,\n+                # since we have merged this into the current work.\n+                qs._prefetch_done = True\n+                obj._prefetched_objects_cache[cache_name] = qs\n+    return all_related_objects, additional_lookups\n+\n+\n+class RelatedPopulator:\n+    \"\"\"\n+    RelatedPopulator is used for select_related() object instantiation.\n+\n+    The idea is that each select_related() model will be populated by a\n+    different RelatedPopulator instance. The RelatedPopulator instances get\n+    klass_info and select (computed in SQLCompiler) plus the used db as\n+    input for initialization. That data is used to compute which columns\n+    to use, how to instantiate the model, and how to populate the links\n+    between the objects.\n+\n+    The actual creation of the objects is done in populate() method. This\n+    method gets row and from_obj as input and populates the select_related()\n+    model instance.\n+    \"\"\"\n+    def __init__(self, klass_info, select, db):\n+        self.db = db\n+        # Pre-compute needed attributes. The attributes are:\n+        #  - model_cls: the possibly deferred model class to instantiate\n+        #  - either:\n+        #    - cols_start, cols_end: usually the columns in the row are\n+        #      in the same order model_cls.__init__ expects them, so we\n+        #      can instantiate by model_cls(*row[cols_start:cols_end])\n+        #    - reorder_for_init: When select_related descends to a child\n+        #      class, then we want to reuse the already selected parent\n+        #      data. However, in this case the parent data isn't necessarily\n+        #      in the same order that Model.__init__ expects it to be, so\n+        #      we have to reorder the parent data. The reorder_for_init\n+        #      attribute contains a function used to reorder the field data\n+        #      in the order __init__ expects it.\n+        #  - pk_idx: the index of the primary key field in the reordered\n+        #    model data. Used to check if a related object exists at all.\n+        #  - init_list: the field attnames fetched from the database. For\n+        #    deferred models this isn't the same as all attnames of the\n+        #    model's fields.\n+        #  - related_populators: a list of RelatedPopulator instances if\n+        #    select_related() descends to related models from this model.\n+        #  - local_setter, remote_setter: Methods to set cached values on\n+        #    the object being populated and on the remote object. Usually\n+        #    these are Field.set_cached_value() methods.\n+        select_fields = klass_info['select_fields']\n+        from_parent = klass_info['from_parent']\n+        if not from_parent:\n+            self.cols_start = select_fields[0]\n+            self.cols_end = select_fields[-1] + 1\n+            self.init_list = [\n+                f[0].target.attname for f in select[self.cols_start:self.cols_end]\n+            ]\n+            self.reorder_for_init = None\n+        else:\n+            attname_indexes = {select[idx][0].target.attname: idx for idx in select_fields}\n+            model_init_attnames = (f.attname for f in klass_info['model']._meta.concrete_fields)\n+            self.init_list = [attname for attname in model_init_attnames if attname in attname_indexes]\n+            self.reorder_for_init = operator.itemgetter(*[attname_indexes[attname] for attname in self.init_list])\n+\n+        self.model_cls = klass_info['model']\n+        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+        self.related_populators = get_related_populators(klass_info, select, self.db)\n+        self.local_setter = klass_info['local_setter']\n+        self.remote_setter = klass_info['remote_setter']\n+\n+    def populate(self, row, from_obj):\n+        if self.reorder_for_init:\n+            obj_data = self.reorder_for_init(row)\n+        else:\n+            obj_data = row[self.cols_start:self.cols_end]\n+        if obj_data[self.pk_idx] is None:\n+            obj = None\n+        else:\n+            obj = self.model_cls.from_db(self.db, self.init_list, obj_data)\n+            for rel_iter in self.related_populators:\n+                rel_iter.populate(row, obj)\n+        self.local_setter(from_obj, obj)\n+        if obj is not None:\n+            self.remote_setter(obj, from_obj)\n+\n+\n+def get_related_populators(klass_info, select, db):\n+    iterators = []\n+    related_klass_infos = klass_info.get('related_klass_infos', [])\n+    for rel_klass_info in related_klass_infos:\n+        rel_cls = RelatedPopulator(rel_klass_info, select, db)\n+        iterators.append(rel_cls)\n+    return iterators\n\n"
  },
  "django__django-11964": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11964",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..ec0cc6c2bf 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -60,7 +60,8 @@ class ChoicesMeta(enum.EnumMeta):\n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated choices.\"\"\"\n-    pass\n+    def __str__(self):\n+        return str(self.value)\n \n \n class IntegerChoices(int, Choices):\n\n"
  },
  "django__django-11999": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11999",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..7879115ee4 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,9 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            if 'get_%s_display' % self.name not in cls.__dict__:\n+                setattr(cls, 'get_%s_display' % self.name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n\n"
  },
  "django__django-12039": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12039",
    "model_patch": "diff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex 44e49806f8..90cae58d4d 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -84,9 +84,10 @@ class Columns(TableColumns):\n     def __str__(self):\n         def col_str(column, idx):\n             try:\n-                return self.quote_name(column) + self.col_suffixes[idx]\n+                suffix = self.col_suffixes[idx]\n             except IndexError:\n                 return self.quote_name(column)\n+            return self.quote_name(column) + (' ' + suffix if suffix else '')\n \n         return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n \n@@ -114,14 +115,12 @@ class IndexColumns(Columns):\n             # length as self.columns.\n             col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n             try:\n-                col = '{} {}'.format(col, self.col_suffixes[idx])\n+                suffix = self.col_suffixes[idx]\n             except IndexError:\n-                pass\n-            return col\n+                return col\n+            return col + (' ' + suffix if suffix else '')\n \n         return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n-\n-\n class ForeignKeyName(TableColumns):\n     \"\"\"Hold a reference to a foreign key name.\"\"\"\n \n\n"
  },
  "django__django-12050": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12050",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ea51912e8b..605cb43b34 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,7 @@ class Query(BaseExpression):\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            value = value.__class__(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\ndiff --git a/repro_resolve_lookup_value.py b/repro_resolve_lookup_value.py\nnew file mode 100644\nindex 0000000000..b5aa55af47\n--- /dev/null\n+++ b/repro_resolve_lookup_value.py\n@@ -0,0 +1,7 @@\n+from django.db.models.sql.query import Query\n+from django.db.models.expressions import F\n+q = Query(None)\n+v = [1, 2, 3]\n+out = q.resolve_lookup_value(v, can_reuse=None, allow_joins=False, simple_col=None)\n+print(type(out).__name__)\n+print(out)\n\nbash execution output:\n \n==================================== ERRORS ====================================\n________ ERROR collecting tests/admin_changelist/test_date_hierarchy.py ________\ntests/admin_changelist/test_date_hierarchy.py:4: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/admin_docs/test_middleware.py _____________\ntests/admin_docs/test_middleware.py:1: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/admin_docs/test_utils.py ________________\ntests/admin_docs/test_utils.py:7: in <module>\n    from .tests import AdminDocsSimpleTestCase\ntests/admin_docs/tests.py:1: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/admin_docs/test_views.py ________________\ntests/admin_docs/test_views.py:7: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/admin_utils/test_logentry.py ______________\ntests/admin_utils/test_logentry.py:4: in <module>\n    from django.contrib.admin.models import ADDITION, CHANGE, DELETION, LogEntry\ndjango/contrib/admin/models.py:5: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/admin_views/test_actions.py ______________\ntests/admin_views/test_actions.py:5: in <module>\n    from django.contrib.auth.models import Permission, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/admin_views/test_adminsite.py _____________\ntests/admin_views/test_adminsite.py:3: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/admin_views/test_autocomplete_view.py _________\ntests/admin_views/test_autocomplete_view.py:7: in <module>\n    from django.contrib.auth.models import Permission, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/admin_views/test_forms.py _______________\ntests/admin_views/test_forms.py:1: in <module>\n    from django.contrib.admin.forms import AdminAuthenticationForm\ndjango/contrib/admin/forms.py:2: in <module>\n    from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm\ndjango/contrib/auth/forms.py:10: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/admin_views/test_history_view.py ____________\ntests/admin_views/test_history_view.py:1: in <module>\n    from django.contrib.admin.models import LogEntry\ndjango/contrib/admin/models.py:5: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/admin_views/test_multidb.py ______________\ntests/admin_views/test_multidb.py:4: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/admin_views/test_templatetags.py ____________\ntests/admin_views/test_templatetags.py:6: in <module>\n    from django.contrib.auth.admin import UserAdmin\ndjango/contrib/auth/admin.py:6: in <module>\n    from django.contrib.auth.forms import (\ndjango/contrib/auth/forms.py:10: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______ ERROR collecting tests/admin_widgets/test_autocomplete_widget.py _______\ntests/admin_widgets/test_autocomplete_widget.py:8: in <module>\n    from .models import Album, Band\ntests/admin_widgets/models.py:3: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/aggregation/test_filter_argument.py __________\ntests/aggregation/test_filter_argument.py:10: in <module>\n    from .models import Author, Book, Publisher\ntests/aggregation/models.py:4: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/auth_tests/test_admin_multidb.py ____________\ntests/auth_tests/test_admin_multidb.py:4: in <module>\n    from django.contrib.auth.admin import UserAdmin\ndjango/contrib/auth/admin.py:6: in <module>\n    from django.contrib.auth.forms import (\ndjango/contrib/auth/forms.py:10: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/auth_tests/test_auth_backends.py ____________\ntests/auth_tests/test_auth_backends.py:7: in <module>\n    from django.contrib.auth.backends import BaseBackend, ModelBackend\ndjango/contrib/auth/backends.py:2: in <module>\n    from django.contrib.auth.models import Permission\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_basic.py ________________\ntests/auth_tests/test_basic.py:2: in <module>\n    from django.contrib.auth.models import AnonymousUser, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_checks.py _______________\ntests/auth_tests/test_checks.py:4: in <module>\n    from django.contrib.auth.models import AbstractBaseUser\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/auth_tests/test_context_processors.py _________\ntests/auth_tests/test_context_processors.py:3: in <module>\n    from django.contrib.auth.models import Permission, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/auth_tests/test_decorators.py _____________\ntests/auth_tests/test_decorators.py:2: in <module>\n    from django.contrib.auth import models\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_forms.py ________________\ntests/auth_tests/test_forms.py:6: in <module>\n    from django.contrib.auth.forms import (\ndjango/contrib/auth/forms.py:10: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/auth_tests/test_handlers.py ______________\ntests/auth_tests/test_handlers.py:1: in <module>\n    from django.contrib.auth.handlers.modwsgi import (\ndjango/contrib/auth/handlers/modwsgi.py:4: in <module>\n    UserModel = auth.get_user_model()\ndjango/contrib/auth/__init__.py:156: in get_user_model\n    return django_apps.get_model(settings.AUTH_USER_MODEL, require_ready=False)\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting AUTH_USER_MODEL, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/auth_tests/test_management.py _____________\ntests/auth_tests/test_management.py:14: in <module>\n    from django.contrib.auth.management.commands import (\ndjango/contrib/auth/management/commands/changepassword.py:9: in <module>\n    UserModel = get_user_model()\ndjango/contrib/auth/__init__.py:156: in get_user_model\n    return django_apps.get_model(settings.AUTH_USER_MODEL, require_ready=False)\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting AUTH_USER_MODEL, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/auth_tests/test_middleware.py _____________\ntests/auth_tests/test_middleware.py:1: in <module>\n    from django.contrib.auth.middleware import AuthenticationMiddleware\ndjango/contrib/auth/middleware.py:5: in <module>\n    from django.contrib.auth.backends import RemoteUserBackend\ndjango/contrib/auth/backends.py:2: in <module>\n    from django.contrib.auth.models import Permission\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/auth_tests/test_migrations.py _____________\ntests/auth_tests/test_migrations.py:4: in <module>\n    from django.contrib.auth.models import Permission, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_mixins.py _______________\ntests/auth_tests/test_mixins.py:3: in <module>\n    from django.contrib.auth import models\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_models.py _______________\ntests/auth_tests/test_models.py:5: in <module>\n    from django.contrib.auth.backends import ModelBackend\ndjango/contrib/auth/backends.py:2: in <module>\n    from django.contrib.auth.models import Permission\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____ ERROR collecting tests/auth_tests/test_password_reset_timeout_days.py _____\ntests/auth_tests/test_password_reset_timeout_days.py:8: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/auth_tests/test_remote_user.py _____________\ntests/auth_tests/test_remote_user.py:5: in <module>\n    from django.contrib.auth.backends import RemoteUserBackend\ndjango/contrib/auth/backends.py:2: in <module>\n    from django.contrib.auth.models import Permission\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/auth_tests/test_signals.py _______________\ntests/auth_tests/test_signals.py:3: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/auth_tests/test_templates.py ______________\ntests/auth_tests/test_templates.py:2: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_tokens.py _______________\ntests/auth_tests/test_tokens.py:4: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/auth_tests/test_validators.py _____________\ntests/auth_tests/test_validators.py:4: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/auth_tests/test_views.py ________________\ntests/auth_tests/test_views.py:11: in <module>\n    from django.contrib.admin.models import LogEntry\ndjango/contrib/admin/models.py:5: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/backends/base/test_base.py _______________\ntests/backends/base/test_base.py:7: in <module>\n    from ..models import Square\ntests/backends/models.py:1: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/backends/mysql/test_creation.py ____________\ntests/backends/mysql/test_creation.py:13: in <module>\n    @unittest.skipUnless(connection.vendor == 'mysql', 'MySQL tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/backends/mysql/test_features.py ____________\ntests/backends/mysql/test_features.py:8: in <module>\n    @skipUnless(connection.vendor == 'mysql', 'MySQL tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/backends/mysql/test_introspection.py __________\ntests/backends/mysql/test_introspection.py:7: in <module>\n    @skipUnless(connection.vendor == 'mysql', 'MySQL tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/backends/mysql/test_schema.py _____________\ntests/backends/mysql/test_schema.py:7: in <module>\n    @unittest.skipUnless(connection.vendor == 'mysql', 'MySQL tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/backends/oracle/test_creation.py ____________\ntests/backends/oracle/test_creation.py:11: in <module>\n    @unittest.skipUnless(connection.vendor == 'oracle', 'Oracle tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/backends/oracle/test_introspection.py _________\ntests/backends/oracle/test_introspection.py:6: in <module>\n    from ..models import Person\ntests/backends/models.py:1: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/backends/oracle/test_operations.py ___________\ntests/backends/oracle/test_operations.py:6: in <module>\n    @unittest.skipUnless(connection.vendor == 'oracle', 'Oracle tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/backends/postgresql/test_creation.py __________\ntests/backends/postgresql/test_creation.py:20: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', 'PostgreSQL tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______ ERROR collecting tests/backends/postgresql/test_introspection.py _______\ntests/backends/postgresql/test_introspection.py:6: in <module>\n    from ..models import Person\ntests/backends/models.py:1: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____ ERROR collecting tests/backends/postgresql/test_server_side_cursors.py ____\ntests/backends/postgresql/test_server_side_cursors.py:9: in <module>\n    from ..models import Person\ntests/backends/models.py:1: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/backends/sqlite/test_introspection.py _________\ntests/backends/sqlite/test_introspection.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'sqlite', 'SQLite tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/check_framework/test_database.py ____________\ntests/check_framework/test_database.py:10: in <module>\n    class DatabaseCheckTests(TestCase):\ntests/check_framework/test_database.py:38: in DatabaseCheckTests\n    @unittest.skipUnless(connection.vendor == 'mysql', 'Test only for MySQL')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/check_framework/test_model_checks.py __________\ntests/check_framework/test_model_checks.py:250: in <module>\n    class ConstraintNameTests(TestCase):\ndjango/test/testcases.py:1212: in decorator\n    if not databases or connection.alias not in databases:\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/contenttypes_tests/test_checks.py ___________\ntests/contenttypes_tests/test_checks.py:4: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/contenttypes_tests/test_fields.py ___________\ntests/contenttypes_tests/test_fields.py:3: in <module>\n    from django.contrib.contenttypes.fields import GenericForeignKey\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/contenttypes_tests/test_management.py _________\ntests/contenttypes_tests/test_management.py:5: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/contenttypes_tests/test_models.py ___________\ntests/contenttypes_tests/test_models.py:1: in <module>\n    from django.contrib.contenttypes.models import ContentType, ContentTypeManager\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/contenttypes_tests/test_operations.py _________\ntests/contenttypes_tests/test_operations.py:4: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___ ERROR collecting tests/contenttypes_tests/test_order_with_respect_to.py ____\ntests/contenttypes_tests/test_order_with_respect_to.py:5: in <module>\n    from .models import Answer, Post, Question\ntests/contenttypes_tests/models.py:3: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/contenttypes_tests/test_views.py ____________\ntests/contenttypes_tests/test_views.py:4: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/db_functions/comparison/test_cast.py __________\ntests/db_functions/comparison/test_cast.py:13: in <module>\n    from ..models import Author, DTModel, Fan, FloatModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______ ERROR collecting tests/db_functions/comparison/test_coalesce.py ________\ntests/db_functions/comparison/test_coalesce.py:6: in <module>\n    from ..models import Article, Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______ ERROR collecting tests/db_functions/comparison/test_greatest.py ________\ntests/db_functions/comparison/test_greatest.py:11: in <module>\n    from ..models import Article, Author, DecimalModel, Fan\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/db_functions/comparison/test_least.py _________\ntests/db_functions/comparison/test_least.py:11: in <module>\n    from ..models import Article, Author, DecimalModel, Fan\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________ ERROR collecting tests/db_functions/comparison/test_nullif.py _________\ntests/db_functions/comparison/test_nullif.py:8: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______ ERROR collecting tests/db_functions/datetime/test_extract_trunc.py ______\ntests/db_functions/datetime/test_extract_trunc.py:22: in <module>\n    from ..models import Author, DTModel, Fan\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/datetime/test_now.py ___________\ntests/db_functions/datetime/test_now.py:7: in <module>\n    from ..models import Article\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_abs.py _____________\ntests/db_functions/math/test_abs.py:8: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_acos.py _____________\ntests/db_functions/math/test_acos.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_asin.py _____________\ntests/db_functions/math/test_asin.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_atan.py _____________\ntests/db_functions/math/test_atan.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_atan2.py ____________\ntests/db_functions/math/test_atan2.py:7: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_ceil.py _____________\ntests/db_functions/math/test_ceil.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_cos.py _____________\ntests/db_functions/math/test_cos.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_cot.py _____________\ntests/db_functions/math/test_cot.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/math/test_degrees.py ___________\ntests/db_functions/math/test_degrees.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_exp.py _____________\ntests/db_functions/math/test_exp.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_floor.py ____________\ntests/db_functions/math/test_floor.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_ln.py ______________\ntests/db_functions/math/test_ln.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_log.py _____________\ntests/db_functions/math/test_log.py:7: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_mod.py _____________\ntests/db_functions/math/test_mod.py:7: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_pi.py ______________\ntests/db_functions/math/test_pi.py:6: in <module>\n    from ..models import FloatModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_power.py ____________\ntests/db_functions/math/test_power.py:6: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/math/test_radians.py ___________\ntests/db_functions/math/test_radians.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_round.py ____________\ntests/db_functions/math/test_round.py:8: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_sign.py _____________\ntests/db_functions/math/test_sign.py:8: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_sin.py _____________\ntests/db_functions/math/test_sin.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/math/test_sqrt.py _____________\ntests/db_functions/math/test_sqrt.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/math/test_tan.py _____________\ntests/db_functions/math/test_tan.py:9: in <module>\n    from ..models import DecimalModel, FloatModel, IntegerModel\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/text/test_chr.py _____________\ntests/db_functions/text/test_chr.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_concat.py ____________\ntests/db_functions/text/test_concat.py:9: in <module>\n    from ..models import Article, Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/text/test_left.py _____________\ntests/db_functions/text/test_left.py:5: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_length.py ____________\ntests/db_functions/text/test_length.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/text/test_lower.py ____________\ntests/db_functions/text/test_lower.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/text/test_md5.py _____________\ntests/db_functions/text/test_md5.py:7: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/text/test_ord.py _____________\ntests/db_functions/text/test_ord.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/db_functions/text/test_pad.py _____________\ntests/db_functions/text/test_pad.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_repeat.py ____________\ntests/db_functions/text/test_repeat.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_replace.py ___________\ntests/db_functions/text/test_replace.py:5: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_reverse.py ___________\ntests/db_functions/text/test_reverse.py:7: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/text/test_right.py ____________\ntests/db_functions/text/test_right.py:5: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/text/test_sha1.py _____________\ntests/db_functions/text/test_sha1.py:7: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_sha224.py ____________\ntests/db_functions/text/test_sha224.py:10: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_sha256.py ____________\ntests/db_functions/text/test_sha256.py:7: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_sha384.py ____________\ntests/db_functions/text/test_sha384.py:7: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_sha512.py ____________\ntests/db_functions/text/test_sha512.py:7: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/db_functions/text/test_strindex.py ___________\ntests/db_functions/text/test_strindex.py:6: in <module>\n    from ..models import Article, Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/db_functions/text/test_substr.py ____________\ntests/db_functions/text/test_substr.py:5: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/text/test_trim.py _____________\ntests/db_functions/text/test_trim.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/db_functions/text/test_upper.py ____________\ntests/db_functions/text/test_upper.py:6: in <module>\n    from ..models import Author\ntests/db_functions/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________________ ERROR collecting tests/dbshell/test_oracle.py _________________\ntests/dbshell/test_oracle.py:9: in <module>\n    @skipUnless(connection.vendor == 'oracle', 'Oracle tests')\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/expressions/test_deprecation.py ____________\ntests/expressions/test_deprecation.py:5: in <module>\n    from .models import Employee\ntests/expressions/models.py:9: in <module>\n    class Employee(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/expressions/test_queryset_values.py __________\ntests/expressions/test_queryset_values.py:5: in <module>\n    from .models import Company, Employee\ntests/expressions/models.py:9: in <module>\n    class Employee(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/flatpages_tests/test_csrf.py ______________\ntests/flatpages_tests/test_csrf.py:1: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/flatpages_tests/test_forms.py _____________\ntests/flatpages_tests/test_forms.py:2: in <module>\n    from django.contrib.flatpages.forms import FlatpageForm\ndjango/contrib/flatpages/forms.py:3: in <module>\n    from django.contrib.flatpages.models import FlatPage\ndjango/contrib/flatpages/models.py:1: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/flatpages_tests/test_middleware.py ___________\ntests/flatpages_tests/test_middleware.py:2: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/flatpages_tests/test_models.py _____________\ntests/flatpages_tests/test_models.py:1: in <module>\n    from django.contrib.flatpages.models import FlatPage\ndjango/contrib/flatpages/models.py:1: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/flatpages_tests/test_sitemaps.py ____________\ntests/flatpages_tests/test_sitemaps.py:2: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/flatpages_tests/test_templatetags.py __________\ntests/flatpages_tests/test_templatetags.py:1: in <module>\n    from django.contrib.auth.models import AnonymousUser, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/flatpages_tests/test_views.py _____________\ntests/flatpages_tests/test_views.py:2: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____ ERROR collecting tests/foreign_object/test_agnostic_order_trimjoin.py _____\ntests/foreign_object/test_agnostic_order_trimjoin.py:5: in <module>\n    from .models import Address, Contact, Customer\ntests/foreign_object/models/__init__.py:1: in <module>\n    from .article import (\ntests/foreign_object/models/article.py:51: in <module>\n    class Article(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/foreign_object/test_empty_join.py ___________\ntests/foreign_object/test_empty_join.py:3: in <module>\n    from .models import SlugPage\ntests/foreign_object/models/__init__.py:1: in <module>\n    from .article import (\ntests/foreign_object/models/article.py:51: in <module>\n    class Article(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/foreign_object/test_forms.py ______________\ntests/foreign_object/test_forms.py:6: in <module>\n    from .models import Article\ntests/foreign_object/models/__init__.py:1: in <module>\n    from .article import (\ntests/foreign_object/models/article.py:51: in <module>\n    class Article(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______ ERROR collecting tests/forms_tests/tests/test_error_messages.py ________\ntests/forms_tests/tests/test_error_messages.py:13: in <module>\n    from ..models import ChoiceModel\ntests/forms_tests/models.py:18: in <module>\n    class BoundaryModel(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/forms_tests/tests/test_widgets.py ___________\ntests/forms_tests/tests/test_widgets.py:5: in <module>\n    from ..models import Article\ntests/forms_tests/models.py:18: in <module>\n    class BoundaryModel(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/generic_relations/test_forms.py ____________\ntests/generic_relations/test_forms.py:2: in <module>\n    from django.contrib.contenttypes.forms import generic_inlineformset_factory\ndjango/contrib/contenttypes/forms.py:1: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/generic_views/test_base.py _______________\ntests/generic_views/test_base.py:10: in <module>\n    from . import views\ntests/generic_views/views.py:7: in <module>\n    from .forms import AuthorForm, ContactForm\ntests/generic_views/forms.py:3: in <module>\n    from .models import Author\ntests/generic_views/models.py:7: in <module>\n    class Artist(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/generic_views/test_dates.py ______________\ntests/generic_views/test_dates.py:9: in <module>\n    from .models import Artist, Author, Book, BookSigning, Page\ntests/generic_views/models.py:7: in <module>\n    class Artist(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/generic_views/test_detail.py ______________\ntests/generic_views/test_detail.py:10: in <module>\n    from .models import Artist, Author, Book, Page\ntests/generic_views/models.py:7: in <module>\n    class Artist(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/generic_views/test_edit.py _______________\ntests/generic_views/test_edit.py:9: in <module>\n    from . import views\ntests/generic_views/views.py:7: in <module>\n    from .forms import AuthorForm, ContactForm\ntests/generic_views/forms.py:3: in <module>\n    from .models import Author\ntests/generic_views/models.py:7: in <module>\n    class Artist(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/generic_views/test_list.py _______________\ntests/generic_views/test_list.py:7: in <module>\n    from .models import Artist, Author, Book, Page\ntests/generic_views/models.py:7: in <module>\n    class Artist(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/gis_tests/test_fields.py ________________\ntests/gis_tests/test_fields.py:3: in <module>\n    from django.contrib.gis.db.models.fields import GeometryField\ndjango/contrib/gis/db/models/__init__.py:3: in <module>\n    import django.contrib.gis.db.models.functions  # NOQA\ndjango/contrib/gis/db/models/functions.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField\ndjango/contrib/gis/db/models/fields.py:3: in <module>\n    from django.contrib.gis import forms, gdal\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n______________ ERROR collecting tests/gis_tests/test_geoforms.py _______________\ntests/gis_tests/test_geoforms.py:3: in <module>\n    from django.contrib.gis import forms\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n_______________ ERROR collecting tests/gis_tests/test_geoip2.py ________________\ntests/gis_tests/test_geoip2.py:6: in <module>\n    from django.contrib.gis.geoip2 import HAS_GEOIP2\ndjango/contrib/gis/geoip2/__init__.py:21: in <module>\n    from .base import GeoIP2, GeoIP2Exception\ndjango/contrib/gis/geoip2/base.py:14: in <module>\n    'GEOIP_PATH': getattr(settings, 'GEOIP_PATH', None),\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting GEOIP_PATH, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/gis_tests/test_gis_tests_utils.py ___________\ntests/gis_tests/test_gis_tests_utils.py:5: in <module>\n    from .utils import FuncTestMixin\ntests/gis_tests/utils.py:45: in <module>\n    _default_db = settings.DATABASES[DEFAULT_DB_ALIAS]['ENGINE'].rsplit('.')[-1]\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/gis_tests/test_spatialrefsys.py ____________\ntests/gis_tests/test_spatialrefsys.py:5: in <module>\n    from .utils import SpatialRefSys, oracle, postgis, spatialite\ntests/gis_tests/utils.py:45: in <module>\n    _default_db = settings.DATABASES[DEFAULT_DB_ALIAS]['ENGINE'].rsplit('.')[-1]\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/gis_tests/gdal_tests/test_driver.py __________\ntests/gis_tests/gdal_tests/test_driver.py:4: in <module>\n    from django.contrib.gis.gdal import Driver, GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n____________ ERROR collecting tests/gis_tests/gdal_tests/test_ds.py ____________\ntests/gis_tests/gdal_tests/test_ds.py:5: in <module>\n    from django.contrib.gis.gdal import (\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n_________ ERROR collecting tests/gis_tests/gdal_tests/test_envelope.py _________\ntests/gis_tests/gdal_tests/test_envelope.py:3: in <module>\n    from django.contrib.gis.gdal import Envelope, GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n___________ ERROR collecting tests/gis_tests/gdal_tests/test_geom.py ___________\ntests/gis_tests/gdal_tests/test_geom.py:4: in <module>\n    from django.contrib.gis.gdal import (\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n__________ ERROR collecting tests/gis_tests/gdal_tests/test_raster.py __________\ntests/gis_tests/gdal_tests/test_raster.py:6: in <module>\n    from django.contrib.gis.gdal import GDAL_VERSION, GDALRaster\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n___________ ERROR collecting tests/gis_tests/gdal_tests/test_srs.py ____________\ntests/gis_tests/gdal_tests/test_srs.py:3: in <module>\n    from django.contrib.gis.gdal import (\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n_________ ERROR collecting tests/gis_tests/geoapp/test_expressions.py __________\ntests/gis_tests/geoapp/test_expressions.py:3: in <module>\n    from django.contrib.gis.db.models import F, GeometryField, Value, functions\ndjango/contrib/gis/db/models/__init__.py:3: in <module>\n    import django.contrib.gis.db.models.functions  # NOQA\ndjango/contrib/gis/db/models/functions.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField\ndjango/contrib/gis/db/models/fields.py:3: in <module>\n    from django.contrib.gis import forms, gdal\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n____________ ERROR collecting tests/gis_tests/geoapp/test_feeds.py _____________\ntests/gis_tests/geoapp/test_feeds.py:4: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/gis_tests/geoapp/test_functions.py ___________\ntests/gis_tests/geoapp/test_functions.py:6: in <module>\n    from django.contrib.gis.db.models import functions\ndjango/contrib/gis/db/models/__init__.py:3: in <module>\n    import django.contrib.gis.db.models.functions  # NOQA\ndjango/contrib/gis/db/models/functions.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField\ndjango/contrib/gis/db/models/fields.py:3: in <module>\n    from django.contrib.gis import forms, gdal\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n___________ ERROR collecting tests/gis_tests/geoapp/test_regress.py ____________\ntests/gis_tests/geoapp/test_regress.py:3: in <module>\n    from django.contrib.gis.db.models import Extent\ndjango/contrib/gis/db/models/__init__.py:3: in <module>\n    import django.contrib.gis.db.models.functions  # NOQA\ndjango/contrib/gis/db/models/functions.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField\ndjango/contrib/gis/db/models/fields.py:3: in <module>\n    from django.contrib.gis import forms, gdal\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n_________ ERROR collecting tests/gis_tests/geoapp/test_serializers.py __________\ntests/gis_tests/geoapp/test_serializers.py:3: in <module>\n    from django.contrib.gis.geos import LinearRing, Point, Polygon\ndjango/contrib/gis/geos/__init__.py:5: in <module>\n    from .collections import (  # NOQA\ndjango/contrib/gis/geos/collections.py:8: in <module>\n    from django.contrib.gis.geos.geometry import GEOSGeometry, LinearGeometryMixin\ndjango/contrib/gis/geos/geometry.py:8: in <module>\n    from django.contrib.gis import gdal\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n___________ ERROR collecting tests/gis_tests/geoapp/test_sitemaps.py ___________\ntests/gis_tests/geoapp/test_sitemaps.py:6: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/gis_tests/geos_tests/test_coordseq.py _________\ntests/gis_tests/geos_tests/test_coordseq.py:1: in <module>\n    from django.contrib.gis.geos import LineString\ndjango/contrib/gis/geos/__init__.py:5: in <module>\n    from .collections import (  # NOQA\ndjango/contrib/gis/geos/collections.py:8: in <module>\n    from django.contrib.gis.geos.geometry import GEOSGeometry, LinearGeometryMixin\ndjango/contrib/gis/geos/geometry.py:8: in <module>\n    from django.contrib.gis import gdal\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n___________ ERROR collecting tests/gis_tests/geos_tests/test_geos.py ___________\ntests/gis_tests/geos_tests/test_geos.py:10: in <module>\n    from django.contrib.gis import gdal\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n______ ERROR collecting tests/gis_tests/geos_tests/test_geos_mutation.py _______\ntests/gis_tests/geos_tests/test_geos_mutation.py:7: in <module>\n    from django.contrib.gis.geos import (\ndjango/contrib/gis/geos/__init__.py:5: in <module>\n    from .collections import (  # NOQA\ndjango/contrib/gis/geos/collections.py:8: in <module>\n    from django.contrib.gis.geos.geometry import GEOSGeometry, LinearGeometryMixin\ndjango/contrib/gis/geos/geometry.py:8: in <module>\n    from django.contrib.gis import gdal\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n____________ ERROR collecting tests/gis_tests/geos_tests/test_io.py ____________\ntests/gis_tests/geos_tests/test_io.py:3: in <module>\n    from django.contrib.gis.geos import (\ndjango/contrib/gis/geos/__init__.py:5: in <module>\n    from .collections import (  # NOQA\ndjango/contrib/gis/geos/collections.py:8: in <module>\n    from django.contrib.gis.geos.geometry import GEOSGeometry, LinearGeometryMixin\ndjango/contrib/gis/geos/geometry.py:8: in <module>\n    from django.contrib.gis import gdal\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n_______ ERROR collecting tests/gis_tests/geos_tests/test_mutable_list.py _______\ntests/gis_tests/geos_tests/test_mutable_list.py:9: in <module>\n    from django.contrib.gis.geos.mutable_list import ListMixin\ndjango/contrib/gis/geos/__init__.py:5: in <module>\n    from .collections import (  # NOQA\ndjango/contrib/gis/geos/collections.py:8: in <module>\n    from django.contrib.gis.geos.geometry import GEOSGeometry, LinearGeometryMixin\ndjango/contrib/gis/geos/geometry.py:8: in <module>\n    from django.contrib.gis import gdal\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n______ ERROR collecting tests/gis_tests/gis_migrations/test_operations.py ______\ntests/gis_tests/gis_migrations/test_operations.py:3: in <module>\n    from django.contrib.gis.db.models import fields\ndjango/contrib/gis/db/models/__init__.py:3: in <module>\n    import django.contrib.gis.db.models.functions  # NOQA\ndjango/contrib/gis/db/models/functions.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField\ndjango/contrib/gis/db/models/fields.py:3: in <module>\n    from django.contrib.gis import forms, gdal\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n________ ERROR collecting tests/gis_tests/rasterapp/test_rasterfield.py ________\ntests/gis_tests/rasterapp/test_rasterfield.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField\ndjango/contrib/gis/db/models/__init__.py:3: in <module>\n    import django.contrib.gis.db.models.functions  # NOQA\ndjango/contrib/gis/db/models/functions.py:3: in <module>\n    from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField\ndjango/contrib/gis/db/models/fields.py:3: in <module>\n    from django.contrib.gis import forms, gdal\ndjango/contrib/gis/forms/__init__.py:3: in <module>\n    from .fields import (  # NOQA\ndjango/contrib/gis/forms/fields.py:2: in <module>\n    from django.contrib.gis.gdal import GDALException\ndjango/contrib/gis/gdal/__init__.py:28: in <module>\n    from django.contrib.gis.gdal.datasource import DataSource\ndjango/contrib/gis/gdal/datasource.py:39: in <module>\n    from django.contrib.gis.gdal.driver import Driver\ndjango/contrib/gis/gdal/driver.py:5: in <module>\n    from django.contrib.gis.gdal.prototypes import ds as vcapi, raster as rcapi\ndjango/contrib/gis/gdal/prototypes/ds.py:9: in <module>\n    from django.contrib.gis.gdal.libgdal import GDAL_VERSION, lgdal\ndjango/contrib/gis/gdal/libgdal.py:42: in <module>\n    % '\", \"'.join(lib_names)\nE   django.core.exceptions.ImproperlyConfigured: Could not find the GDAL library (tried \"gdal\", \"GDAL\", \"gdal2.4.0\", \"gdal2.3.0\", \"gdal2.2.0\", \"gdal2.1.0\", \"gdal2.0.0\"). Is GDAL installed? If it is, try setting GDAL_LIBRARY_PATH in your settings.\n__________ ERROR collecting tests/invalid_models_tests/test_models.py __________\ntests/invalid_models_tests/test_models.py:334: in <module>\n    class FieldNamesTests(SimpleTestCase):\ntests/invalid_models_tests/test_models.py:354: in FieldNamesTests\n    max_column_name_length, column_limit_db_alias = get_max_column_name_length()\ntests/invalid_models_tests/test_models.py:18: in get_max_column_name_length\n    for db in settings.DATABASES:\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____ ERROR collecting tests/invalid_models_tests/test_ordinary_fields.py ______\ntests/invalid_models_tests/test_ordinary_fields.py:85: in <module>\n    class CharFieldTests(SimpleTestCase):\ntests/invalid_models_tests/test_ordinary_fields.py:363: in CharFieldTests\n    @unittest.skipUnless(connection.vendor == 'mysql',\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/lookup/test_decimalfield.py ______________\ntests/lookup/test_decimalfield.py:5: in <module>\n    from .models import Product, Stock\ntests/lookup/models.py:11: in <module>\n    class Alarm(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/lookup/test_timefield.py ________________\ntests/lookup/test_timefield.py:3: in <module>\n    from .models import Alarm\ntests/lookup/models.py:11: in <module>\n    class Alarm(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________ ERROR collecting tests/m2m_through_regress/test_multitable.py _________\ntests/m2m_through_regress/test_multitable.py:3: in <module>\n    from .models import (\ntests/m2m_through_regress/models.py:1: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/messages_tests/test_cookie.py _____________\ntests/messages_tests/test_cookie.py:4: in <module>\n    from django.contrib.messages.storage.base import Message\ndjango/contrib/messages/storage/base.py:4: in <module>\n    LEVEL_TAGS = utils.get_level_tags()\ndjango/contrib/messages/utils.py:11: in get_level_tags\n    **getattr(settings, 'MESSAGE_TAGS', {}),\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting MESSAGE_TAGS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/messages_tests/test_fallback.py ____________\ntests/messages_tests/test_fallback.py:2: in <module>\n    from django.contrib.messages.storage.fallback import (\ndjango/contrib/messages/storage/fallback.py:1: in <module>\n    from django.contrib.messages.storage.base import BaseStorage\ndjango/contrib/messages/storage/base.py:4: in <module>\n    LEVEL_TAGS = utils.get_level_tags()\ndjango/contrib/messages/utils.py:11: in get_level_tags\n    **getattr(settings, 'MESSAGE_TAGS', {}),\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting MESSAGE_TAGS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/messages_tests/test_session.py _____________\ntests/messages_tests/test_session.py:2: in <module>\n    from django.contrib.messages.storage.base import Message\ndjango/contrib/messages/storage/base.py:4: in <module>\n    LEVEL_TAGS = utils.get_level_tags()\ndjango/contrib/messages/utils.py:11: in get_level_tags\n    **getattr(settings, 'MESSAGE_TAGS', {}),\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting MESSAGE_TAGS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/migrations/test_autodetector.py ____________\ntests/migrations/test_autodetector.py:7: in <module>\n    from django.contrib.auth.models import AbstractBaseUser\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/migrations/test_commands.py ______________\ntests/migrations/test_commands.py:19: in <module>\n    from .models import UnicodeModel, UnserializableModel\ntests/migrations/models.py:9: in <module>\n    class ModelWithCustomBase(models.Model, metaclass=CustomModelBase):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/migrations/test_operations.py _____________\ntests/migrations/test_operations.py:12: in <module>\n    from .models import FoodManager, FoodQuerySet, UnicodeModel\ntests/migrations/models.py:9: in <module>\n    class ModelWithCustomBase(models.Model, metaclass=CustomModelBase):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/migrations/test_optimizer.py ______________\ntests/migrations/test_optimizer.py:7: in <module>\n    from .models import EmptyManager, UnicodeModel\ntests/migrations/models.py:9: in <module>\n    class ModelWithCustomBase(models.Model, metaclass=CustomModelBase):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/migrations/test_state.py ________________\ntests/migrations/test_state.py:2: in <module>\n    from django.contrib.contenttypes.fields import GenericForeignKey\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/migrations/test_writer.py _______________\ntests/migrations/test_writer.py:26: in <module>\n    from .models import FoodManager, FoodQuerySet\ntests/migrations/models.py:9: in <module>\n    class ModelWithCustomBase(models.Model, metaclass=CustomModelBase):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_autofield.py _____________\ntests/model_fields/test_autofield.py:4: in <module>\n    from .models import AutoModel, BigAutoModel, SmallAutoModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/model_fields/test_binaryfield.py ____________\ntests/model_fields/test_binaryfield.py:5: in <module>\n    from .models import DataModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/model_fields/test_booleanfield.py ___________\ntests/model_fields/test_booleanfield.py:6: in <module>\n    from .models import BooleanModel, FksToBooleans, NullBooleanModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_charfield.py _____________\ntests/model_fields/test_charfield.py:7: in <module>\n    from .models import Post\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/model_fields/test_datetimefield.py ___________\ntests/model_fields/test_datetimefield.py:10: in <module>\n    from .models import DateTimeModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/model_fields/test_decimalfield.py ___________\ntests/model_fields/test_decimalfield.py:9: in <module>\n    from .models import BigD, Foo\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/model_fields/test_durationfield.py ___________\ntests/model_fields/test_durationfield.py:9: in <module>\n    from .models import DurationModel, NullDurationModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/model_fields/test_field_flags.py ____________\ntests/model_fields/test_field_flags.py:2: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_filefield.py _____________\ntests/model_fields/test_filefield.py:13: in <module>\n    from .models import Document\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_floatfield.py ____________\ntests/model_fields/test_floatfield.py:4: in <module>\n    from .models import FloatModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_foreignkey.py ____________\ntests/model_fields/test_foreignkey.py:9: in <module>\n    from .models import Bar, FkToChar, Foo, PrimaryKeyCharModel\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______ ERROR collecting tests/model_fields/test_genericipaddressfield.py _______\ntests/model_fields/test_genericipaddressfield.py:5: in <module>\n    from .models import GenericIPAddress\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/model_fields/test_integerfield.py ___________\ntests/model_fields/test_integerfield.py:8: in <module>\n    from .models import (\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/model_fields/test_manytomanyfield.py __________\ntests/model_fields/test_manytomanyfield.py:6: in <module>\n    from .models import ManyToMany\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_slugfield.py _____________\ntests/model_fields/test_slugfield.py:3: in <module>\n    from .models import BigS, UnicodeSlugField\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/model_fields/test_textfield.py _____________\ntests/model_fields/test_textfield.py:7: in <module>\n    from .models import Post\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/model_fields/test_uuid.py _______________\ntests/model_fields/test_uuid.py:12: in <module>\n    from .models import (\ntests/model_fields/models.py:5: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/model_forms/test_modelchoicefield.py __________\ntests/model_forms/test_modelchoicefield.py:10: in <module>\n    from .models import Article, Author, Book, Category, Writer\ntests/model_forms/models.py:15: in <module>\n    class Person(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/model_forms/test_uuid.py ________________\ntests/model_forms/test_uuid.py:5: in <module>\n    from .models import UUIDPK\ntests/model_forms/models.py:15: in <module>\n    class Person(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/model_formsets/test_uuid.py ______________\ntests/model_formsets/test_uuid.py:4: in <module>\n    from .models import (\ntests/model_formsets/models.py:7: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____ ERROR collecting tests/model_inheritance/test_abstract_inheritance.py _____\ntests/model_inheritance/test_abstract_inheritance.py:1: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______ ERROR collecting tests/model_options/test_default_related_name.py _______\ntests/model_options/test_default_related_name.py:4: in <module>\n    from .models.default_related_name import Author, Book, Editor\ntests/model_options/models/default_related_name.py:4: in <module>\n    class Author(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/model_options/test_tablespaces.py ___________\ntests/model_options/test_tablespaces.py:8: in <module>\n    from .models.tablespaces import (\ntests/model_options/models/tablespaces.py:11: in <module>\n    class ScientistRef(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/modeladmin/test_actions.py _______________\ntests/modeladmin/test_actions.py:2: in <module>\n    from django.contrib.auth.models import Permission, User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/modeladmin/test_checks.py _______________\ntests/modeladmin/test_checks.py:11: in <module>\n    from .models import (\ntests/modeladmin/models.py:1: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/postgres_tests/test_aggregates.py ___________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/postgres_tests/test_apps.py ______________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/postgres_tests/test_array.py ______________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/postgres_tests/test_bulk_update.py ___________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/postgres_tests/test_citext.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/postgres_tests/test_constraints.py ___________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/postgres_tests/test_functions.py ____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/postgres_tests/test_hstore.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/postgres_tests/test_indexes.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/postgres_tests/test_integration.py ___________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/postgres_tests/test_introspection.py __________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/postgres_tests/test_json.py ______________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/postgres_tests/test_operations.py ___________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/postgres_tests/test_ranges.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/postgres_tests/test_search.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/postgres_tests/test_signals.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/postgres_tests/test_trigram.py _____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/postgres_tests/test_unaccent.py ____________\n/opt/miniconda3/envs/testbed/lib/python3.6/importlib/__init__.py:126: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:941: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\n<frozen importlib._bootstrap>:994: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:971: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:955: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:665: in _load_unlocked\n    ???\n<frozen importlib._bootstrap_external>:678: in exec_module\n    ???\n<frozen importlib._bootstrap>:219: in _call_with_frames_removed\n    ???\ntests/postgres_tests/__init__.py:9: in <module>\n    @unittest.skipUnless(connection.vendor == 'postgresql', \"PostgreSQL specific tests\")\ndjango/db/__init__.py:28: in __getattr__\n    return getattr(connections[DEFAULT_DB_ALIAS], item)\ndjango/db/utils.py:204: in __getitem__\n    self.ensure_defaults(alias)\ndjango/db/utils.py:172: in ensure_defaults\n    conn = self.databases[alias]\ndjango/utils/functional.py:48: in __get__\n    res = instance.__dict__[self.name] = self.func(instance)\ndjango/db/utils.py:153: in databases\n    self._databases = settings.DATABASES\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting DATABASES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___ ERROR collecting tests/prefetch_related/test_prefetch_related_objects.py ___\ntests/prefetch_related/test_prefetch_related_objects.py:4: in <module>\n    from .models import Author, Book, Reader\ntests/prefetch_related/models.py:3: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/prefetch_related/test_uuid.py _____________\ntests/prefetch_related/test_uuid.py:3: in <module>\n    from .models import Flea, House, Person, Pet, Room\ntests/prefetch_related/models.py:3: in <module>\n    from django.contrib.contenttypes.fields import (\ndjango/contrib/contenttypes/fields.py:6: in <module>\n    from django.contrib.contenttypes.models import ContentType\ndjango/contrib/contenttypes/models.py:133: in <module>\n    class ContentType(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/queries/test_bulk_update.py ______________\ntests/queries/test_bulk_update.py:8: in <module>\n    from .models import (\ntests/queries/models.py:10: in <module>\n    class DumbCategory(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/queries/test_db_returning.py ______________\ntests/queries/test_db_returning.py:7: in <module>\n    from .models import DumbCategory, NonIntegerPKReturningModel, ReturningModel\ntests/queries/models.py:10: in <module>\n    class DumbCategory(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________________ ERROR collecting tests/queries/test_explain.py ________________\ntests/queries/test_explain.py:8: in <module>\n    from .models import Tag\ntests/queries/models.py:10: in <module>\n    class DumbCategory(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/queries/test_iterator.py ________________\ntests/queries/test_iterator.py:8: in <module>\n    from .models import Article\ntests/queries/models.py:10: in <module>\n    class DumbCategory(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/queries/test_qs_combinators.py _____________\ntests/queries/test_qs_combinators.py:6: in <module>\n    from .models import Number, ReservedName\ntests/queries/models.py:10: in <module>\n    class DumbCategory(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________________ ERROR collecting tests/queries/test_query.py _________________\ntests/queries/test_query.py:14: in <module>\n    from .models import Author, Item, ObjectC, Ranking\ntests/queries/models.py:10: in <module>\n    class DumbCategory(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/serializers/test_data.py ________________\ntests/serializers/test_data.py:17: in <module>\n    from .models import (\ntests/serializers/models/__init__.py:1: in <module>\n    from .base import *  # NOQA\ntests/serializers/models/base.py:18: in <module>\n    class CategoryMetaData(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________ ERROR collecting tests/serializers/test_deserializedobject.py _________\ntests/serializers/test_deserializedobject.py:4: in <module>\n    from .models import Author\ntests/serializers/models/__init__.py:1: in <module>\n    from .base import *  # NOQA\ntests/serializers/models/base.py:18: in <module>\n    class CategoryMetaData(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/serializers/test_json.py ________________\ntests/serializers/test_json.py:14: in <module>\n    from .models import Score\ntests/serializers/models/__init__.py:1: in <module>\n    from .base import *  # NOQA\ntests/serializers/models/base.py:18: in <module>\n    class CategoryMetaData(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/serializers/test_natural.py ______________\ntests/serializers/test_natural.py:5: in <module>\n    from .models import (\ntests/serializers/models/__init__.py:1: in <module>\n    from .base import *  # NOQA\ntests/serializers/models/base.py:18: in <module>\n    class CategoryMetaData(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________________ ERROR collecting tests/serializers/test_xml.py ________________\ntests/serializers/test_xml.py:7: in <module>\n    from .tests import SerializersTestBase, SerializersTransactionTestBase\ntests/serializers/tests.py:14: in <module>\n    from .models import (\ntests/serializers/models/__init__.py:1: in <module>\n    from .base import *  # NOQA\ntests/serializers/models/base.py:18: in <module>\n    class CategoryMetaData(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/serializers/test_yaml.py ________________\ntests/serializers/test_yaml.py:9: in <module>\n    from .models import Author\ntests/serializers/models/__init__.py:1: in <module>\n    from .base import *  # NOQA\ntests/serializers/models/base.py:18: in <module>\n    class CategoryMetaData(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/sitemaps_tests/test_generic.py _____________\ntests/sitemaps_tests/test_generic.py:6: in <module>\n    from .base import SitemapTestsBase\ntests/sitemaps_tests/base.py:2: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/sitemaps_tests/test_http.py ______________\ntests/sitemaps_tests/test_http.py:7: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/sitemaps_tests/test_https.py ______________\ntests/sitemaps_tests/test_https.py:5: in <module>\n    from .base import SitemapTestsBase\ntests/sitemaps_tests/base.py:2: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/sitemaps_tests/test_management.py ___________\ntests/sitemaps_tests/test_management.py:5: in <module>\n    from .base import SitemapTestsBase\ntests/sitemaps_tests/base.py:2: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/sitemaps_tests/test_utils.py ______________\ntests/sitemaps_tests/test_utils.py:10: in <module>\n    from .base import SitemapTestsBase\ntests/sitemaps_tests/base.py:2: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/staticfiles_tests/test_checks.py ____________\ntests/staticfiles_tests/test_checks.py:10: in <module>\n    class FindersCheckTests(SimpleTestCase):\ntests/staticfiles_tests/test_checks.py:59: in FindersCheckTests\n    @override_settings(STATICFILES_DIRS=['/fake/path', settings.STATIC_ROOT])\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting STATIC_ROOT, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/template_tests/test_custom.py _____________\ntests/template_tests/test_custom.py:9: in <module>\n    from .templatetags import custom, inclusion\ntests/template_tests/templatetags/inclusion.py:18: in <module>\n    @register.inclusion_tag(engine.get_template('inclusion.html'))\ndjango/template/engine.py:143: in get_template\n    template, origin = self.find_template(template_name)\ndjango/template/engine.py:125: in find_template\n    template = loader.get_template(name, skip=skip)\ndjango/template/loaders/cached.py:53: in get_template\n    template = super().get_template(template_name, skip)\ndjango/template/loaders/base.py:18: in get_template\n    for origin in self.get_template_sources(template_name):\ndjango/template/loaders/cached.py:64: in get_template_sources\n    yield from loader.get_template_sources(template_name)\ndjango/template/loaders/filesystem.py:34: in get_template_sources\n    for template_dir in self.get_dirs():\ndjango/template/loaders/app_directories.py:14: in get_dirs\n    return get_app_template_dirs('templates')\ndjango/template/utils.py:103: in get_app_template_dirs\n    for app_config in apps.get_app_configs()\ndjango/apps/registry.py:144: in get_app_configs\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__ ERROR collecting tests/template_tests/syntax_tests/i18n/test_blocktrans.py __\ntests/template_tests/syntax_tests/i18n/test_blocktrans.py:12: in <module>\n    from .base import MultipleLocaleActivationTestCase, extended_locale_paths, here\ntests/template_tests/syntax_tests/i18n/base.py:9: in <module>\n    extended_locale_paths = settings.LOCALE_PATHS + [\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting LOCALE_PATHS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____ ERROR collecting tests/template_tests/syntax_tests/i18n/test_trans.py _____\ntests/template_tests/syntax_tests/i18n/test_trans.py:11: in <module>\n    from .base import MultipleLocaleActivationTestCase, extended_locale_paths\ntests/template_tests/syntax_tests/i18n/base.py:9: in <module>\n    extended_locale_paths = settings.LOCALE_PATHS + [\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting LOCALE_PATHS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_ ERROR collecting tests/template_tests/syntax_tests/i18n/test_underscore_syntax.py _\ntests/template_tests/syntax_tests/i18n/test_underscore_syntax.py:6: in <module>\n    from .base import MultipleLocaleActivationTestCase\ntests/template_tests/syntax_tests/i18n/base.py:9: in <module>\n    extended_locale_paths = settings.LOCALE_PATHS + [\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting LOCALE_PATHS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/test_runner/test_debug_sql.py _____________\ntests/test_runner/test_debug_sql.py:8: in <module>\n    from .models import Person\ntests/test_runner/models.py:4: in <module>\n    class Person(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n______________ ERROR collecting tests/test_utils/test_testcase.py ______________\ntests/test_utils/test_testcase.py:4: in <module>\n    from .models import Car, PossessedCar\ntests/test_utils/models.py:4: in <module>\n    class Car(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n________ ERROR collecting tests/test_utils/test_transactiontestcase.py _________\ntests/test_utils/test_transactiontestcase.py:6: in <module>\n    from .models import Car\ntests/test_utils/models.py:4: in <module>\n    class Car(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/utils_tests/test_lazyobject.py _____________\ntests/utils_tests/test_lazyobject.py:9: in <module>\n    from .models import Category, CategoryInfo\ntests/utils_tests/models.py:4: in <module>\n    class Category(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_________ ERROR collecting tests/utils_tests/test_simplelazyobject.py __________\ntests/utils_tests/test_simplelazyobject.py:3: in <module>\n    from django.contrib.auth.models import User\ndjango/contrib/auth/models.py:2: in <module>\n    from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager\ndjango/contrib/auth/base_user.py:47: in <module>\n    class AbstractBaseUser(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n__________ ERROR collecting tests/validation/test_custom_messages.py ___________\ntests/validation/test_custom_messages.py:4: in <module>\n    from .models import CustomMessagesModel\ntests/validation/models.py:12: in <module>\n    class ModelToValidate(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_______________ ERROR collecting tests/validation/test_unique.py _______________\ntests/validation/test_unique.py:9: in <module>\n    from .models import (\ntests/validation/models.py:12: in <module>\n    class ModelToValidate(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/validation/test_validators.py _____________\ntests/validation/test_validators.py:4: in <module>\n    from .models import ModelToValidate\ntests/validation/models.py:12: in <module>\n    class ModelToValidate(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n___________ ERROR collecting tests/view_tests/tests/test_defaults.py ___________\ntests/view_tests/tests/test_defaults.py:3: in <module>\n    from django.contrib.sites.models import Site\ndjango/contrib/sites/models.py:78: in <module>\n    class Site(models.Model):\ndjango/db/models/base.py:108: in __new__\n    app_config = apps.get_containing_app_config(module)\ndjango/apps/registry.py:252: in get_containing_app_config\n    self.check_apps_ready()\ndjango/apps/registry.py:134: in check_apps_ready\n    settings.INSTALLED_APPS\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n_____________ ERROR collecting tests/view_tests/tests/test_i18n.py _____________\ntests/view_tests/tests/test_i18n.py:18: in <module>\n    from ..urls import locale_dir\ntests/view_tests/urls.py:55: in <module>\n    re_path(_(r'^translated/$'), views.index_page, name='i18n_prefixed'),\ndjango/conf/urls/i18n.py:13: in i18n_patterns\n    if not settings.USE_I18N:\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting USE_I18N, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n____________ ERROR collecting tests/view_tests/tests/test_static.py ____________\ntests/view_tests/tests/test_static.py:13: in <module>\n    from .. import urls\ntests/view_tests/urls.py:55: in <module>\n    re_path(_(r'^translated/$'), views.index_page, name='i18n_prefixed'),\ndjango/conf/urls/i18n.py:13: in i18n_patterns\n    if not settings.USE_I18N:\ndjango/conf/__init__.py:77: in __getattr__\n    self._setup(name)\ndjango/conf/__init__.py:62: in _setup\n    % (desc, ENVIRONMENT_VARIABLE))\nE   django.core.exceptions.ImproperlyConfigured: Requested setting USE_I18N, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.\n=========================== short test summary info ============================\nERROR tests/admin_changelist/test_date_hierarchy.py - django.core.exceptions....\nERROR tests/admin_docs/test_middleware.py - django.core.exceptions.Improperly...\nERROR tests/admin_docs/test_utils.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/admin_docs/test_views.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/admin_utils/test_logentry.py - django.core.exceptions.ImproperlyC...\nERROR tests/admin_views/test_actions.py - django.core.exceptions.ImproperlyCo...\nERROR tests/admin_views/test_adminsite.py - django.core.exceptions.Improperly...\nERROR tests/admin_views/test_autocomplete_view.py - django.core.exceptions.Im...\nERROR tests/admin_views/test_forms.py - django.core.exceptions.ImproperlyConf...\nERROR tests/admin_views/test_history_view.py - django.core.exceptions.Imprope...\nERROR tests/admin_views/test_multidb.py - django.core.exceptions.ImproperlyCo...\nERROR tests/admin_views/test_templatetags.py - django.core.exceptions.Imprope...\nERROR tests/admin_widgets/test_autocomplete_widget.py - django.core.exception...\nERROR tests/aggregation/test_filter_argument.py - django.core.exceptions.Impr...\nERROR tests/auth_tests/test_admin_multidb.py - django.core.exceptions.Imprope...\nERROR tests/auth_tests/test_auth_backends.py - django.core.exceptions.Imprope...\nERROR tests/auth_tests/test_basic.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/auth_tests/test_checks.py - django.core.exceptions.ImproperlyConf...\nERROR tests/auth_tests/test_context_processors.py - django.core.exceptions.Im...\nERROR tests/auth_tests/test_decorators.py - django.core.exceptions.Improperly...\nERROR tests/auth_tests/test_forms.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/auth_tests/test_handlers.py - django.core.exceptions.ImproperlyCo...\nERROR tests/auth_tests/test_management.py - django.core.exceptions.Improperly...\nERROR tests/auth_tests/test_middleware.py - django.core.exceptions.Improperly...\nERROR tests/auth_tests/test_migrations.py - django.core.exceptions.Improperly...\nERROR tests/auth_tests/test_mixins.py - django.core.exceptions.ImproperlyConf...\nERROR tests/auth_tests/test_models.py - django.core.exceptions.ImproperlyConf...\nERROR tests/auth_tests/test_password_reset_timeout_days.py - django.core.exce...\nERROR tests/auth_tests/test_remote_user.py - django.core.exceptions.Improperl...\nERROR tests/auth_tests/test_signals.py - django.core.exceptions.ImproperlyCon...\nERROR tests/auth_tests/test_templates.py - django.core.exceptions.ImproperlyC...\nERROR tests/auth_tests/test_tokens.py - django.core.exceptions.ImproperlyConf...\nERROR tests/auth_tests/test_validators.py - django.core.exceptions.Improperly...\nERROR tests/auth_tests/test_views.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/backends/base/test_base.py - django.core.exceptions.ImproperlyCon...\nERROR tests/backends/mysql/test_creation.py - django.core.exceptions.Improper...\nERROR tests/backends/mysql/test_features.py - django.core.exceptions.Improper...\nERROR tests/backends/mysql/test_introspection.py - django.core.exceptions.Imp...\nERROR tests/backends/mysql/test_schema.py - django.core.exceptions.Improperly...\nERROR tests/backends/oracle/test_creation.py - django.core.exceptions.Imprope...\nERROR tests/backends/oracle/test_introspection.py - django.core.exceptions.Im...\nERROR tests/backends/oracle/test_operations.py - django.core.exceptions.Impro...\nERROR tests/backends/postgresql/test_creation.py - django.core.exceptions.Imp...\nERROR tests/backends/postgresql/test_introspection.py - django.core.exception...\nERROR tests/backends/postgresql/test_server_side_cursors.py - django.core.exc...\nERROR tests/backends/sqlite/test_introspection.py - django.core.exceptions.Im...\nERROR tests/check_framework/test_database.py - django.core.exceptions.Imprope...\nERROR tests/check_framework/test_model_checks.py - django.core.exceptions.Imp...\nERROR tests/contenttypes_tests/test_checks.py - django.core.exceptions.Improp...\nERROR tests/contenttypes_tests/test_fields.py - django.core.exceptions.Improp...\nERROR tests/contenttypes_tests/test_management.py - django.core.exceptions.Im...\nERROR tests/contenttypes_tests/test_models.py - django.core.exceptions.Improp...\nERROR tests/contenttypes_tests/test_operations.py - django.core.exceptions.Im...\nERROR tests/contenttypes_tests/test_order_with_respect_to.py - django.core.ex...\nERROR tests/contenttypes_tests/test_views.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/comparison/test_cast.py - django.core.exceptions.Imp...\nERROR tests/db_functions/comparison/test_coalesce.py - django.core.exceptions...\nERROR tests/db_functions/comparison/test_greatest.py - django.core.exceptions...\nERROR tests/db_functions/comparison/test_least.py - django.core.exceptions.Im...\nERROR tests/db_functions/comparison/test_nullif.py - django.core.exceptions.I...\nERROR tests/db_functions/datetime/test_extract_trunc.py - django.core.excepti...\nERROR tests/db_functions/datetime/test_now.py - django.core.exceptions.Improp...\nERROR tests/db_functions/math/test_abs.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_acos.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/math/test_asin.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/math/test_atan.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/math/test_atan2.py - django.core.exceptions.Improper...\nERROR tests/db_functions/math/test_ceil.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/math/test_cos.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_cot.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_degrees.py - django.core.exceptions.Improp...\nERROR tests/db_functions/math/test_exp.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_floor.py - django.core.exceptions.Improper...\nERROR tests/db_functions/math/test_ln.py - django.core.exceptions.ImproperlyC...\nERROR tests/db_functions/math/test_log.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_mod.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_pi.py - django.core.exceptions.ImproperlyC...\nERROR tests/db_functions/math/test_power.py - django.core.exceptions.Improper...\nERROR tests/db_functions/math/test_radians.py - django.core.exceptions.Improp...\nERROR tests/db_functions/math/test_round.py - django.core.exceptions.Improper...\nERROR tests/db_functions/math/test_sign.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/math/test_sin.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/math/test_sqrt.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/math/test_tan.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/text/test_chr.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/text/test_concat.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_left.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/text/test_length.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_lower.py - django.core.exceptions.Improper...\nERROR tests/db_functions/text/test_md5.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/text/test_ord.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/text/test_pad.py - django.core.exceptions.Improperly...\nERROR tests/db_functions/text/test_repeat.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_replace.py - django.core.exceptions.Improp...\nERROR tests/db_functions/text/test_reverse.py - django.core.exceptions.Improp...\nERROR tests/db_functions/text/test_right.py - django.core.exceptions.Improper...\nERROR tests/db_functions/text/test_sha1.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/text/test_sha224.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_sha256.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_sha384.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_sha512.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_strindex.py - django.core.exceptions.Impro...\nERROR tests/db_functions/text/test_substr.py - django.core.exceptions.Imprope...\nERROR tests/db_functions/text/test_trim.py - django.core.exceptions.Improperl...\nERROR tests/db_functions/text/test_upper.py - django.core.exceptions.Improper...\nERROR tests/dbshell/test_oracle.py - django.core.exceptions.ImproperlyConfigu...\nERROR tests/expressions/test_deprecation.py - django.core.exceptions.Improper...\nERROR tests/expressions/test_queryset_values.py - django.core.exceptions.Impr...\nERROR tests/flatpages_tests/test_csrf.py - django.core.exceptions.ImproperlyC...\nERROR tests/flatpages_tests/test_forms.py - django.core.exceptions.Improperly...\nERROR tests/flatpages_tests/test_middleware.py - django.core.exceptions.Impro...\nERROR tests/flatpages_tests/test_models.py - django.core.exceptions.Improperl...\nERROR tests/flatpages_tests/test_sitemaps.py - django.core.exceptions.Imprope...\nERROR tests/flatpages_tests/test_templatetags.py - django.core.exceptions.Imp...\nERROR tests/flatpages_tests/test_views.py - django.core.exceptions.Improperly...\nERROR tests/foreign_object/test_agnostic_order_trimjoin.py - django.core.exce...\nERROR tests/foreign_object/test_empty_join.py - django.core.exceptions.Improp...\nERROR tests/foreign_object/test_forms.py - django.core.exceptions.ImproperlyC...\nERROR tests/forms_tests/tests/test_error_messages.py - django.core.exceptions...\nERROR tests/forms_tests/tests/test_widgets.py - django.core.exceptions.Improp...\nERROR tests/generic_relations/test_forms.py - django.core.exceptions.Improper...\nERROR tests/generic_views/test_base.py - django.core.exceptions.ImproperlyCon...\nERROR tests/generic_views/test_dates.py - django.core.exceptions.ImproperlyCo...\nERROR tests/generic_views/test_detail.py - django.core.exceptions.ImproperlyC...\nERROR tests/generic_views/test_edit.py - django.core.exceptions.ImproperlyCon...\nERROR tests/generic_views/test_list.py - django.core.exceptions.ImproperlyCon...\nERROR tests/gis_tests/test_fields.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/gis_tests/test_geoforms.py - django.core.exceptions.ImproperlyCon...\nERROR tests/gis_tests/test_geoip2.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/gis_tests/test_gis_tests_utils.py - django.core.exceptions.Improp...\nERROR tests/gis_tests/test_spatialrefsys.py - django.core.exceptions.Improper...\nERROR tests/gis_tests/gdal_tests/test_driver.py - django.core.exceptions.Impr...\nERROR tests/gis_tests/gdal_tests/test_ds.py - django.core.exceptions.Improper...\nERROR tests/gis_tests/gdal_tests/test_envelope.py - django.core.exceptions.Im...\nERROR tests/gis_tests/gdal_tests/test_geom.py - django.core.exceptions.Improp...\nERROR tests/gis_tests/gdal_tests/test_raster.py - django.core.exceptions.Impr...\nERROR tests/gis_tests/gdal_tests/test_srs.py - django.core.exceptions.Imprope...\nERROR tests/gis_tests/geoapp/test_expressions.py - django.core.exceptions.Imp...\nERROR tests/gis_tests/geoapp/test_feeds.py - django.core.exceptions.Improperl...\nERROR tests/gis_tests/geoapp/test_functions.py - django.core.exceptions.Impro...\nERROR tests/gis_tests/geoapp/test_regress.py - django.core.exceptions.Imprope...\nERROR tests/gis_tests/geoapp/test_serializers.py - django.core.exceptions.Imp...\nERROR tests/gis_tests/geoapp/test_sitemaps.py - django.core.exceptions.Improp...\nERROR tests/gis_tests/geos_tests/test_coordseq.py - django.core.exceptions.Im...\nERROR tests/gis_tests/geos_tests/test_geos.py - django.core.exceptions.Improp...\nERROR tests/gis_tests/geos_tests/test_geos_mutation.py - django.core.exceptio...\nERROR tests/gis_tests/geos_tests/test_io.py - django.core.exceptions.Improper...\nERROR tests/gis_tests/geos_tests/test_mutable_list.py - django.core.exception...\nERROR tests/gis_tests/gis_migrations/test_operations.py - django.core.excepti...\nERROR tests/gis_tests/rasterapp/test_rasterfield.py - django.core.exceptions....\nERROR tests/invalid_models_tests/test_models.py - django.core.exceptions.Impr...\nERROR tests/invalid_models_tests/test_ordinary_fields.py - django.core.except...\nERROR tests/lookup/test_decimalfield.py - django.core.exceptions.ImproperlyCo...\nERROR tests/lookup/test_timefield.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/m2m_through_regress/test_multitable.py - django.core.exceptions.I...\nERROR tests/messages_tests/test_cookie.py - django.core.exceptions.Improperly...\nERROR tests/messages_tests/test_fallback.py - django.core.exceptions.Improper...\nERROR tests/messages_tests/test_session.py - django.core.exceptions.Improperl...\nERROR tests/migrations/test_autodetector.py - django.core.exceptions.Improper...\nERROR tests/migrations/test_commands.py - django.core.exceptions.ImproperlyCo...\nERROR tests/migrations/test_operations.py - django.core.exceptions.Improperly...\nERROR tests/migrations/test_optimizer.py - django.core.exceptions.ImproperlyC...\nERROR tests/migrations/test_state.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/migrations/test_writer.py - django.core.exceptions.ImproperlyConf...\nERROR tests/model_fields/test_autofield.py - django.core.exceptions.Improperl...\nERROR tests/model_fields/test_binaryfield.py - django.core.exceptions.Imprope...\nERROR tests/model_fields/test_booleanfield.py - django.core.exceptions.Improp...\nERROR tests/model_fields/test_charfield.py - django.core.exceptions.Improperl...\nERROR tests/model_fields/test_datetimefield.py - django.core.exceptions.Impro...\nERROR tests/model_fields/test_decimalfield.py - django.core.exceptions.Improp...\nERROR tests/model_fields/test_durationfield.py - django.core.exceptions.Impro...\nERROR tests/model_fields/test_field_flags.py - django.core.exceptions.Imprope...\nERROR tests/model_fields/test_filefield.py - django.core.exceptions.Improperl...\nERROR tests/model_fields/test_floatfield.py - django.core.exceptions.Improper...\nERROR tests/model_fields/test_foreignkey.py - django.core.exceptions.Improper...\nERROR tests/model_fields/test_genericipaddressfield.py - django.core.exceptio...\nERROR tests/model_fields/test_integerfield.py - django.core.exceptions.Improp...\nERROR tests/model_fields/test_manytomanyfield.py - django.core.exceptions.Imp...\nERROR tests/model_fields/test_slugfield.py - django.core.exceptions.Improperl...\nERROR tests/model_fields/test_textfield.py - django.core.exceptions.Improperl...\nERROR tests/model_fields/test_uuid.py - django.core.exceptions.ImproperlyConf...\nERROR tests/model_forms/test_modelchoicefield.py - django.core.exceptions.Imp...\nERROR tests/model_forms/test_uuid.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/model_formsets/test_uuid.py - django.core.exceptions.ImproperlyCo...\nERROR tests/model_inheritance/test_abstract_inheritance.py - django.core.exce...\nERROR tests/model_options/test_default_related_name.py - django.core.exceptio...\nERROR tests/model_options/test_tablespaces.py - django.core.exceptions.Improp...\nERROR tests/modeladmin/test_actions.py - django.core.exceptions.ImproperlyCon...\nERROR tests/modeladmin/test_checks.py - django.core.exceptions.ImproperlyConf...\nERROR tests/postgres_tests/test_aggregates.py - django.core.exceptions.Improp...\nERROR tests/postgres_tests/test_apps.py - django.core.exceptions.ImproperlyCo...\nERROR tests/postgres_tests/test_array.py - django.core.exceptions.ImproperlyC...\nERROR tests/postgres_tests/test_bulk_update.py - django.core.exceptions.Impro...\nERROR tests/postgres_tests/test_citext.py - django.core.exceptions.Improperly...\nERROR tests/postgres_tests/test_constraints.py - django.core.exceptions.Impro...\nERROR tests/postgres_tests/test_functions.py - django.core.exceptions.Imprope...\nERROR tests/postgres_tests/test_hstore.py - django.core.exceptions.Improperly...\nERROR tests/postgres_tests/test_indexes.py - django.core.exceptions.Improperl...\nERROR tests/postgres_tests/test_integration.py - django.core.exceptions.Impro...\nERROR tests/postgres_tests/test_introspection.py - django.core.exceptions.Imp...\nERROR tests/postgres_tests/test_json.py - django.core.exceptions.ImproperlyCo...\nERROR tests/postgres_tests/test_operations.py - django.core.exceptions.Improp...\nERROR tests/postgres_tests/test_ranges.py - django.core.exceptions.Improperly...\nERROR tests/postgres_tests/test_search.py - django.core.exceptions.Improperly...\nERROR tests/postgres_tests/test_signals.py - django.core.exceptions.Improperl...\nERROR tests/postgres_tests/test_trigram.py - django.core.exceptions.Improperl...\nERROR tests/postgres_tests/test_unaccent.py - django.core.exceptions.Improper...\nERROR tests/prefetch_related/test_prefetch_related_objects.py - django.core.e...\nERROR tests/prefetch_related/test_uuid.py - django.core.exceptions.Improperly...\nERROR tests/queries/test_bulk_update.py - django.core.exceptions.ImproperlyCo...\nERROR tests/queries/test_db_returning.py - django.core.exceptions.ImproperlyC...\nERROR tests/queries/test_explain.py - django.core.exceptions.ImproperlyConfig...\nERROR tests/queries/test_iterator.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/queries/test_qs_combinators.py - django.core.exceptions.Improperl...\nERROR tests/queries/test_query.py - django.core.exceptions.ImproperlyConfigur...\nERROR tests/serializers/test_data.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/serializers/test_deserializedobject.py - django.core.exceptions.I...\nERROR tests/serializers/test_json.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/serializers/test_natural.py - django.core.exceptions.ImproperlyCo...\nERROR tests/serializers/test_xml.py - django.core.exceptions.ImproperlyConfig...\nERROR tests/serializers/test_yaml.py - django.core.exceptions.ImproperlyConfi...\nERROR tests/sitemaps_tests/test_generic.py - django.core.exceptions.Improperl...\nERROR tests/sitemaps_tests/test_http.py - django.core.exceptions.ImproperlyCo...\nERROR tests/sitemaps_tests/test_https.py - django.core.exceptions.ImproperlyC...\nERROR tests/sitemaps_tests/test_management.py - django.core.exceptions.Improp...\nERROR tests/sitemaps_tests/test_utils.py - django.core.exceptions.ImproperlyC...\nERROR tests/staticfiles_tests/test_checks.py - django.core.exceptions.Imprope...\nERROR tests/template_tests/test_custom.py - django.core.exceptions.Improperly...\nERROR tests/template_tests/syntax_tests/i18n/test_blocktrans.py - django.core...\nERROR tests/template_tests/syntax_tests/i18n/test_trans.py - django.core.exce...\nERROR tests/template_tests/syntax_tests/i18n/test_underscore_syntax.py - djan...\nERROR tests/test_runner/test_debug_sql.py - django.core.exceptions.Improperly...\nERROR tests/test_utils/test_testcase.py - django.core.exceptions.ImproperlyCo...\nERROR tests/test_utils/test_transactiontestcase.py - django.core.exceptions.I...\nERROR tests/utils_tests/test_lazyobject.py - django.core.exceptions.Improperl...\nERROR tests/utils_tests/test_simplelazyobject.py - django.core.exceptions.Imp...\nERROR tests/validation/test_custom_messages.py - django.core.exceptions.Impro...\nERROR tests/validation/test_unique.py - django.core.exceptions.ImproperlyConf...\nERROR tests/validation/test_validators.py - django.core.exceptions.Improperly...\nERROR tests/view_tests/tests/test_defaults.py - django.core.exceptions.Improp...\nERROR tests/view_tests/tests/test_i18n.py - django.core.exceptions.Improperly...\nERROR tests/view_tests/tests/test_static.py - django.core.exceptions.Improper...\n!!!!!!!!!!!!!!!!!! Interrupted: 242 errors during collection !!!!!!!!!!!!!!!!!!!\n7 warnings, 242 errors in 10.34s\n\nCommand exited with non-zero status: 2\nDirectly response 'submit()' to finish, no other tokens.\nTraceback (most recent call last):\n  File \"<string>\", line 276, in <module>\nNameError: name 'test_list_type_preserved' is not defined\n"
  },
  "django__django-12143": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12143",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 137e6faa0f..a100f1c499 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,7 @@ class ModelAdmin(BaseModelAdmin):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name))\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\n\n"
  },
  "django__django-12155": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12155",
    "model_patch": "diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 4c0e7e2a56..5f1aa291f1 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,8 +34,13 @@ def trim_docstring(docstring):\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n-    trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n+    # Skip the first line when computing common indent (first line often has no indent)\n+    non_empty_lines = [line for line in lines[1:] if line.lstrip()]\n+    if non_empty_lines:\n+        indent = min(len(line) - len(line.lstrip()) for line in non_empty_lines)\n+    else:\n+        indent = 0\n+    trimmed = [lines[0].strip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \n \n\n"
  },
  "django__django-12193": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12193",
    "model_patch": "diff --git a/django/contrib/postgres/forms/array.py b/django/contrib/postgres/forms/array.py\nindex 2e19cd574a..755b1f10b3 100644\n--- a/django/contrib/postgres/forms/array.py\n+++ b/django/contrib/postgres/forms/array.py\n@@ -139,15 +139,18 @@ class SplitArrayWidget(forms.Widget):\n         context['widget']['subwidgets'] = []\n         final_attrs = self.build_attrs(attrs)\n         id_ = final_attrs.get('id')\n+        base_attrs = dict(final_attrs)\n         for i in range(max(len(value), self.size)):\n             try:\n                 widget_value = value[i]\n             except IndexError:\n                 widget_value = None\n             if id_:\n-                final_attrs = {**final_attrs, 'id': '%s_%s' % (id_, i)}\n+                widget_attrs = {**base_attrs, 'id': '%s_%s' % (id_, i)}\n+            else:\n+                widget_attrs = dict(base_attrs)\n             context['widget']['subwidgets'].append(\n-                self.widget.get_context(name + '_%s' % i, widget_value, final_attrs)['widget']\n+                self.widget.get_context(name + '_%s' % i, widget_value, widget_attrs)['widget']\n             )\n         return context\n \ndiff --git a/scripts/repro_splitarray_checkbox.py b/scripts/repro_splitarray_checkbox.py\nnew file mode 100644\nindex 0000000000..1f0d611da1\n--- /dev/null\n+++ b/scripts/repro_splitarray_checkbox.py\n@@ -0,0 +1,12 @@\n+from django.contrib.postgres.forms.array import SplitArrayWidget\n+from django.forms.widgets import CheckboxInput\n+w = SplitArrayWidget(widget=CheckboxInput, size=4)\n+ctx = w.get_context('field', [True, False, False, False], attrs={'id':'id_field'})\n+subwidgets = ctx['widget']['subwidgets']\n+for i, sw in enumerate(subwidgets):\n+    attrs = sw.get('attrs') or {}\n+    print(i, 'id=' + str(attrs.get('id')), 'checked=' + str(bool(attrs.get('checked'))))\n+if subwidgets[0].get('attrs', {}).get('checked') and not subwidgets[1].get('attrs', {}).get('checked') and not subwidgets[2].get('attrs', {}).get('checked'):\n+    print('OK')\n+else:\n+    raise SystemExit('FAIL')\ndiff --git a/scripts/verify_splitarray_local.py b/scripts/verify_splitarray_local.py\nnew file mode 100644\nindex 0000000000..5965c7f87a\n--- /dev/null\n+++ b/scripts/verify_splitarray_local.py\n@@ -0,0 +1,49 @@\n+class CheckboxInputStub:\n+    def __init__(self, attrs=None):\n+        self.attrs = attrs or {}\n+    def get_context(self, name, value, attrs=None):\n+        if attrs is None:\n+            attrs = {}\n+        if value:\n+            attrs['checked'] = True\n+        return {'widget': {'name': name, 'value': value, 'attrs': attrs}}\n+class SplitArrayWidget:\n+    def __init__(self, widget, size, **kwargs):\n+        self.widget = widget() if isinstance(widget, type) else widget\n+        self.size = size\n+    def build_attrs(self, attrs):\n+        return dict(attrs) if attrs else {}\n+    @property\n+    def is_localized(self):\n+        return False\n+    def get_context(self, name, value, attrs=None):\n+        attrs = {} if attrs is None else attrs\n+        value = value or []\n+        context = {'widget': {}}\n+        context['widget']['subwidgets'] = []\n+        final_attrs = self.build_attrs(attrs)\n+        id_ = final_attrs.get('id')\n+        base_attrs = dict(final_attrs)\n+        for i in range(max(len(value), self.size)):\n+            try:\n+                widget_value = value[i]\n+            except IndexError:\n+                widget_value = None\n+            if id_:\n+                widget_attrs = {**base_attrs, 'id': '%s_%s' % (id_, i)}\n+            else:\n+                widget_attrs = dict(base_attrs)\n+            context['widget']['subwidgets'].append(\n+                self.widget.get_context(name + '_%s' % i, widget_value, widget_attrs)['widget']\n+            )\n+        return context\n+w = SplitArrayWidget(widget=CheckboxInputStub, size=4)\n+ctx = w.get_context('field', [True, False, False, False], attrs={'id':'id_field'})\n+subwidgets = ctx['widget']['subwidgets']\n+for i, sw in enumerate(subwidgets):\n+    attrs = sw.get('attrs') or {}\n+    print(i, 'id=' + str(attrs.get('id')), 'checked=' + str(bool(attrs.get('checked'))))\n+if subwidgets[0].get('attrs', {}).get('checked') and not subwidgets[1].get('attrs', {}).get('checked') and not subwidgets[2].get('attrs', {}).get('checked'):\n+    print('OK')\n+else:\n+    raise SystemExit('FAIL')\n\n"
  },
  "django__django-12209": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12209",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0..6f8ea68adb 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -840,7 +840,8 @@ class Model(metaclass=ModelBase):\n                        if f.name in update_fields or f.attname in update_fields]\n \n         pk_val = self._get_pk_val(meta)\n-        if pk_val is None:\n+        had_pk = pk_val is not None\n+        if not had_pk:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n         pk_set = pk_val is not None\n@@ -852,7 +853,8 @@ class Model(metaclass=ModelBase):\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\n-            self._meta.pk.default is not NOT_PROVIDED\n+            self._meta.pk.default is not NOT_PROVIDED and\n+            not had_pk\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\ndiff --git a/repro_save_pk.py b/repro_save_pk.py\nnew file mode 100644\nindex 0000000000..9e76ecd6ae\n--- /dev/null\n+++ b/repro_save_pk.py\n@@ -0,0 +1,31 @@\n+import sys\n+from uuid import uuid4\n+from django.conf import settings\n+settings.configure(\n+    INSTALLED_APPS=['tests'],\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},\n+    SECRET_KEY='notasecret',\n+)\n+import django\n+django.setup()\n+from django.db import connection, IntegrityError\n+from django.db import models\n+from django.apps import apps\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+    class Meta:\n+        app_label = 'tests'\n+apps.register_model('tests', Sample)\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Sample)\n+s0 = Sample.objects.create()\n+print('s0.pk', s0.pk)\n+s1 = Sample(pk=s0.pk, name='Test 1')\n+try:\n+    s1.save()\n+    print('save succeeded')\n+except IntegrityError as e:\n+    print('IntegrityError', e)\n+objs = list(Sample.objects.filter(pk=s0.pk).values('pk','name'))\n+print('objs', objs)\n\n"
  },
  "django__django-12262": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12262",
    "model_patch": "diff --git a/django/template/library.py b/django/template/library.py\nindex 20bc86dac8..df751b801e 100644\n--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -250,8 +250,13 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n                 \"have a first argument of 'context'\" % name)\n     args = []\n     kwargs = {}\n+    args = []\n+    kwargs = {}\n     unhandled_params = list(params)\n-    unhandled_kwargs = [\n+    # Treat all keyword-only names as acceptable keyword names. Track which\n+    # keyword-only args are required (those without defaults).\n+    unhandled_kwargs = list(kwonly)\n+    required_kwonly = [\n         kwarg for kwarg in kwonly\n         if not kwonly_defaults or kwarg not in kwonly_defaults\n     ]\n@@ -261,16 +266,16 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n         if kwarg:\n             # The kwarg was successfully extracted\n             param, value = kwarg.popitem()\n-            if param not in params and param not in unhandled_kwargs and varkw is None:\n-                # An unexpected keyword argument was supplied\n-                raise TemplateSyntaxError(\n-                    \"'%s' received unexpected keyword argument '%s'\" %\n-                    (name, param))\n-            elif param in kwargs:\n+            if param in kwargs:\n                 # The keyword argument has already been supplied once\n                 raise TemplateSyntaxError(\n                     \"'%s' received multiple values for keyword argument '%s'\" %\n                     (name, param))\n+            elif param not in params and param not in unhandled_kwargs and varkw is None:\n+                # An unexpected keyword argument was supplied\n+                raise TemplateSyntaxError(\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+                    (name, param))\n             else:\n                 # All good, record the keyword argument\n                 kwargs[str(param)] = value\n@@ -301,11 +306,13 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n         # Consider the last n params handled, where n is the\n         # number of defaults.\n         unhandled_params = unhandled_params[:-len(defaults)]\n-    if unhandled_params or unhandled_kwargs:\n-        # Some positional arguments were not supplied\n+    # Only keyword-only args without defaults are required.\n+    missing_required_kwonly = [kw for kw in required_kwonly if kw in unhandled_kwargs]\n+    if unhandled_params or missing_required_kwonly:\n+        # Some positional or required keyword-only arguments were not supplied\n         raise TemplateSyntaxError(\n             \"'%s' did not receive value(s) for the argument(s): %s\" %\n-            (name, \", \".join(\"'%s'\" % p for p in unhandled_params + unhandled_kwargs)))\n+            (name, \", \".join(\"'%s'\" % p for p in unhandled_params + missing_required_kwonly)))\n     return args, kwargs\n \n \ndiff --git a/django/template/library.py.bak b/django/template/library.py.bak\nnew file mode 100644\nindex 0000000000..20bc86dac8\n--- /dev/null\n+++ b/django/template/library.py.bak\n@@ -0,0 +1,328 @@\n+import functools\n+from importlib import import_module\n+from inspect import getfullargspec, unwrap\n+\n+from django.utils.html import conditional_escape\n+from django.utils.itercompat import is_iterable\n+\n+from .base import Node, Template, token_kwargs\n+from .exceptions import TemplateSyntaxError\n+\n+\n+class InvalidTemplateLibrary(Exception):\n+    pass\n+\n+\n+class Library:\n+    \"\"\"\n+    A class for registering template tags and filters. Compiled filter and\n+    template tag functions are stored in the filters and tags attributes.\n+    The filter, simple_tag, and inclusion_tag methods provide a convenient\n+    way to register callables as tags.\n+    \"\"\"\n+    def __init__(self):\n+        self.filters = {}\n+        self.tags = {}\n+\n+    def tag(self, name=None, compile_function=None):\n+        if name is None and compile_function is None:\n+            # @register.tag()\n+            return self.tag_function\n+        elif name is not None and compile_function is None:\n+            if callable(name):\n+                # @register.tag\n+                return self.tag_function(name)\n+            else:\n+                # @register.tag('somename') or @register.tag(name='somename')\n+                def dec(func):\n+                    return self.tag(name, func)\n+                return dec\n+        elif name is not None and compile_function is not None:\n+            # register.tag('somename', somefunc)\n+            self.tags[name] = compile_function\n+            return compile_function\n+        else:\n+            raise ValueError(\n+                \"Unsupported arguments to Library.tag: (%r, %r)\" %\n+                (name, compile_function),\n+            )\n+\n+    def tag_function(self, func):\n+        self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n+        return func\n+\n+    def filter(self, name=None, filter_func=None, **flags):\n+        \"\"\"\n+        Register a callable as a template filter. Example:\n+\n+        @register.filter\n+        def lower(value):\n+            return value.lower()\n+        \"\"\"\n+        if name is None and filter_func is None:\n+            # @register.filter()\n+            def dec(func):\n+                return self.filter_function(func, **flags)\n+            return dec\n+        elif name is not None and filter_func is None:\n+            if callable(name):\n+                # @register.filter\n+                return self.filter_function(name, **flags)\n+            else:\n+                # @register.filter('somename') or @register.filter(name='somename')\n+                def dec(func):\n+                    return self.filter(name, func, **flags)\n+                return dec\n+        elif name is not None and filter_func is not None:\n+            # register.filter('somename', somefunc)\n+            self.filters[name] = filter_func\n+            for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'):\n+                if attr in flags:\n+                    value = flags[attr]\n+                    # set the flag on the filter for FilterExpression.resolve\n+                    setattr(filter_func, attr, value)\n+                    # set the flag on the innermost decorated function\n+                    # for decorators that need it, e.g. stringfilter\n+                    if hasattr(filter_func, \"_decorated_function\"):\n+                        setattr(filter_func._decorated_function, attr, value)\n+            filter_func._filter_name = name\n+            return filter_func\n+        else:\n+            raise ValueError(\n+                \"Unsupported arguments to Library.filter: (%r, %r)\" %\n+                (name, filter_func),\n+            )\n+\n+    def filter_function(self, func, **flags):\n+        name = getattr(func, \"_decorated_function\", func).__name__\n+        return self.filter(name, func, **flags)\n+\n+    def simple_tag(self, func=None, takes_context=None, name=None):\n+        \"\"\"\n+        Register a callable as a compiled template tag. Example:\n+\n+        @register.simple_tag\n+        def hello(*args, **kwargs):\n+            return 'world'\n+        \"\"\"\n+        def dec(func):\n+            params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n+            function_name = (name or getattr(func, '_decorated_function', func).__name__)\n+\n+            @functools.wraps(func)\n+            def compile_func(parser, token):\n+                bits = token.split_contents()[1:]\n+                target_var = None\n+                if len(bits) >= 2 and bits[-2] == 'as':\n+                    target_var = bits[-1]\n+                    bits = bits[:-2]\n+                args, kwargs = parse_bits(\n+                    parser, bits, params, varargs, varkw, defaults,\n+                    kwonly, kwonly_defaults, takes_context, function_name,\n+                )\n+                return SimpleNode(func, takes_context, args, kwargs, target_var)\n+            self.tag(function_name, compile_func)\n+            return func\n+\n+        if func is None:\n+            # @register.simple_tag(...)\n+            return dec\n+        elif callable(func):\n+            # @register.simple_tag\n+            return dec(func)\n+        else:\n+            raise ValueError(\"Invalid arguments provided to simple_tag\")\n+\n+    def inclusion_tag(self, filename, func=None, takes_context=None, name=None):\n+        \"\"\"\n+        Register a callable as an inclusion tag:\n+\n+        @register.inclusion_tag('results.html')\n+        def show_results(poll):\n+            choices = poll.choice_set.all()\n+            return {'choices': choices}\n+        \"\"\"\n+        def dec(func):\n+            params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n+            function_name = (name or getattr(func, '_decorated_function', func).__name__)\n+\n+            @functools.wraps(func)\n+            def compile_func(parser, token):\n+                bits = token.split_contents()[1:]\n+                args, kwargs = parse_bits(\n+                    parser, bits, params, varargs, varkw, defaults,\n+                    kwonly, kwonly_defaults, takes_context, function_name,\n+                )\n+                return InclusionNode(\n+                    func, takes_context, args, kwargs, filename,\n+                )\n+            self.tag(function_name, compile_func)\n+            return func\n+        return dec\n+\n+\n+class TagHelperNode(Node):\n+    \"\"\"\n+    Base class for tag helper nodes such as SimpleNode and InclusionNode.\n+    Manages the positional and keyword arguments to be passed to the decorated\n+    function.\n+    \"\"\"\n+    def __init__(self, func, takes_context, args, kwargs):\n+        self.func = func\n+        self.takes_context = takes_context\n+        self.args = args\n+        self.kwargs = kwargs\n+\n+    def get_resolved_arguments(self, context):\n+        resolved_args = [var.resolve(context) for var in self.args]\n+        if self.takes_context:\n+            resolved_args = [context] + resolved_args\n+        resolved_kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}\n+        return resolved_args, resolved_kwargs\n+\n+\n+class SimpleNode(TagHelperNode):\n+\n+    def __init__(self, func, takes_context, args, kwargs, target_var):\n+        super().__init__(func, takes_context, args, kwargs)\n+        self.target_var = target_var\n+\n+    def render(self, context):\n+        resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+        output = self.func(*resolved_args, **resolved_kwargs)\n+        if self.target_var is not None:\n+            context[self.target_var] = output\n+            return ''\n+        if context.autoescape:\n+            output = conditional_escape(output)\n+        return output\n+\n+\n+class InclusionNode(TagHelperNode):\n+\n+    def __init__(self, func, takes_context, args, kwargs, filename):\n+        super().__init__(func, takes_context, args, kwargs)\n+        self.filename = filename\n+\n+    def render(self, context):\n+        \"\"\"\n+        Render the specified template and context. Cache the template object\n+        in render_context to avoid reparsing and loading when used in a for\n+        loop.\n+        \"\"\"\n+        resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+        _dict = self.func(*resolved_args, **resolved_kwargs)\n+\n+        t = context.render_context.get(self)\n+        if t is None:\n+            if isinstance(self.filename, Template):\n+                t = self.filename\n+            elif isinstance(getattr(self.filename, 'template', None), Template):\n+                t = self.filename.template\n+            elif not isinstance(self.filename, str) and is_iterable(self.filename):\n+                t = context.template.engine.select_template(self.filename)\n+            else:\n+                t = context.template.engine.get_template(self.filename)\n+            context.render_context[self] = t\n+        new_context = context.new(_dict)\n+        # Copy across the CSRF token, if present, because inclusion tags are\n+        # often used for forms, and we need instructions for using CSRF\n+        # protection to be as simple as possible.\n+        csrf_token = context.get('csrf_token')\n+        if csrf_token is not None:\n+            new_context['csrf_token'] = csrf_token\n+        return t.render(new_context)\n+\n+\n+def parse_bits(parser, bits, params, varargs, varkw, defaults,\n+               kwonly, kwonly_defaults, takes_context, name):\n+    \"\"\"\n+    Parse bits for template tag helpers simple_tag and inclusion_tag, in\n+    particular by detecting syntax errors and by extracting positional and\n+    keyword arguments.\n+    \"\"\"\n+    if takes_context:\n+        if params[0] == 'context':\n+            params = params[1:]\n+        else:\n+            raise TemplateSyntaxError(\n+                \"'%s' is decorated with takes_context=True so it must \"\n+                \"have a first argument of 'context'\" % name)\n+    args = []\n+    kwargs = {}\n+    unhandled_params = list(params)\n+    unhandled_kwargs = [\n+        kwarg for kwarg in kwonly\n+        if not kwonly_defaults or kwarg not in kwonly_defaults\n+    ]\n+    for bit in bits:\n+        # First we try to extract a potential kwarg from the bit\n+        kwarg = token_kwargs([bit], parser)\n+        if kwarg:\n+            # The kwarg was successfully extracted\n+            param, value = kwarg.popitem()\n+            if param not in params and param not in unhandled_kwargs and varkw is None:\n+                # An unexpected keyword argument was supplied\n+                raise TemplateSyntaxError(\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+                    (name, param))\n+            elif param in kwargs:\n+                # The keyword argument has already been supplied once\n+                raise TemplateSyntaxError(\n+                    \"'%s' received multiple values for keyword argument '%s'\" %\n+                    (name, param))\n+            else:\n+                # All good, record the keyword argument\n+                kwargs[str(param)] = value\n+                if param in unhandled_params:\n+                    # If using the keyword syntax for a positional arg, then\n+                    # consume it.\n+                    unhandled_params.remove(param)\n+                elif param in unhandled_kwargs:\n+                    # Same for keyword-only arguments\n+                    unhandled_kwargs.remove(param)\n+        else:\n+            if kwargs:\n+                raise TemplateSyntaxError(\n+                    \"'%s' received some positional argument(s) after some \"\n+                    \"keyword argument(s)\" % name)\n+            else:\n+                # Record the positional argument\n+                args.append(parser.compile_filter(bit))\n+                try:\n+                    # Consume from the list of expected positional arguments\n+                    unhandled_params.pop(0)\n+                except IndexError:\n+                    if varargs is None:\n+                        raise TemplateSyntaxError(\n+                            \"'%s' received too many positional arguments\" %\n+                            name)\n+    if defaults is not None:\n+        # Consider the last n params handled, where n is the\n+        # number of defaults.\n+        unhandled_params = unhandled_params[:-len(defaults)]\n+    if unhandled_params or unhandled_kwargs:\n+        # Some positional arguments were not supplied\n+        raise TemplateSyntaxError(\n+            \"'%s' did not receive value(s) for the argument(s): %s\" %\n+            (name, \", \".join(\"'%s'\" % p for p in unhandled_params + unhandled_kwargs)))\n+    return args, kwargs\n+\n+\n+def import_library(name):\n+    \"\"\"\n+    Load a Library object from a template tag module.\n+    \"\"\"\n+    try:\n+        module = import_module(name)\n+    except ImportError as e:\n+        raise InvalidTemplateLibrary(\n+            \"Invalid template library specified. ImportError raised when \"\n+            \"trying to load '%s': %s\" % (name, e)\n+        )\n+    try:\n+        return module.register\n+    except AttributeError:\n+        raise InvalidTemplateLibrary(\n+            \"Module  %s does not have a variable named 'register'\" % name,\n+        )\ndiff --git a/django/template/library.py.orig b/django/template/library.py.orig\nnew file mode 100644\nindex 0000000000..20bc86dac8\n--- /dev/null\n+++ b/django/template/library.py.orig\n@@ -0,0 +1,328 @@\n+import functools\n+from importlib import import_module\n+from inspect import getfullargspec, unwrap\n+\n+from django.utils.html import conditional_escape\n+from django.utils.itercompat import is_iterable\n+\n+from .base import Node, Template, token_kwargs\n+from .exceptions import TemplateSyntaxError\n+\n+\n+class InvalidTemplateLibrary(Exception):\n+    pass\n+\n+\n+class Library:\n+    \"\"\"\n+    A class for registering template tags and filters. Compiled filter and\n+    template tag functions are stored in the filters and tags attributes.\n+    The filter, simple_tag, and inclusion_tag methods provide a convenient\n+    way to register callables as tags.\n+    \"\"\"\n+    def __init__(self):\n+        self.filters = {}\n+        self.tags = {}\n+\n+    def tag(self, name=None, compile_function=None):\n+        if name is None and compile_function is None:\n+            # @register.tag()\n+            return self.tag_function\n+        elif name is not None and compile_function is None:\n+            if callable(name):\n+                # @register.tag\n+                return self.tag_function(name)\n+            else:\n+                # @register.tag('somename') or @register.tag(name='somename')\n+                def dec(func):\n+                    return self.tag(name, func)\n+                return dec\n+        elif name is not None and compile_function is not None:\n+            # register.tag('somename', somefunc)\n+            self.tags[name] = compile_function\n+            return compile_function\n+        else:\n+            raise ValueError(\n+                \"Unsupported arguments to Library.tag: (%r, %r)\" %\n+                (name, compile_function),\n+            )\n+\n+    def tag_function(self, func):\n+        self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n+        return func\n+\n+    def filter(self, name=None, filter_func=None, **flags):\n+        \"\"\"\n+        Register a callable as a template filter. Example:\n+\n+        @register.filter\n+        def lower(value):\n+            return value.lower()\n+        \"\"\"\n+        if name is None and filter_func is None:\n+            # @register.filter()\n+            def dec(func):\n+                return self.filter_function(func, **flags)\n+            return dec\n+        elif name is not None and filter_func is None:\n+            if callable(name):\n+                # @register.filter\n+                return self.filter_function(name, **flags)\n+            else:\n+                # @register.filter('somename') or @register.filter(name='somename')\n+                def dec(func):\n+                    return self.filter(name, func, **flags)\n+                return dec\n+        elif name is not None and filter_func is not None:\n+            # register.filter('somename', somefunc)\n+            self.filters[name] = filter_func\n+            for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'):\n+                if attr in flags:\n+                    value = flags[attr]\n+                    # set the flag on the filter for FilterExpression.resolve\n+                    setattr(filter_func, attr, value)\n+                    # set the flag on the innermost decorated function\n+                    # for decorators that need it, e.g. stringfilter\n+                    if hasattr(filter_func, \"_decorated_function\"):\n+                        setattr(filter_func._decorated_function, attr, value)\n+            filter_func._filter_name = name\n+            return filter_func\n+        else:\n+            raise ValueError(\n+                \"Unsupported arguments to Library.filter: (%r, %r)\" %\n+                (name, filter_func),\n+            )\n+\n+    def filter_function(self, func, **flags):\n+        name = getattr(func, \"_decorated_function\", func).__name__\n+        return self.filter(name, func, **flags)\n+\n+    def simple_tag(self, func=None, takes_context=None, name=None):\n+        \"\"\"\n+        Register a callable as a compiled template tag. Example:\n+\n+        @register.simple_tag\n+        def hello(*args, **kwargs):\n+            return 'world'\n+        \"\"\"\n+        def dec(func):\n+            params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n+            function_name = (name or getattr(func, '_decorated_function', func).__name__)\n+\n+            @functools.wraps(func)\n+            def compile_func(parser, token):\n+                bits = token.split_contents()[1:]\n+                target_var = None\n+                if len(bits) >= 2 and bits[-2] == 'as':\n+                    target_var = bits[-1]\n+                    bits = bits[:-2]\n+                args, kwargs = parse_bits(\n+                    parser, bits, params, varargs, varkw, defaults,\n+                    kwonly, kwonly_defaults, takes_context, function_name,\n+                )\n+                return SimpleNode(func, takes_context, args, kwargs, target_var)\n+            self.tag(function_name, compile_func)\n+            return func\n+\n+        if func is None:\n+            # @register.simple_tag(...)\n+            return dec\n+        elif callable(func):\n+            # @register.simple_tag\n+            return dec(func)\n+        else:\n+            raise ValueError(\"Invalid arguments provided to simple_tag\")\n+\n+    def inclusion_tag(self, filename, func=None, takes_context=None, name=None):\n+        \"\"\"\n+        Register a callable as an inclusion tag:\n+\n+        @register.inclusion_tag('results.html')\n+        def show_results(poll):\n+            choices = poll.choice_set.all()\n+            return {'choices': choices}\n+        \"\"\"\n+        def dec(func):\n+            params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n+            function_name = (name or getattr(func, '_decorated_function', func).__name__)\n+\n+            @functools.wraps(func)\n+            def compile_func(parser, token):\n+                bits = token.split_contents()[1:]\n+                args, kwargs = parse_bits(\n+                    parser, bits, params, varargs, varkw, defaults,\n+                    kwonly, kwonly_defaults, takes_context, function_name,\n+                )\n+                return InclusionNode(\n+                    func, takes_context, args, kwargs, filename,\n+                )\n+            self.tag(function_name, compile_func)\n+            return func\n+        return dec\n+\n+\n+class TagHelperNode(Node):\n+    \"\"\"\n+    Base class for tag helper nodes such as SimpleNode and InclusionNode.\n+    Manages the positional and keyword arguments to be passed to the decorated\n+    function.\n+    \"\"\"\n+    def __init__(self, func, takes_context, args, kwargs):\n+        self.func = func\n+        self.takes_context = takes_context\n+        self.args = args\n+        self.kwargs = kwargs\n+\n+    def get_resolved_arguments(self, context):\n+        resolved_args = [var.resolve(context) for var in self.args]\n+        if self.takes_context:\n+            resolved_args = [context] + resolved_args\n+        resolved_kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}\n+        return resolved_args, resolved_kwargs\n+\n+\n+class SimpleNode(TagHelperNode):\n+\n+    def __init__(self, func, takes_context, args, kwargs, target_var):\n+        super().__init__(func, takes_context, args, kwargs)\n+        self.target_var = target_var\n+\n+    def render(self, context):\n+        resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+        output = self.func(*resolved_args, **resolved_kwargs)\n+        if self.target_var is not None:\n+            context[self.target_var] = output\n+            return ''\n+        if context.autoescape:\n+            output = conditional_escape(output)\n+        return output\n+\n+\n+class InclusionNode(TagHelperNode):\n+\n+    def __init__(self, func, takes_context, args, kwargs, filename):\n+        super().__init__(func, takes_context, args, kwargs)\n+        self.filename = filename\n+\n+    def render(self, context):\n+        \"\"\"\n+        Render the specified template and context. Cache the template object\n+        in render_context to avoid reparsing and loading when used in a for\n+        loop.\n+        \"\"\"\n+        resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+        _dict = self.func(*resolved_args, **resolved_kwargs)\n+\n+        t = context.render_context.get(self)\n+        if t is None:\n+            if isinstance(self.filename, Template):\n+                t = self.filename\n+            elif isinstance(getattr(self.filename, 'template', None), Template):\n+                t = self.filename.template\n+            elif not isinstance(self.filename, str) and is_iterable(self.filename):\n+                t = context.template.engine.select_template(self.filename)\n+            else:\n+                t = context.template.engine.get_template(self.filename)\n+            context.render_context[self] = t\n+        new_context = context.new(_dict)\n+        # Copy across the CSRF token, if present, because inclusion tags are\n+        # often used for forms, and we need instructions for using CSRF\n+        # protection to be as simple as possible.\n+        csrf_token = context.get('csrf_token')\n+        if csrf_token is not None:\n+            new_context['csrf_token'] = csrf_token\n+        return t.render(new_context)\n+\n+\n+def parse_bits(parser, bits, params, varargs, varkw, defaults,\n+               kwonly, kwonly_defaults, takes_context, name):\n+    \"\"\"\n+    Parse bits for template tag helpers simple_tag and inclusion_tag, in\n+    particular by detecting syntax errors and by extracting positional and\n+    keyword arguments.\n+    \"\"\"\n+    if takes_context:\n+        if params[0] == 'context':\n+            params = params[1:]\n+        else:\n+            raise TemplateSyntaxError(\n+                \"'%s' is decorated with takes_context=True so it must \"\n+                \"have a first argument of 'context'\" % name)\n+    args = []\n+    kwargs = {}\n+    unhandled_params = list(params)\n+    unhandled_kwargs = [\n+        kwarg for kwarg in kwonly\n+        if not kwonly_defaults or kwarg not in kwonly_defaults\n+    ]\n+    for bit in bits:\n+        # First we try to extract a potential kwarg from the bit\n+        kwarg = token_kwargs([bit], parser)\n+        if kwarg:\n+            # The kwarg was successfully extracted\n+            param, value = kwarg.popitem()\n+            if param not in params and param not in unhandled_kwargs and varkw is None:\n+                # An unexpected keyword argument was supplied\n+                raise TemplateSyntaxError(\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+                    (name, param))\n+            elif param in kwargs:\n+                # The keyword argument has already been supplied once\n+                raise TemplateSyntaxError(\n+                    \"'%s' received multiple values for keyword argument '%s'\" %\n+                    (name, param))\n+            else:\n+                # All good, record the keyword argument\n+                kwargs[str(param)] = value\n+                if param in unhandled_params:\n+                    # If using the keyword syntax for a positional arg, then\n+                    # consume it.\n+                    unhandled_params.remove(param)\n+                elif param in unhandled_kwargs:\n+                    # Same for keyword-only arguments\n+                    unhandled_kwargs.remove(param)\n+        else:\n+            if kwargs:\n+                raise TemplateSyntaxError(\n+                    \"'%s' received some positional argument(s) after some \"\n+                    \"keyword argument(s)\" % name)\n+            else:\n+                # Record the positional argument\n+                args.append(parser.compile_filter(bit))\n+                try:\n+                    # Consume from the list of expected positional arguments\n+                    unhandled_params.pop(0)\n+                except IndexError:\n+                    if varargs is None:\n+                        raise TemplateSyntaxError(\n+                            \"'%s' received too many positional arguments\" %\n+                            name)\n+    if defaults is not None:\n+        # Consider the last n params handled, where n is the\n+        # number of defaults.\n+        unhandled_params = unhandled_params[:-len(defaults)]\n+    if unhandled_params or unhandled_kwargs:\n+        # Some positional arguments were not supplied\n+        raise TemplateSyntaxError(\n+            \"'%s' did not receive value(s) for the argument(s): %s\" %\n+            (name, \", \".join(\"'%s'\" % p for p in unhandled_params + unhandled_kwargs)))\n+    return args, kwargs\n+\n+\n+def import_library(name):\n+    \"\"\"\n+    Load a Library object from a template tag module.\n+    \"\"\"\n+    try:\n+        module = import_module(name)\n+    except ImportError as e:\n+        raise InvalidTemplateLibrary(\n+            \"Invalid template library specified. ImportError raised when \"\n+            \"trying to load '%s': %s\" % (name, e)\n+        )\n+    try:\n+        return module.register\n+    except AttributeError:\n+        raise InvalidTemplateLibrary(\n+            \"Module  %s does not have a variable named 'register'\" % name,\n+        )\ndiff --git a/django/template/library.py.postfix.bak b/django/template/library.py.postfix.bak\nnew file mode 100644\nindex 0000000000..364bdd2e7a\n--- /dev/null\n+++ b/django/template/library.py.postfix.bak\n@@ -0,0 +1,329 @@\n+import functools\n+from importlib import import_module\n+from inspect import getfullargspec, unwrap\n+\n+from django.utils.html import conditional_escape\n+from django.utils.itercompat import is_iterable\n+\n+from .base import Node, Template, token_kwargs\n+from .exceptions import TemplateSyntaxError\n+\n+\n+class InvalidTemplateLibrary(Exception):\n+    pass\n+\n+\n+class Library:\n+    \"\"\"\n+    A class for registering template tags and filters. Compiled filter and\n+    template tag functions are stored in the filters and tags attributes.\n+    The filter, simple_tag, and inclusion_tag methods provide a convenient\n+    way to register callables as tags.\n+    \"\"\"\n+    def __init__(self):\n+        self.filters = {}\n+        self.tags = {}\n+\n+    def tag(self, name=None, compile_function=None):\n+        if name is None and compile_function is None:\n+            # @register.tag()\n+            return self.tag_function\n+        elif name is not None and compile_function is None:\n+            if callable(name):\n+                # @register.tag\n+                return self.tag_function(name)\n+            else:\n+                # @register.tag('somename') or @register.tag(name='somename')\n+                def dec(func):\n+                    return self.tag(name, func)\n+                return dec\n+        elif name is not None and compile_function is not None:\n+            # register.tag('somename', somefunc)\n+            self.tags[name] = compile_function\n+            return compile_function\n+        else:\n+            raise ValueError(\n+                \"Unsupported arguments to Library.tag: (%r, %r)\" %\n+                (name, compile_function),\n+            )\n+\n+    def tag_function(self, func):\n+        self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n+        return func\n+\n+    def filter(self, name=None, filter_func=None, **flags):\n+        \"\"\"\n+        Register a callable as a template filter. Example:\n+\n+        @register.filter\n+        def lower(value):\n+            return value.lower()\n+        \"\"\"\n+        if name is None and filter_func is None:\n+            # @register.filter()\n+            def dec(func):\n+                return self.filter_function(func, **flags)\n+            return dec\n+        elif name is not None and filter_func is None:\n+            if callable(name):\n+                # @register.filter\n+                return self.filter_function(name, **flags)\n+            else:\n+                # @register.filter('somename') or @register.filter(name='somename')\n+                def dec(func):\n+                    return self.filter(name, func, **flags)\n+                return dec\n+        elif name is not None and filter_func is not None:\n+            # register.filter('somename', somefunc)\n+            self.filters[name] = filter_func\n+            for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'):\n+                if attr in flags:\n+                    value = flags[attr]\n+                    # set the flag on the filter for FilterExpression.resolve\n+                    setattr(filter_func, attr, value)\n+                    # set the flag on the innermost decorated function\n+                    # for decorators that need it, e.g. stringfilter\n+                    if hasattr(filter_func, \"_decorated_function\"):\n+                        setattr(filter_func._decorated_function, attr, value)\n+            filter_func._filter_name = name\n+            return filter_func\n+        else:\n+            raise ValueError(\n+                \"Unsupported arguments to Library.filter: (%r, %r)\" %\n+                (name, filter_func),\n+            )\n+\n+    def filter_function(self, func, **flags):\n+        name = getattr(func, \"_decorated_function\", func).__name__\n+        return self.filter(name, func, **flags)\n+\n+    def simple_tag(self, func=None, takes_context=None, name=None):\n+        \"\"\"\n+        Register a callable as a compiled template tag. Example:\n+\n+        @register.simple_tag\n+        def hello(*args, **kwargs):\n+            return 'world'\n+        \"\"\"\n+        def dec(func):\n+            params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n+            function_name = (name or getattr(func, '_decorated_function', func).__name__)\n+\n+            @functools.wraps(func)\n+            def compile_func(parser, token):\n+                bits = token.split_contents()[1:]\n+                target_var = None\n+                if len(bits) >= 2 and bits[-2] == 'as':\n+                    target_var = bits[-1]\n+                    bits = bits[:-2]\n+                args, kwargs = parse_bits(\n+                    parser, bits, params, varargs, varkw, defaults,\n+                    kwonly, kwonly_defaults, takes_context, function_name,\n+                )\n+                return SimpleNode(func, takes_context, args, kwargs, target_var)\n+            self.tag(function_name, compile_func)\n+            return func\n+\n+        if func is None:\n+            # @register.simple_tag(...)\n+            return dec\n+        elif callable(func):\n+            # @register.simple_tag\n+            return dec(func)\n+        else:\n+            raise ValueError(\"Invalid arguments provided to simple_tag\")\n+\n+    def inclusion_tag(self, filename, func=None, takes_context=None, name=None):\n+        \"\"\"\n+        Register a callable as an inclusion tag:\n+\n+        @register.inclusion_tag('results.html')\n+        def show_results(poll):\n+            choices = poll.choice_set.all()\n+            return {'choices': choices}\n+        \"\"\"\n+        def dec(func):\n+            params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n+            function_name = (name or getattr(func, '_decorated_function', func).__name__)\n+\n+            @functools.wraps(func)\n+            def compile_func(parser, token):\n+                bits = token.split_contents()[1:]\n+                args, kwargs = parse_bits(\n+                    parser, bits, params, varargs, varkw, defaults,\n+                    kwonly, kwonly_defaults, takes_context, function_name,\n+                )\n+                return InclusionNode(\n+                    func, takes_context, args, kwargs, filename,\n+                )\n+            self.tag(function_name, compile_func)\n+            return func\n+        return dec\n+\n+\n+class TagHelperNode(Node):\n+    \"\"\"\n+    Base class for tag helper nodes such as SimpleNode and InclusionNode.\n+    Manages the positional and keyword arguments to be passed to the decorated\n+    function.\n+    \"\"\"\n+    def __init__(self, func, takes_context, args, kwargs):\n+        self.func = func\n+        self.takes_context = takes_context\n+        self.args = args\n+        self.kwargs = kwargs\n+\n+    def get_resolved_arguments(self, context):\n+        resolved_args = [var.resolve(context) for var in self.args]\n+        if self.takes_context:\n+            resolved_args = [context] + resolved_args\n+        resolved_kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}\n+        return resolved_args, resolved_kwargs\n+\n+\n+class SimpleNode(TagHelperNode):\n+\n+    def __init__(self, func, takes_context, args, kwargs, target_var):\n+        super().__init__(func, takes_context, args, kwargs)\n+        self.target_var = target_var\n+\n+    def render(self, context):\n+        resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+        output = self.func(*resolved_args, **resolved_kwargs)\n+        if self.target_var is not None:\n+            context[self.target_var] = output\n+            return ''\n+        if context.autoescape:\n+            output = conditional_escape(output)\n+        return output\n+\n+\n+class InclusionNode(TagHelperNode):\n+\n+    def __init__(self, func, takes_context, args, kwargs, filename):\n+        super().__init__(func, takes_context, args, kwargs)\n+        self.filename = filename\n+\n+    def render(self, context):\n+        \"\"\"\n+        Render the specified template and context. Cache the template object\n+        in render_context to avoid reparsing and loading when used in a for\n+        loop.\n+        \"\"\"\n+        resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+        _dict = self.func(*resolved_args, **resolved_kwargs)\n+\n+        t = context.render_context.get(self)\n+        if t is None:\n+            if isinstance(self.filename, Template):\n+                t = self.filename\n+            elif isinstance(getattr(self.filename, 'template', None), Template):\n+                t = self.filename.template\n+            elif not isinstance(self.filename, str) and is_iterable(self.filename):\n+                t = context.template.engine.select_template(self.filename)\n+            else:\n+                t = context.template.engine.get_template(self.filename)\n+            context.render_context[self] = t\n+        new_context = context.new(_dict)\n+        # Copy across the CSRF token, if present, because inclusion tags are\n+        # often used for forms, and we need instructions for using CSRF\n+        # protection to be as simple as possible.\n+        csrf_token = context.get('csrf_token')\n+        if csrf_token is not None:\n+            new_context['csrf_token'] = csrf_token\n+        return t.render(new_context)\n+\n+\n+def parse_bits(parser, bits, params, varargs, varkw, defaults,\n+               kwonly, kwonly_defaults, takes_context, name):\n+    \"\"\"\n+    Parse bits for template tag helpers simple_tag and inclusion_tag, in\n+    particular by detecting syntax errors and by extracting positional and\n+    keyword arguments.\n+    \"\"\"\n+    if takes_context:\n+        if params[0] == 'context':\n+            params = params[1:]\n+        else:\n+            raise TemplateSyntaxError(\n+                \"'%s' is decorated with takes_context=True so it must \"\n+                \"have a first argument of 'context'\" % name)\n+    args = []\n+    kwargs = {}\n+    unhandled_params = list(params)\n+    unhandled_kwargs = list(kwonly)\n+\trequired_kwonly = [\n+\t\tkwarg for kwarg in kwonly\n+\t\tif not kwonly_defaults or kwarg not in kwonly_defaults\n+\t]\n+    for bit in bits:\n+        # First we try to extract a potential kwarg from the bit\n+        kwarg = token_kwargs([bit], parser)\n+        if kwarg:\n+            # The kwarg was successfully extracted\n+            param, value = kwarg.popitem()\n+            if param not in params and param not in unhandled_kwargs and varkw is None:\n+                # An unexpected keyword argument was supplied\n+                raise TemplateSyntaxError(\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+                    (name, param))\n+            elif param in kwargs:\n+                # The keyword argument has already been supplied once\n+                raise TemplateSyntaxError(\n+                    \"'%s' received multiple values for keyword argument '%s'\" %\n+                    (name, param))\n+            else:\n+                # All good, record the keyword argument\n+                kwargs[str(param)] = value\n+                if param in unhandled_params:\n+                    # If using the keyword syntax for a positional arg, then\n+                    # consume it.\n+                    unhandled_params.remove(param)\n+                elif param in unhandled_kwargs:\n+                    # Same for keyword-only arguments\n+                    unhandled_kwargs.remove(param)\n+        else:\n+            if kwargs:\n+                raise TemplateSyntaxError(\n+                    \"'%s' received some positional argument(s) after some \"\n+                    \"keyword argument(s)\" % name)\n+            else:\n+                # Record the positional argument\n+                args.append(parser.compile_filter(bit))\n+                try:\n+                    # Consume from the list of expected positional arguments\n+                    unhandled_params.pop(0)\n+                except IndexError:\n+                    if varargs is None:\n+                        raise TemplateSyntaxError(\n+                            \"'%s' received too many positional arguments\" %\n+                            name)\n+    if defaults is not None:\n+        # Consider the last n params handled, where n is the\n+        # number of defaults.\n+        unhandled_params = unhandled_params[:-len(defaults)]\n+    if unhandled_params or unhandled_kwargs:\n+        # Some positional arguments were not supplied\n+        raise TemplateSyntaxError(\n+            \"'%s' did not receive value(s) for the argument(s): %s\" %\n+            (name, \", \".join(\"'%s'\" % p for p in unhandled_params + unhandled_kwargs)))\n+    return args, kwargs\n+\n+\n+def import_library(name):\n+    \"\"\"\n+    Load a Library object from a template tag module.\n+    \"\"\"\n+    try:\n+        module = import_module(name)\n+    except ImportError as e:\n+        raise InvalidTemplateLibrary(\n+            \"Invalid template library specified. ImportError raised when \"\n+            \"trying to load '%s': %s\" % (name, e)\n+        )\n+    try:\n+        return module.register\n+    except AttributeError:\n+        raise InvalidTemplateLibrary(\n+            \"Module  %s does not have a variable named 'register'\" % name,\n+        )\n\nbash execution output:\n    248\t            raise TemplateSyntaxError(\n   249\t                \"'%s' is decorated with takes_context=True so it must \"\n   250\t                \"have a first argument of 'context'\" % name)\n   251\t    args = []\n   252\t    kwargs = {}\n   253\t    args = []\n   254\t    kwargs = {}\n   255\t    unhandled_params = list(params)\n   256\t    # Treat all keyword-only names as acceptable keyword names. Track which\n   257\t    # keyword-only args are required (those without defaults).\n   258\t    unhandled_kwargs = list(kwonly)\n   259\t    required_kwonly = [\n   260\t        kwarg for kwarg in kwonly\n   261\t        if not kwonly_defaults or kwarg not in kwonly_defaults\n   262\t    ]\n   263\t    for bit in bits:\n   264\t        # First we try to extract a potential kwarg from the bit\n   265\t        kwarg = token_kwargs([bit], parser)\n   266\t        if kwarg:\n   267\t            # The kwarg was successfully extracted\n   268\t            param, value = kwarg.popitem()\n   269\t            if param in kwargs:\n   270\t                # The keyword argument has already been supplied once\n   271\t                raise TemplateSyntaxError(\n   272\t                    \"'%s' received multiple values for keyword argument '%s'\" %\n   273\t                    (name, param))\n   274\t            elif param not in params and param not in unhandled_kwargs and varkw is None:\n   275\t                # An unexpected keyword argument was supplied\n   276\t                raise TemplateSyntaxError(\n   277\t                    \"'%s' received unexpected keyword argument '%s'\" %\n   278\t                    (name, param))\n   279\t            else:\n   280\t                # All good, record the keyword argument\n   281\t                kwargs[str(param)] = value\n   282\t                if param in unhandled_params:\n   283\t                    # If using the keyword syntax for a positional arg, then\n   284\t                    # consume it.\n   285\t                    unhandled_params.remove(param)\n   286\t                elif param in unhandled_kwargs:\n   287\t                    # Same for keyword-only arguments\n   288\t                    unhandled_kwargs.remove(param)\n   289\t        else:\n   290\t            if kwargs:\n   291\t                raise TemplateSyntaxError(\n   292\t                    \"'%s' received some positional argument(s) after some \"\n   293\t                    \"keyword argument(s)\" % name)\n   294\t            else:\n   295\t                # Record the positional argument\n   296\t                args.append(parser.compile_filter(bit))\n\nDirectly response 'submit()' to finish, no other tokens.\nbash execution output:\n ERROR MSG: 'hi' received multiple values for keyword argument 'greeting'\n\nDirectly response 'submit()' to finish, no other tokens.\nTraceback (most recent call last):\n  File \"<string>\", line 318, in <module>\nNameError: name 'hi' is not defined\n"
  },
  "django__django-12273": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12273",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..0df4c972f9 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -403,6 +403,27 @@ class ModelState:\n \n class Model(metaclass=ModelBase):\n \n+    def __setattr__(self, name, value):\n+        # If assigning any primary-key field (including parent fields),\n+        # setting it to None should make the instance be treated as new\n+        # so save() will INSERT rather than overwrite. Clear all concrete\n+        # primary-key attnames on the instance to ensure multi-table\n+        # inheritance pk columns are cleared as well.\n+        try:\n+            if hasattr(self, '_meta') and hasattr(self, '_state'):\n+                for f in self._meta.get_fields():\n+                    att = getattr(f, 'attname', None)\n+                    if att == name and getattr(f, 'primary_key', False) and value is None:\n+                        self._state.adding = True\n+                        pk_attnames = [fld.attname for fld in self._meta.concrete_fields if getattr(fld, 'primary_key', False)]\n+                        for a in pk_attnames:\n+                            super().__setattr__(a, None)\n+                        break\n+        except Exception:\n+            pass\n+        return super().__setattr__(name, value)\n+\n+\n     def __init__(self, *args, **kwargs):\n         # Alias some things as locals to avoid repeat global lookups\n         cls = self.__class__\ndiff --git a/repro_debug.py b/repro_debug.py\nnew file mode 100644\nindex 0000000000..f1eef9dffb\n--- /dev/null\n+++ b/repro_debug.py\n@@ -0,0 +1,36 @@\n+from django.conf import settings\n+settings.configure(\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+    INSTALLED_APPS=[],\n+    USE_TZ=False,\n+)\n+import django\n+django.setup()\n+from django.db import models, connection\n+class Item(models.Model):\n+    uid = models.AutoField(primary_key=True, editable=False)\n+    f = models.BooleanField(default=False)\n+    def reset(self):\n+        self.uid = None\n+        self.f = False\n+    class Meta:\n+        app_label = 'tests'\n+class Derived(Item):\n+    class Meta:\n+        app_label = 'tests'\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Item)\n+    schema_editor.create_model(Derived)\n+d = Derived.objects.create(f=True)\n+print('initial pk:', d.pk)\n+print('counts before:', Item.objects.count(), Derived.objects.count())\n+item = Item.objects.get(pk=d.pk)\n+obj1 = item.derived\n+print('obj1 before_reset pk, adding:', getattr(obj1,'pk',None), getattr(obj1,'_state').adding)\n+obj1.reset()\n+print('obj1 after_reset pk, adding, uid attr:', getattr(obj1,'pk',None), getattr(obj1,'_state').adding, getattr(obj1,'uid',None))\n+obj1.save()\n+print('obj1 after_save pk, adding:', getattr(obj1,'pk',None), getattr(obj1,'_state').adding)\n+print('counts after:', Item.objects.count(), Derived.objects.count())\n+print('Items:', list(Item.objects.values_list('uid','f')))\n+print('Deriveds:', list(Derived.objects.values_list('item_ptr_id', 'f')))\ndiff --git a/repro_run.py b/repro_run.py\nnew file mode 100644\nindex 0000000000..340bd92c1f\n--- /dev/null\n+++ b/repro_run.py\n@@ -0,0 +1,32 @@\n+from django.conf import settings\n+settings.configure(\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+    INSTALLED_APPS=[],\n+    USE_TZ=False,\n+)\n+import django\n+django.setup()\n+from django.db import models, connection\n+class Item(models.Model):\n+    uid = models.AutoField(primary_key=True, editable=False)\n+    f = models.BooleanField(default=False)\n+    def reset(self):\n+        self.uid = None\n+        self.f = False\n+    class Meta:\n+        app_label = 'tests'\n+class Derived(Item):\n+    class Meta:\n+        app_label = 'tests'\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Item)\n+    schema_editor.create_model(Derived)\n+d = Derived.objects.create(f=True)\n+orig_pk = d.pk\n+item = Item.objects.get(pk=orig_pk)\n+obj1 = item.derived\n+obj1.reset()\n+obj1.save()\n+# After saving, the original object accessed by original PK should remain with f=True\n+obj = Item.objects.get(pk=orig_pk)\n+print('RESULT_F_IS_TRUE' if obj.f else 'RESULT_F_IS_FALSE')\n\n"
  },
  "django__django-12276": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12276",
    "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 338d54d72f..cdcfa24d39 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -272,9 +272,6 @@ class Widget(metaclass=MediaDefiningClass):\n         \"\"\"\n         return id_\n \n-    def use_required_attribute(self, initial):\n-        return not self.is_hidden\n-\n \n class Input(Widget):\n     \"\"\"\n@@ -387,10 +384,14 @@ class FileInput(Input):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in files\n \n+    def use_required_attribute(self, initial):\n+        return super().use_required_attribute(initial) and not initial\n+\n \n FILE_INPUT_CONTRADICTION = object()\n \n \n+    \n class ClearableFileInput(FileInput):\n     clear_checkbox_label = _('Clear')\n     initial_text = _('Currently')\n@@ -451,9 +452,7 @@ class ClearableFileInput(FileInput):\n             return False\n         return upload\n \n-    def use_required_attribute(self, initial):\n-        return super().use_required_attribute(initial) and not initial\n-\n+    \n     def value_omitted_from_data(self, data, files, name):\n         return (\n             super().value_omitted_from_data(data, files, name) and\n\n"
  },
  "django__django-12304": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12304",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex f48143ddaf..30891b741b 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -59,6 +59,8 @@ class ChoicesMeta(enum.EnumMeta):\n \n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n+    do_not_call_in_templates = True\n+\n     \"\"\"Class for creating enumerated choices.\"\"\"\n \n     def __str__(self):\n\n"
  },
  "django__django-12308": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12308",
    "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex e4ddc8f017..f7e992ac8f 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -398,6 +398,12 @@ def display_for_field(value, field, empty_value_display):\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    elif isinstance(field, models.JSONField):\n+        try:\n+            form_field = field.formfield()\n+            return form_field.prepare_value(value)\n+        except Exception:\n+            return display_for_value(value, empty_value_display)\n     else:\n         return display_for_value(value, empty_value_display)\n \ndiff --git a/django/contrib/admin/utils.py.bak b/django/contrib/admin/utils.py.bak\nnew file mode 100644\nindex 0000000000..e4ddc8f017\n--- /dev/null\n+++ b/django/contrib/admin/utils.py.bak\n@@ -0,0 +1,545 @@\n+import datetime\n+import decimal\n+from collections import defaultdict\n+\n+from django.core.exceptions import FieldDoesNotExist\n+from django.db import models, router\n+from django.db.models.constants import LOOKUP_SEP\n+from django.db.models.deletion import Collector\n+from django.forms.utils import pretty_name\n+from django.urls import NoReverseMatch, reverse\n+from django.utils import formats, timezone\n+from django.utils.html import format_html\n+from django.utils.regex_helper import _lazy_re_compile\n+from django.utils.text import capfirst\n+from django.utils.translation import ngettext, override as translation_override\n+\n+QUOTE_MAP = {i: '_%02X' % i for i in b'\":/_#?;@&=+$,\"[]<>%\\n\\\\'}\n+UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}\n+UNQUOTE_RE = _lazy_re_compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))\n+\n+\n+class FieldIsAForeignKeyColumnName(Exception):\n+    \"\"\"A field is a foreign key attname, i.e. <FK>_id.\"\"\"\n+    pass\n+\n+\n+def lookup_needs_distinct(opts, lookup_path):\n+    \"\"\"\n+    Return True if 'distinct()' should be used to query the given lookup path.\n+    \"\"\"\n+    lookup_fields = lookup_path.split(LOOKUP_SEP)\n+    # Go through the fields (following all relations) and look for an m2m.\n+    for field_name in lookup_fields:\n+        if field_name == 'pk':\n+            field_name = opts.pk.name\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            # Ignore query lookups.\n+            continue\n+        else:\n+            if hasattr(field, 'get_path_info'):\n+                # This field is a relation; update opts to follow the relation.\n+                path_info = field.get_path_info()\n+                opts = path_info[-1].to_opts\n+                if any(path.m2m for path in path_info):\n+                    # This field is a m2m relation so distinct must be called.\n+                    return True\n+    return False\n+\n+\n+def prepare_lookup_value(key, value):\n+    \"\"\"\n+    Return a lookup value prepared to be used in queryset filtering.\n+    \"\"\"\n+    # if key ends with __in, split parameter into separate values\n+    if key.endswith('__in'):\n+        value = value.split(',')\n+    # if key ends with __isnull, special case '' and the string literals 'false' and '0'\n+    elif key.endswith('__isnull'):\n+        value = value.lower() not in ('', 'false', '0')\n+    return value\n+\n+\n+def quote(s):\n+    \"\"\"\n+    Ensure that primary key values do not confuse the admin URLs by escaping\n+    any '/', '_' and ':' and similarly problematic characters.\n+    Similar to urllib.parse.quote(), except that the quoting is slightly\n+    different so that it doesn't get automatically unquoted by the Web browser.\n+    \"\"\"\n+    return s.translate(QUOTE_MAP) if isinstance(s, str) else s\n+\n+\n+def unquote(s):\n+    \"\"\"Undo the effects of quote().\"\"\"\n+    return UNQUOTE_RE.sub(lambda m: UNQUOTE_MAP[m.group(0)], s)\n+\n+\n+def flatten(fields):\n+    \"\"\"\n+    Return a list which is a single level of flattening of the original list.\n+    \"\"\"\n+    flat = []\n+    for field in fields:\n+        if isinstance(field, (list, tuple)):\n+            flat.extend(field)\n+        else:\n+            flat.append(field)\n+    return flat\n+\n+\n+def flatten_fieldsets(fieldsets):\n+    \"\"\"Return a list of field names from an admin fieldsets structure.\"\"\"\n+    field_names = []\n+    for name, opts in fieldsets:\n+        field_names.extend(\n+            flatten(opts['fields'])\n+        )\n+    return field_names\n+\n+\n+def get_deleted_objects(objs, request, admin_site):\n+    \"\"\"\n+    Find all objects related to ``objs`` that should also be deleted. ``objs``\n+    must be a homogeneous iterable of objects (e.g. a QuerySet).\n+\n+    Return a nested list of strings suitable for display in the\n+    template with the ``unordered_list`` filter.\n+    \"\"\"\n+    try:\n+        obj = objs[0]\n+    except IndexError:\n+        return [], {}, set(), []\n+    else:\n+        using = router.db_for_write(obj._meta.model)\n+    collector = NestedObjects(using=using)\n+    collector.collect(objs)\n+    perms_needed = set()\n+\n+    def format_callback(obj):\n+        model = obj.__class__\n+        has_admin = model in admin_site._registry\n+        opts = obj._meta\n+\n+        no_edit_link = '%s: %s' % (capfirst(opts.verbose_name), obj)\n+\n+        if has_admin:\n+            if not admin_site._registry[model].has_delete_permission(request, obj):\n+                perms_needed.add(opts.verbose_name)\n+            try:\n+                admin_url = reverse('%s:%s_%s_change'\n+                                    % (admin_site.name,\n+                                       opts.app_label,\n+                                       opts.model_name),\n+                                    None, (quote(obj.pk),))\n+            except NoReverseMatch:\n+                # Change url doesn't exist -- don't display link to edit\n+                return no_edit_link\n+\n+            # Display a link to the admin page.\n+            return format_html('{}: <a href=\"{}\">{}</a>',\n+                               capfirst(opts.verbose_name),\n+                               admin_url,\n+                               obj)\n+        else:\n+            # Don't display link to edit, because it either has no\n+            # admin or is edited inline.\n+            return no_edit_link\n+\n+    to_delete = collector.nested(format_callback)\n+\n+    protected = [format_callback(obj) for obj in collector.protected]\n+    model_count = {model._meta.verbose_name_plural: len(objs) for model, objs in collector.model_objs.items()}\n+\n+    return to_delete, model_count, perms_needed, protected\n+\n+\n+class NestedObjects(Collector):\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.edges = {}  # {from_instance: [to_instances]}\n+        self.protected = set()\n+        self.model_objs = defaultdict(set)\n+\n+    def add_edge(self, source, target):\n+        self.edges.setdefault(source, []).append(target)\n+\n+    def collect(self, objs, source=None, source_attr=None, **kwargs):\n+        for obj in objs:\n+            if source_attr and not source_attr.endswith('+'):\n+                related_name = source_attr % {\n+                    'class': source._meta.model_name,\n+                    'app_label': source._meta.app_label,\n+                }\n+                self.add_edge(getattr(obj, related_name), obj)\n+            else:\n+                self.add_edge(None, obj)\n+            self.model_objs[obj._meta.model].add(obj)\n+        try:\n+            return super().collect(objs, source_attr=source_attr, **kwargs)\n+        except models.ProtectedError as e:\n+            self.protected.update(e.protected_objects)\n+        except models.RestrictedError as e:\n+            self.protected.update(e.restricted_objects)\n+\n+    def related_objects(self, related_model, related_fields, objs):\n+        qs = super().related_objects(related_model, related_fields, objs)\n+        return qs.select_related(*[related_field.name for related_field in related_fields])\n+\n+    def _nested(self, obj, seen, format_callback):\n+        if obj in seen:\n+            return []\n+        seen.add(obj)\n+        children = []\n+        for child in self.edges.get(obj, ()):\n+            children.extend(self._nested(child, seen, format_callback))\n+        if format_callback:\n+            ret = [format_callback(obj)]\n+        else:\n+            ret = [obj]\n+        if children:\n+            ret.append(children)\n+        return ret\n+\n+    def nested(self, format_callback=None):\n+        \"\"\"\n+        Return the graph as a nested list.\n+        \"\"\"\n+        seen = set()\n+        roots = []\n+        for root in self.edges.get(None, ()):\n+            roots.extend(self._nested(root, seen, format_callback))\n+        return roots\n+\n+    def can_fast_delete(self, *args, **kwargs):\n+        \"\"\"\n+        We always want to load the objects into memory so that we can display\n+        them to the user in confirm page.\n+        \"\"\"\n+        return False\n+\n+\n+def model_format_dict(obj):\n+    \"\"\"\n+    Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',\n+    typically for use with string formatting.\n+\n+    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.\n+    \"\"\"\n+    if isinstance(obj, (models.Model, models.base.ModelBase)):\n+        opts = obj._meta\n+    elif isinstance(obj, models.query.QuerySet):\n+        opts = obj.model._meta\n+    else:\n+        opts = obj\n+    return {\n+        'verbose_name': opts.verbose_name,\n+        'verbose_name_plural': opts.verbose_name_plural,\n+    }\n+\n+\n+def model_ngettext(obj, n=None):\n+    \"\"\"\n+    Return the appropriate `verbose_name` or `verbose_name_plural` value for\n+    `obj` depending on the count `n`.\n+\n+    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.\n+    If `obj` is a `QuerySet` instance, `n` is optional and the length of the\n+    `QuerySet` is used.\n+    \"\"\"\n+    if isinstance(obj, models.query.QuerySet):\n+        if n is None:\n+            n = obj.count()\n+        obj = obj.model\n+    d = model_format_dict(obj)\n+    singular, plural = d[\"verbose_name\"], d[\"verbose_name_plural\"]\n+    return ngettext(singular, plural, n or 0)\n+\n+\n+def lookup_field(name, obj, model_admin=None):\n+    opts = obj._meta\n+    try:\n+        f = _get_non_gfk_field(opts, name)\n+    except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):\n+        # For non-field values, the value is either a method, property or\n+        # returned via a callable.\n+        if callable(name):\n+            attr = name\n+            value = attr(obj)\n+        elif hasattr(model_admin, name) and name != '__str__':\n+            attr = getattr(model_admin, name)\n+            value = attr(obj)\n+        else:\n+            attr = getattr(obj, name)\n+            if callable(attr):\n+                value = attr()\n+            else:\n+                value = attr\n+        f = None\n+    else:\n+        attr = None\n+        value = getattr(obj, name)\n+    return f, attr, value\n+\n+\n+def _get_non_gfk_field(opts, name):\n+    \"\"\"\n+    For historical reasons, the admin app relies on GenericForeignKeys as being\n+    \"not found\" by get_field(). This could likely be cleaned up.\n+\n+    Reverse relations should also be excluded as these aren't attributes of the\n+    model (rather something like `foo_set`).\n+    \"\"\"\n+    field = opts.get_field(name)\n+    if (field.is_relation and\n+            # Generic foreign keys OR reverse relations\n+            ((field.many_to_one and not field.related_model) or field.one_to_many)):\n+        raise FieldDoesNotExist()\n+\n+    # Avoid coercing <FK>_id fields to FK\n+    if field.is_relation and not field.many_to_many and hasattr(field, 'attname') and field.attname == name:\n+        raise FieldIsAForeignKeyColumnName()\n+\n+    return field\n+\n+\n+def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n+    \"\"\"\n+    Return a sensible label for a field name. The name can be a callable,\n+    property (but not created with @property decorator), or the name of an\n+    object's attribute, as well as a model field. If return_attr is True, also\n+    return the resolved attribute (which could be a callable). This will be\n+    None if (and only if) the name refers to a field.\n+    \"\"\"\n+    attr = None\n+    try:\n+        field = _get_non_gfk_field(model._meta, name)\n+        try:\n+            label = field.verbose_name\n+        except AttributeError:\n+            # field is likely a ForeignObjectRel\n+            label = field.related_model._meta.verbose_name\n+    except FieldDoesNotExist:\n+        if name == \"__str__\":\n+            label = str(model._meta.verbose_name)\n+            attr = str\n+        else:\n+            if callable(name):\n+                attr = name\n+            elif hasattr(model_admin, name):\n+                attr = getattr(model_admin, name)\n+            elif hasattr(model, name):\n+                attr = getattr(model, name)\n+            elif form and name in form.fields:\n+                attr = form.fields[name]\n+            else:\n+                message = \"Unable to lookup '%s' on %s\" % (name, model._meta.object_name)\n+                if model_admin:\n+                    message += \" or %s\" % model_admin.__class__.__name__\n+                if form:\n+                    message += \" or %s\" % form.__class__.__name__\n+                raise AttributeError(message)\n+\n+            if hasattr(attr, \"short_description\"):\n+                label = attr.short_description\n+            elif (isinstance(attr, property) and\n+                  hasattr(attr, \"fget\") and\n+                  hasattr(attr.fget, \"short_description\")):\n+                label = attr.fget.short_description\n+            elif callable(attr):\n+                if attr.__name__ == \"<lambda>\":\n+                    label = \"--\"\n+                else:\n+                    label = pretty_name(attr.__name__)\n+            else:\n+                label = pretty_name(name)\n+    except FieldIsAForeignKeyColumnName:\n+        label = pretty_name(name)\n+        attr = name\n+\n+    if return_attr:\n+        return (label, attr)\n+    else:\n+        return label\n+\n+\n+def help_text_for_field(name, model):\n+    help_text = \"\"\n+    try:\n+        field = _get_non_gfk_field(model._meta, name)\n+    except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):\n+        pass\n+    else:\n+        if hasattr(field, 'help_text'):\n+            help_text = field.help_text\n+    return help_text\n+\n+\n+def display_for_field(value, field, empty_value_display):\n+    from django.contrib.admin.templatetags.admin_list import _boolean_icon\n+\n+    if getattr(field, 'flatchoices', None):\n+        return dict(field.flatchoices).get(value, empty_value_display)\n+    # BooleanField needs special-case null-handling, so it comes before the\n+    # general null test.\n+    elif isinstance(field, models.BooleanField):\n+        return _boolean_icon(value)\n+    elif value is None:\n+        return empty_value_display\n+    elif isinstance(field, models.DateTimeField):\n+        return formats.localize(timezone.template_localtime(value))\n+    elif isinstance(field, (models.DateField, models.TimeField)):\n+        return formats.localize(value)\n+    elif isinstance(field, models.DecimalField):\n+        return formats.number_format(value, field.decimal_places)\n+    elif isinstance(field, (models.IntegerField, models.FloatField)):\n+        return formats.number_format(value)\n+    elif isinstance(field, models.FileField) and value:\n+        return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    else:\n+        return display_for_value(value, empty_value_display)\n+\n+\n+def display_for_value(value, empty_value_display, boolean=False):\n+    from django.contrib.admin.templatetags.admin_list import _boolean_icon\n+\n+    if boolean:\n+        return _boolean_icon(value)\n+    elif value is None:\n+        return empty_value_display\n+    elif isinstance(value, bool):\n+        return str(value)\n+    elif isinstance(value, datetime.datetime):\n+        return formats.localize(timezone.template_localtime(value))\n+    elif isinstance(value, (datetime.date, datetime.time)):\n+        return formats.localize(value)\n+    elif isinstance(value, (int, decimal.Decimal, float)):\n+        return formats.number_format(value)\n+    elif isinstance(value, (list, tuple)):\n+        return ', '.join(str(v) for v in value)\n+    else:\n+        return str(value)\n+\n+\n+class NotRelationField(Exception):\n+    pass\n+\n+\n+def get_model_from_relation(field):\n+    if hasattr(field, 'get_path_info'):\n+        return field.get_path_info()[-1].to_opts.model\n+    else:\n+        raise NotRelationField\n+\n+\n+def reverse_field_path(model, path):\n+    \"\"\" Create a reversed field path.\n+\n+    E.g. Given (Order, \"user__groups\"),\n+    return (Group, \"user__order\").\n+\n+    Final field must be a related model, not a data field.\n+    \"\"\"\n+    reversed_path = []\n+    parent = model\n+    pieces = path.split(LOOKUP_SEP)\n+    for piece in pieces:\n+        field = parent._meta.get_field(piece)\n+        # skip trailing data field if extant:\n+        if len(reversed_path) == len(pieces) - 1:  # final iteration\n+            try:\n+                get_model_from_relation(field)\n+            except NotRelationField:\n+                break\n+\n+        # Field should point to another model\n+        if field.is_relation and not (field.auto_created and not field.concrete):\n+            related_name = field.related_query_name()\n+            parent = field.remote_field.model\n+        else:\n+            related_name = field.field.name\n+            parent = field.related_model\n+        reversed_path.insert(0, related_name)\n+    return (parent, LOOKUP_SEP.join(reversed_path))\n+\n+\n+def get_fields_from_path(model, path):\n+    \"\"\" Return list of Fields given path relative to model.\n+\n+    e.g. (ModelX, \"user__groups__name\") -> [\n+        <django.db.models.fields.related.ForeignKey object at 0x...>,\n+        <django.db.models.fields.related.ManyToManyField object at 0x...>,\n+        <django.db.models.fields.CharField object at 0x...>,\n+    ]\n+    \"\"\"\n+    pieces = path.split(LOOKUP_SEP)\n+    fields = []\n+    for piece in pieces:\n+        if fields:\n+            parent = get_model_from_relation(fields[-1])\n+        else:\n+            parent = model\n+        fields.append(parent._meta.get_field(piece))\n+    return fields\n+\n+\n+def construct_change_message(form, formsets, add):\n+    \"\"\"\n+    Construct a JSON structure describing changes from a changed object.\n+    Translations are deactivated so that strings are stored untranslated.\n+    Translation happens later on LogEntry access.\n+    \"\"\"\n+    # Evaluating `form.changed_data` prior to disabling translations is required\n+    # to avoid fields affected by localization from being included incorrectly,\n+    # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.\n+    changed_data = form.changed_data\n+    with translation_override(None):\n+        # Deactivate translations while fetching verbose_name for form\n+        # field labels and using `field_name`, if verbose_name is not provided.\n+        # Translations will happen later on LogEntry access.\n+        changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)\n+\n+    change_message = []\n+    if add:\n+        change_message.append({'added': {}})\n+    elif form.changed_data:\n+        change_message.append({'changed': {'fields': changed_field_labels}})\n+    if formsets:\n+        with translation_override(None):\n+            for formset in formsets:\n+                for added_object in formset.new_objects:\n+                    change_message.append({\n+                        'added': {\n+                            'name': str(added_object._meta.verbose_name),\n+                            'object': str(added_object),\n+                        }\n+                    })\n+                for changed_object, changed_fields in formset.changed_objects:\n+                    change_message.append({\n+                        'changed': {\n+                            'name': str(changed_object._meta.verbose_name),\n+                            'object': str(changed_object),\n+                            'fields': _get_changed_field_labels_from_form(formset.forms[0], changed_fields),\n+                        }\n+                    })\n+                for deleted_object in formset.deleted_objects:\n+                    change_message.append({\n+                        'deleted': {\n+                            'name': str(deleted_object._meta.verbose_name),\n+                            'object': str(deleted_object),\n+                        }\n+                    })\n+    return change_message\n+\n+\n+def _get_changed_field_labels_from_form(form, changed_data):\n+    changed_field_labels = []\n+    for field_name in changed_data:\n+        try:\n+            verbose_field_name = form.fields[field_name].label or field_name\n+        except KeyError:\n+            verbose_field_name = field_name\n+        changed_field_labels.append(str(verbose_field_name))\n+    return changed_field_labels\n\n"
  },
  "django__django-12325": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12325",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..5a3962194c 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -201,10 +201,17 @@ class ModelBase(type):\n             if base != new_class and not base._meta.abstract:\n                 continue\n             # Locate OneToOneField instances.\n-            for field in base._meta.local_fields:\n-                if isinstance(field, OneToOneField):\n-                    related = resolve_relation(new_class, field.remote_field.model)\n-                    parent_links[make_model_tuple(related)] = field\n+        for field in base._meta.local_fields:\n+            if isinstance(field, OneToOneField):\n+                related = resolve_relation(new_class, field.remote_field.model)\n+                key = make_model_tuple(related)\n+                existing = parent_links.get(key)\n+                new_parent_link = getattr(getattr(field, 'remote_field', None), 'parent_link', False)\n+                existing_parent_link = getattr(getattr(existing, 'remote_field', None), 'parent_link', False) if existing is not None else False\n+                # Prefer an explicitly declared parent_link=True field when multiple OneToOneFields target the same parent.\n+                if existing is None or new_parent_link or not existing_parent_link:\n+                    parent_links[key] = field\n+\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\ndiff --git a/reproapp/__init__.py b/reproapp/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/reproapp/migrations/0001_initial.py b/reproapp/migrations/0001_initial.py\nnew file mode 100644\nindex 0000000000..4ede4ff43a\n--- /dev/null\n+++ b/reproapp/migrations/0001_initial.py\n@@ -0,0 +1,29 @@\n+# Generated by Django 3.1 on 2026-01-12 05:34\n+\n+from django.db import migrations, models\n+import django.db.models.deletion\n+\n+\n+class Migration(migrations.Migration):\n+\n+    initial = True\n+\n+    dependencies = [\n+    ]\n+\n+    operations = [\n+        migrations.CreateModel(\n+            name='Document',\n+            fields=[\n+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ],\n+        ),\n+        migrations.CreateModel(\n+            name='Picking',\n+            fields=[\n+                ('document_ptr', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, related_name='+', serialize=False, to='reproapp.Document')),\n+                ('origin', models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='picking', to='reproapp.Document')),\n+            ],\n+            bases=('reproapp.document',),\n+        ),\n+    ]\ndiff --git a/reproapp/migrations/__init__.py b/reproapp/migrations/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/reproapp/models.py b/reproapp/models.py\nnew file mode 100644\nindex 0000000000..847e470218\n--- /dev/null\n+++ b/reproapp/models.py\n@@ -0,0 +1,7 @@\n+from django.db import models\n+class Document(models.Model):\n+    pass\n+\n+class Picking(Document):\n+    document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+    origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\ndiff --git a/reproproj/__init__.py b/reproproj/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/reproproj/manage.py b/reproproj/manage.py\nnew file mode 100644\nindex 0000000000..4539e84e26\n--- /dev/null\n+++ b/reproproj/manage.py\n@@ -0,0 +1,5 @@\n+#!/usr/bin/env python3\n+import os,sys\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE','reproproj.settings')\n+from django.core.management import execute_from_command_line\n+execute_from_command_line(sys.argv)\ndiff --git a/reproproj/reproapp/__init__.py b/reproproj/reproapp/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/reproproj/reproapp/models.py b/reproproj/reproapp/models.py\nnew file mode 100644\nindex 0000000000..847e470218\n--- /dev/null\n+++ b/reproproj/reproapp/models.py\n@@ -0,0 +1,7 @@\n+from django.db import models\n+class Document(models.Model):\n+    pass\n+\n+class Picking(Document):\n+    document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+    origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\ndiff --git a/reproproj/settings.py b/reproproj/settings.py\nnew file mode 100644\nindex 0000000000..8584c28451\n--- /dev/null\n+++ b/reproproj/settings.py\n@@ -0,0 +1,3 @@\n+SECRET_KEY='x'\n+INSTALLED_APPS=['django.contrib.contenttypes','reproapp']\n+DATABASES={'default':{'ENGINE':'django.db.backends.sqlite3','NAME':'/tmp/db.sqlite3'}}\ndiff --git a/reproproj/urls.py b/reproproj/urls.py\nnew file mode 100644\nindex 0000000000..2379fc621e\n--- /dev/null\n+++ b/reproproj/urls.py\n@@ -0,0 +1 @@\n+urlpatterns=[]\ndiff --git a/tests/test_parent_link_preference.py b/tests/test_parent_link_preference.py\nnew file mode 100644\nindex 0000000000..d9a1f1241c\n--- /dev/null\n+++ b/tests/test_parent_link_preference.py\n@@ -0,0 +1,23 @@\n+from django.db import models\n+from django.test import TestCase\n+class Document(models.Model):\n+    pass\n+\n+class Picking(models.Model, models.Model.__class__):\n+    class Meta:\n+        app_label = 'reproapp'\n+# We'll create models dynamically in test to mimic one-to-one collisions\n+def make_models():\n+    class Document(models.Model):\n+        class Meta:\n+            app_label = 'reproapp'\n+    class Picking(Document):\n+        document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+        origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n+    return Picking\n+\n+class ParentLinkTest(TestCase):\n+    def test_parent_link_chosen(self):\n+        PickingModel = make_models()\n+        # ensure pk was setup from the parent ptr\n+        self.assertTrue(any(getattr(f.remote_field, 'parent_link', False) for f in PickingModel._meta.local_fields if getattr(f, 'one_to_one', False)))\n\n"
  },
  "django__django-12406": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12406",
    "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex dafc11f995..d2e6b62461 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1185,8 +1185,21 @@ class ModelChoiceField(ChoiceField):\n                  required=True, widget=None, label=None, initial=None,\n                  help_text='', to_field_name=None, limit_choices_to=None,\n                  **kwargs):\n+        # Don't show the empty_label for required ModelChoiceFields rendered\n+        # as radio buttons (RadioSelect), since radio widgets have an inherent\n+        # unfilled state and a blank choice would appear as a selectable option.\n+        widget_is_radio = False\n+        if widget is not None:\n+            try:\n+                from django.forms.widgets import RadioSelect\n+                widget_cls = widget if isinstance(widget, type) else widget.__class__\n+                widget_is_radio = issubclass(widget_cls, RadioSelect)\n+            except Exception:\n+                widget_is_radio = False\n         if required and (initial is not None):\n             self.empty_label = None\n+        elif required and widget_is_radio:\n+            self.empty_label = None\n         else:\n             self.empty_label = empty_label\n \n\n"
  },
  "django__django-12708": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12708",
    "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..851bae8d17 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -408,11 +408,22 @@ class BaseDatabaseSchemaEditor:\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            # Disambiguate when introspection reports both a unique and an index\n+            # for the same columns (some backends mark uniques as indexed).\n+            if constraint_kwargs.get('index') is True:\n+                constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names, index=True, unique=False\n+                )\n+            elif constraint_kwargs.get('unique') is True:\n+                constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names, unique=True, index=False\n+                )\n+            if len(constraint_names) != 1:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\ndiff --git a/repro.py b/repro.py\nnew file mode 100644\nindex 0000000000..e819f92aea\n--- /dev/null\n+++ b/repro.py\n@@ -0,0 +1,5 @@\n+# Minimal static simulation of _constraint_names behavior\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+from types import SimpleNamespace\n+editor=BaseDatabaseSchemaEditor()\n+print('loaded')\n\n"
  },
  "django__django-12713": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12713",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 69a5fbf389..c1e357d328 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -250,16 +250,17 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         db = kwargs.get('using')\n \n         autocomplete_fields = self.get_autocomplete_fields(request)\n-        if db_field.name in autocomplete_fields:\n-            kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in self.raw_id_fields:\n-            kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n-            kwargs['widget'] = widgets.FilteredSelectMultiple(\n-                db_field.verbose_name,\n-                db_field.name in self.filter_vertical\n-            )\n-\n+        if 'widget' not in kwargs:\n+            if db_field.name in autocomplete_fields:\n+                kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in self.raw_id_fields:\n+                kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n+                kwargs['widget'] = widgets.FilteredSelectMultiple(\n+                    db_field.verbose_name,\n+                    db_field.name in self.filter_vertical\n+                )\n+    \n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n             if queryset is not None:\ndiff --git a/repro_m2m.py b/repro_m2m.py\nnew file mode 100644\nindex 0000000000..740c4ab10e\n--- /dev/null\n+++ b/repro_m2m.py\n@@ -0,0 +1,18 @@\n+from django import forms\n+from django.contrib.admin.options import ModelAdmin\n+from django.db import models\n+class Tag(models.Model):\n+    name = models.CharField(max_length=10)\n+    class Meta:\n+        app_label='tests'\n+class Post(models.Model):\n+    tags = models.ManyToManyField(Tag)\n+    class Meta:\n+        app_label='tests'\n+class MyAdmin(ModelAdmin):\n+    def formfield_for_manytomany(self, db_field, request, **kwargs):\n+        kwargs['widget'] = forms.CheckboxSelectMultiple()\n+        return super().formfield_for_manytomany(db_field, request, **kwargs)\n+admin = MyAdmin(Post, None)\n+field = admin.formfield_for_manytomany(Post.tags.field, request=None)\n+print(type(field.widget))\ndiff --git a/verify_m2m_widget.py b/verify_m2m_widget.py\nnew file mode 100644\nindex 0000000000..af9a7a56a8\n--- /dev/null\n+++ b/verify_m2m_widget.py\n@@ -0,0 +1,34 @@\n+from django import forms\n+from django.forms.widgets import SelectMultiple, CheckboxSelectMultiple\n+from django.contrib.admin.options import ModelAdmin\n+class DummyMeta: pass\n+class DummyModel:\n+    _meta = DummyMeta()\n+class FakeThroughMeta:\n+    auto_created = True\n+class FakeThrough:\n+    _meta = FakeThroughMeta()\n+class FakeRemoteField:\n+    def __init__(self):\n+        self.through = FakeThrough()\n+        self.model = object\n+class FakeField:\n+    def __init__(self, name='tags'):\n+        self.name = name\n+        self.remote_field = FakeRemoteField()\n+        self.verbose_name = 'tags'\n+    def formfield(self, **kwargs):\n+        widget = kwargs.get('widget', SelectMultiple())\n+        f = forms.MultipleChoiceField(choices=[], widget=widget)\n+        f.help_text = kwargs.get('help_text', '')\n+        return f\n+class DummySite:\n+    def __init__(self):\n+        self._registry = {}\n+        self.empty_value_display = '(None)'\n+admin = ModelAdmin(DummyModel, DummySite())\n+f = FakeField()\n+field_with_custom = admin.formfield_for_manytomany(f, request=None, widget=CheckboxSelectMultiple())\n+field_without_custom = admin.formfield_for_manytomany(f, request=None)\n+print('with_custom_widget:', type(field_with_custom.widget).__name__)\n+print('without_custom_widget:', type(field_without_custom.widget).__name__)\n\n"
  },
  "django__django-12774": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12774",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex d9c9b0db04..dfdb72080f 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -689,8 +689,22 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\n-        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n-            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+        if field_name != 'pk':\n+            field = self.model._meta.get_field(field_name)\n+            is_unique_field = field.unique\n+            if not is_unique_field:\n+                constraints = getattr(self.model._meta, 'constraints', ())\n+                for constraint in constraints:\n+                    try:\n+                        is_unique = getattr(constraint, 'unique', False)\n+                        fields = getattr(constraint, 'fields', None)\n+                    except Exception:\n+                        continue\n+                    if is_unique and fields and len(fields) == 1 and fields[0] == field_name:\n+                        is_unique_field = True\n+                        break\n+            if not is_unique_field:\n+                raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\ndiff --git a/reproduce_in_bulk_check.py b/reproduce_in_bulk_check.py\nnew file mode 100644\nindex 0000000000..19bd22dc22\n--- /dev/null\n+++ b/reproduce_in_bulk_check.py\n@@ -0,0 +1,47 @@\n+class DummyField:\n+    def __init__(self, unique=False):\n+        self.unique = unique\n+class DummyConstraint:\n+    def __init__(self, unique, fields):\n+        self.unique = unique\n+        self.fields = fields\n+class DummyMeta:\n+    def __init__(self, field, constraints):\n+        self._field = field\n+        self.constraints = constraints\n+    def get_field(self, name):\n+        if name == 'slug':\n+            return self._field\n+        raise LookupError(name)\n+def check_field_unique(meta, field_name):\n+    if field_name != 'pk':\n+        field = meta.get_field(field_name)\n+        is_unique_field = field.unique\n+        if not is_unique_field:\n+            constraints = getattr(meta, 'constraints', ())\n+            for constraint in constraints:\n+                try:\n+                    is_unique = getattr(constraint, 'unique', False)\n+                    fields = getattr(constraint, 'fields', None)\n+                except Exception:\n+                    continue\n+                if is_unique and fields and len(fields) == 1 and fields[0] == field_name:\n+                    is_unique_field = True\n+                    break\n+        if not is_unique_field:\n+            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+    return True\n+# Case 1: field.unique=True (legacy unique=True)\n+meta1 = DummyMeta(DummyField(unique=True), ())\n+print('unique_field_ok:', check_field_unique(meta1, 'slug'))\n+# Case 2: field.unique=False but UniqueConstraint exists on single field\n+uc = DummyConstraint(True, ['slug'])\n+meta2 = DummyMeta(DummyField(unique=False), (uc,))\n+print('unique_via_constraint_ok:', check_field_unique(meta2, 'slug'))\n+# Case 3: non-unique field and no single-field UniqueConstraint -> should raise\n+meta3 = DummyMeta(DummyField(unique=False), ())\n+try:\n+    check_field_unique(meta3, 'slug')\n+    print('unexpected_ok_for_non_unique')\n+except ValueError as e:\n+    print('expected_error:', str(e))\n\n"
  },
  "django__django-9296": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-9296",
    "model_patch": "diff --git a/django/core/paginator.py b/django/core/paginator.py\nindex 1f92da5d4f..8ffad51a74 100644\n--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -106,6 +106,11 @@ class Paginator:\n         \"\"\"\n         return range(1, self.num_pages + 1)\n \n+    def __iter__(self):\n+        for page_num in self.page_range:\n+            yield self.page(page_num)\n+\n+\n     def _check_object_list_is_ordered(self):\n         \"\"\"\n         Warn if self.object_list is unordered (typically a QuerySet).\n\n"
  },
  "sphinx-doc__sphinx-10323": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10323",
    "model_patch": "diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py\nindex dc44ed314..9437fe9a5 100644\n--- a/sphinx/directives/code.py\n+++ b/sphinx/directives/code.py\n@@ -224,9 +224,9 @@ class LiteralIncludeReader:\n                        self.start_filter,\n                        self.end_filter,\n                        self.lines_filter,\n+                       self.dedent_filter,\n                        self.prepend_filter,\n-                       self.append_filter,\n-                       self.dedent_filter]\n+                       self.append_filter]\n             lines = self.read_file(self.filename, location=location)\n             for func in filters:\n                 lines = func(lines, location=location)\n\n"
  },
  "sphinx-doc__sphinx-10435": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10435",
    "model_patch": "diff --git a/sphinx/texinputs/sphinxlatexliterals.sty b/sphinx/texinputs/sphinxlatexliterals.sty\nindex cc768c25b..023951449 100644\n--- a/sphinx/texinputs/sphinxlatexliterals.sty\n+++ b/sphinx/texinputs/sphinxlatexliterals.sty\n@@ -767,7 +767,7 @@\n \\newcommand*{\\sphinxhyphenininlineliteral}{\\sphinxhyphennobreak}\n % the macro must be protected if it ends up used in moving arguments,\n % in 'alltt' \\@noligs is done already, and the \\scantokens must be avoided.\n-\\protected\\def\\sphinxupquote#1{{\\def\\@tempa{alltt}%\n+\\protected\\def\\sphinxupquote#1{{\\def\\@tempa{alltt}%\\ignorespaces\n   \\ifx\\@tempa\\@currenvir\\else\n    \\let\\sphinxhyphen\\sphinxhyphenininlineliteral\n    \\ifspx@opt@inlineliteralwraps\n@@ -794,7 +794,7 @@\n    \\let\\do@noligs\\sphinx@do@noligs\n    \\@noligs\\endlinechar\\m@ne\\everyeof{}% (<- in case inside \\sphinxhref)\n    \\expandafter\\scantokens\n-  \\fi {{#1}}}}% extra brace pair to fix end-space gobbling issue...\n+  \\fi {{#1\\unskip}}}}% extra brace pair to fix end-space gobbling issue...\n \\def\\sphinx@do@noligs #1{\\catcode`#1\\active\\begingroup\\lccode`\\~`#1\\relax\n     \\lowercase{\\endgroup\\def~{\\leavevmode\\kern\\z@\\char`#1 }}}\n \\def\\sphinx@literal@nolig@list {\\do\\`\\do\\<\\do\\>\\do\\'\\do\\-}%\ndiff --git a/sphinx/texinputs/sphinxlatexliterals.sty.bak b/sphinx/texinputs/sphinxlatexliterals.sty.bak\nnew file mode 100644\nindex 000000000..cc768c25b\n--- /dev/null\n+++ b/sphinx/texinputs/sphinxlatexliterals.sty.bak\n@@ -0,0 +1,804 @@\n+%% LITERAL BLOCKS\n+%\n+% change this info string if making any custom modification\n+\\ProvidesFile{sphinxlatexliterals.sty}[2021/12/06 code-blocks and parsed literals]\n+\n+% Provides support for this output mark-up from Sphinx latex writer:\n+%\n+% - macros:\n+%   - \\sphinxLiteralBlockLabel\n+%   - \\sphinxSetupCaptionForVerbatim\n+%   - \\sphinxSetupCodeBlockInFootnote\n+%   - \\sphinxhref\n+%   - \\sphinxnolinkurl\n+%   - \\sphinxresetverbatimhllines\n+%   - \\sphinxunactivateextrasandspace\n+%   - \\sphinxupquote\n+%   - \\sphinxurl\n+%\n+% - environments:\n+%   - sphinxVerbatim\n+%   - sphinxVerbatimintable\n+%   - sphinxalltt\n+%\n+% Dependency:\n+%\n+% - hyperref (for \\phantomsection and \\capstart) (loaded later)\n+%\n+% Executes \\RequirePackage for:\n+%\n+% - framed\n+% - fancyvrb\n+% - alltt\n+% - upquote\n+% - needspace\n+\n+% also in sphinxlatexadmonitions.sty:\n+% This is a workaround to a \"feature\" of French lists, when literal block\n+% follows immediately; usable generally (does only \\par then), a priori...\n+\\providecommand*\\sphinxvspacefixafterfrenchlists{%\n+   \\ifvmode\\ifdim\\lastskip<\\z@ \\vskip\\parskip\\fi\\else\\par\\fi\n+}\n+\n+% For framing allowing pagebreaks\n+\\RequirePackage{framed}\n+% For source code\n+% MEMO: fancyvrb is used mainly to\n+% 1- control horizontal and vertical spacing\n+% 2- optional line numbering\n+% 3- optional line emphasizing\n+% 4- while still allowing expansion of Pygments latex mark-up\n+% Other aspects such as framing, caption handling, codeline wrapping are\n+% added on top of it. We should stop using fancyvrb and implement\n+% 1, 2, 3, 4 by own Sphinx fully native Verbatim. This would allow to solve\n+% limitations with wrapped long code line not allowing page break.\n+\\RequirePackage{fancyvrb}\n+% For parsed-literal blocks.\n+\\RequirePackage{alltt}\n+% Display \"real\" single quotes in literal blocks.\n+\\RequirePackage{upquote}\n+% Skip to next page if not enough space at bottom\n+\\RequirePackage{needspace}\n+\n+% Based on use of \"fancyvrb.sty\"'s Verbatim.\n+% - with framing allowing page breaks (\"framed.sty\")\n+% - with breaking of long lines (exploits Pygments mark-up),\n+% - with possibly of a top caption, non-separable by pagebreak.\n+% - and usable inside tables or footnotes (\"sphinxpackagefootnote.sty\").\n+\n+% for emphasizing lines\n+\\define@key{FV}{hllines}{\\def\\sphinx@verbatim@checkifhl##1{\\in@{, ##1,}{#1}}}\n+% sphinxVerbatim must be usable by third party without requiring hllines set-up\n+\\def\\sphinxresetverbatimhllines{\\def\\sphinx@verbatim@checkifhl##1{\\in@false}}\n+\\sphinxresetverbatimhllines\n+\n+% Prior to Sphinx 1.5, \\Verbatim and \\endVerbatim were modified by Sphinx.\n+% The aliases defined here are used in sphinxVerbatim environment and can\n+% serve as hook-points with no need to modify \\Verbatim itself.\n+\\let\\OriginalVerbatim   \\Verbatim\n+\\let\\endOriginalVerbatim\\endVerbatim\n+\n+% for captions of literal blocks\n+% at start of caption title\n+\\newcommand*{\\fnum@literalblock}{\\literalblockname\\nobreakspace\\theliteralblock}\n+% this will be overwritten in document preamble by Babel translation\n+\\newcommand*{\\literalblockname}{Listing }\n+% file extension needed for \\caption's good functioning, the file is created\n+% only if a \\listof{literalblock}{foo} command is encountered, which is\n+% analogous to \\listoffigures, but for the code listings (foo = chosen title.)\n+\\newcommand*{\\ext@literalblock}{lol}\n+\n+% if forced use of minipage encapsulation is needed (e.g. table cells)\n+\\newif\\ifsphinxverbatimwithminipage   \\sphinxverbatimwithminipagefalse\n+\n+% Framing macro for use with framed.sty's \\FrameCommand\n+%  - it obeys current indentation,\n+%  - frame is \\fboxsep separated from the contents,\n+%  - the contents use the full available text width,\n+%  - #1 = color of frame, #2 = color of background,\n+%  - #3 = above frame, #4 = below frame, #5 = within frame,\n+%  - #3 and #4 must be already typeset boxes; they must issue \\normalcolor\n+%    or similar, else, they are under scope of color #1\n+\\long\\def\\spx@fcolorbox #1#2#3#4#5{%\n+  \\hskip\\@totalleftmargin\n+  \\hskip-\\fboxsep\\hskip-\\fboxrule\n+  % use of \\color@b@x here is compatible with both xcolor.sty and color.sty\n+  \\color@b@x {\\color{#1}\\spx@CustomFBox{#3}{#4}}{\\color{#2}}{#5}%\n+  \\hskip-\\fboxsep\\hskip-\\fboxrule\n+  \\hskip-\\linewidth \\hskip-\\@totalleftmargin \\hskip\\columnwidth\n+}%\n+% #1 = for material above frame, such as a caption or a \"continued\" hint\n+% #2 = for material below frame, such as a caption or \"continues on next page\"\n+% #3 = actual contents, which will be typeset with a background color\n+\\long\\def\\spx@CustomFBox#1#2#3{%\n+  \\begingroup\n+  \\setbox\\@tempboxa\\hbox{{#3}}% inner braces to avoid color leaks\n+  \\vbox{#1% above frame\n+            % draw frame border _latest_ to avoid pdf viewer issue\n+            \\kern\\fboxrule\n+            \\hbox{\\kern\\fboxrule\n+                  \\copy\\@tempboxa\n+                  \\kern-\\wd\\@tempboxa\\kern-\\fboxrule\n+                  \\vrule\\@width\\fboxrule\n+                  \\kern\\wd\\@tempboxa\n+                  \\vrule\\@width\\fboxrule}%\n+            \\kern-\\dimexpr\\ht\\@tempboxa+\\dp\\@tempboxa+\\fboxrule\\relax\n+            \\hrule\\@height\\fboxrule\n+            \\kern\\dimexpr\\ht\\@tempboxa+\\dp\\@tempboxa\\relax\n+            \\hrule\\@height\\fboxrule\n+        #2% below frame\n+       }%\n+  \\endgroup\n+}%\n+\\def\\spx@fcolorbox@put@c#1{% hide width from framed.sty measuring\n+    \\moveright\\dimexpr\\fboxrule+.5\\wd\\@tempboxa\\hb@xt@\\z@{\\hss#1\\hss}%\n+}%\n+\\def\\spx@fcolorbox@put@r#1{% right align with contents, width hidden\n+    \\moveright\\dimexpr\\fboxrule+\\wd\\@tempboxa-\\fboxsep\\hb@xt@\\z@{\\hss#1}%\n+}%\n+\\def\\spx@fcolorbox@put@l#1{% left align with contents, width hidden\n+    \\moveright\\dimexpr\\fboxrule+\\fboxsep\\hb@xt@\\z@{#1\\hss}%\n+}%\n+%\n+\\def\\sphinxVerbatim@Continued\n+   {\\csname spx@fcolorbox@put@\\spx@opt@verbatimcontinuedalign\\endcsname\n+    {\\normalcolor\\sphinxstylecodecontinued\\literalblockcontinuedname}}%\n+\\def\\sphinxVerbatim@Continues\n+   {\\csname spx@fcolorbox@put@\\spx@opt@verbatimcontinuesalign\\endcsname\n+    {\\normalcolor\\sphinxstylecodecontinues\\literalblockcontinuesname}}%\n+\\def\\sphinxVerbatim@Title\n+   {\\spx@fcolorbox@put@c{\\unhcopy\\sphinxVerbatim@TitleBox}}%\n+\\let\\sphinxVerbatim@Before\\@empty\n+\\let\\sphinxVerbatim@After\\@empty\n+% Defaults are redefined in document preamble according to language\n+\\newcommand*\\literalblockcontinuedname{continued from previous page}%\n+\\newcommand*\\literalblockcontinuesname{continues on next page}%\n+%\n+\\def\\spx@verbatimfcolorbox{\\spx@fcolorbox{VerbatimBorderColor}{VerbatimColor}}%\n+\\def\\sphinxVerbatim@FrameCommand\n+   {\\spx@verbatimfcolorbox\\sphinxVerbatim@Before\\sphinxVerbatim@After}%\n+\\def\\sphinxVerbatim@FirstFrameCommand\n+   {\\spx@verbatimfcolorbox\\sphinxVerbatim@Before\\sphinxVerbatim@Continues}%\n+\\def\\sphinxVerbatim@MidFrameCommand\n+   {\\spx@verbatimfcolorbox\\sphinxVerbatim@Continued\\sphinxVerbatim@Continues}%\n+\\def\\sphinxVerbatim@LastFrameCommand\n+   {\\spx@verbatimfcolorbox\\sphinxVerbatim@Continued\\sphinxVerbatim@After}%\n+\n+% For linebreaks inside Verbatim environment from package fancyvrb.\n+\\newbox\\sphinxcontinuationbox\n+\\newbox\\sphinxvisiblespacebox\n+\\newcommand*\\sphinxafterbreak {\\copy\\sphinxcontinuationbox}\n+\n+% Take advantage of the already applied Pygments mark-up to insert\n+% potential linebreaks for TeX processing.\n+%        {, <, #, %, $, ' and \": go to next line.\n+%        _, }, ^, &, >, -, ~, and \\: stay at end of broken line.\n+% Use of \\textquotesingle for straight quote.\n+% FIXME: convert this to package options ?\n+\\newcommand*\\sphinxbreaksbeforelist {%\n+    \\do\\PYGZob\\{\\do\\PYGZlt\\<\\do\\PYGZsh\\#\\do\\PYGZpc\\%% {, <, #, %,\n+    \\do\\PYGZdl\\$\\do\\PYGZdq\\\"% $, \"\n+    \\def\\PYGZsq\n+     {\\discretionary{}{\\sphinxafterbreak\\textquotesingle}{\\textquotesingle}}% '\n+}\n+\\newcommand*\\sphinxbreaksafterlist {%\n+    \\do\\PYGZus\\_\\do\\PYGZcb\\}\\do\\PYGZca\\^\\do\\PYGZam\\&% _, }, ^, &,\n+    \\do\\PYGZgt\\>\\do\\PYGZhy\\-\\do\\PYGZti\\~% >, -, ~\n+    \\do\\PYGZbs\\\\% \\\n+}\n+\\newcommand*\\sphinxbreaksatspecials {%\n+  \\def\\do##1##2%\n+     {\\def##1{\\discretionary{}{\\sphinxafterbreak\\char`##2}{\\char`##2}}}%\n+  \\sphinxbreaksbeforelist\n+  \\def\\do##1##2%\n+     {\\def##1{\\discretionary{\\char`##2}{\\sphinxafterbreak}{\\char`##2}}}%\n+  \\sphinxbreaksafterlist\n+}\n+\n+\\def\\sphinx@verbatim@nolig@list {\\do \\`}%\n+% Some characters . , ; ? ! / are neither pygmentized nor \"tex-escaped\".\n+% This macro makes them \"active\" and they will insert potential linebreaks.\n+% Not compatible with math mode (cf \\sphinxunactivateextras).\n+\\newcommand*\\sphinxbreaksbeforeactivelist {}% none\n+\\newcommand*\\sphinxbreaksafteractivelist  {\\do\\.\\do\\,\\do\\;\\do\\?\\do\\!\\do\\/}\n+\\newcommand*\\sphinxbreaksviaactive {%\n+   \\def\\do##1{\\lccode`\\~`##1%\n+    \\lowercase{\\def~}{\\discretionary{}{\\sphinxafterbreak\\char`##1}{\\char`##1}}%\n+    \\catcode`##1\\active}%\n+   \\sphinxbreaksbeforeactivelist\n+   \\def\\do##1{\\lccode`\\~`##1%\n+    \\lowercase{\\def~}{\\discretionary{\\char`##1}{\\sphinxafterbreak}{\\char`##1}}%\n+    \\catcode`##1\\active}%\n+   \\sphinxbreaksafteractivelist\n+   \\lccode`\\~`\\~\n+}\n+\n+% If the linebreak is at a space, the latter will be displayed as visible\n+% space at end of first line, and a continuation symbol starts next line.\n+\\def\\spx@verbatim@space {%\n+     \\nobreak\\hskip\\z@skip\n+     \\discretionary{\\copy\\sphinxvisiblespacebox}{\\sphinxafterbreak}\n+                   {\\kern\\fontdimen2\\font}%\n+}%\n+\n+% if the available space on page is less than \\literalblockneedspace, insert pagebreak\n+\\newcommand{\\sphinxliteralblockneedspace}{5\\baselineskip}\n+\\newcommand{\\sphinxliteralblockwithoutcaptionneedspace}{1.5\\baselineskip}\n+% The title (caption) is specified from outside as macro \\sphinxVerbatimTitle.\n+% \\sphinxVerbatimTitle is reset to empty after each use of Verbatim.\n+\\newcommand*\\sphinxVerbatimTitle {}\n+% This box to typeset the caption before framed.sty multiple passes for framing.\n+\\newbox\\sphinxVerbatim@TitleBox\n+% This box to measure contents if nested as inner \\MakeFramed requires then\n+% minipage encapsulation but too long contents then break outer \\MakeFramed\n+\\newbox\\sphinxVerbatim@ContentsBox\n+% Holder macro for labels of literal blocks. Set-up by LaTeX writer.\n+\\newcommand*\\sphinxLiteralBlockLabel {}\n+\\newcommand*\\sphinxSetupCaptionForVerbatim [1]\n+{%\n+    \\sphinxvspacefixafterfrenchlists\n+    \\needspace{\\sphinxliteralblockneedspace}%\n+% insert a \\label via \\sphinxLiteralBlockLabel\n+% reset to normal the color for the literal block caption\n+    \\def\\sphinxVerbatimTitle\n+       {\\py@NormalColor\\sphinxcaption{\\sphinxLiteralBlockLabel #1}}%\n+}\n+\\newcommand*\\sphinxSetupCodeBlockInFootnote {%\n+  \\fvset{fontsize=\\footnotesize}\\let\\caption\\sphinxfigcaption\n+  \\sphinxverbatimwithminipagetrue % reduces vertical spaces\n+  % we counteract (this is in a group) the \\@normalsize from \\caption\n+  \\let\\normalsize\\footnotesize\\let\\@parboxrestore\\relax\n+  \\def\\spx@abovecaptionskip{\\sphinxverbatimsmallskipamount}%\n+}\n+\\newcommand*{\\sphinxverbatimsmallskipamount}{\\smallskipamount}\n+% serves to implement line highlighting and line wrapping\n+\\newcommand\\sphinxFancyVerbFormatLine[1]{%\n+  \\expandafter\\sphinx@verbatim@checkifhl\\expandafter{\\the\\FV@CodeLineNo}%\n+  \\ifin@\n+     \\sphinxVerbatimHighlightLine{#1}%\n+  \\else\n+     \\sphinxVerbatimFormatLine{#1}%\n+  \\fi\n+}%\n+\\newcommand\\sphinxVerbatimHighlightLine[1]{%\n+  \\edef\\sphinxrestorefboxsep{\\fboxsep\\the\\fboxsep\\relax}%\n+  \\fboxsep0pt\\relax % cf LaTeX bug graphics/4524\n+  \\colorbox{sphinxVerbatimHighlightColor}%\n+           {\\sphinxrestorefboxsep\\sphinxVerbatimFormatLine{#1}}%\n+  % no need to restore \\fboxsep here, as this ends up in a \\hbox from fancyvrb\n+}%\n+% \\sphinxVerbatimFormatLine will be set locally to one of those two:\n+\\newcommand\\sphinxVerbatimFormatLineWrap{%\n+  \\hsize\\linewidth\n+  \\ifspx@opt@verbatimforcewraps\n+       \\expandafter\\spx@verb@FormatLineForceWrap\n+  \\else\\expandafter\\spx@verb@FormatLineWrap\n+  \\fi\n+}%\n+\\newcommand\\sphinxVerbatimFormatLineNoWrap[1]{\\hb@xt@\\linewidth{\\strut #1\\hss}}%\n+\\long\\def\\spx@verb@FormatLineWrap#1{%\n+    \\vtop{\\raggedright\\hyphenpenalty\\z@\\exhyphenpenalty\\z@\n+          \\doublehyphendemerits\\z@\\finalhyphendemerits\\z@\n+          \\strut #1\\strut}%\n+}%\n+%\n+% The normal line wrapping allows breaks at spaces and ascii non\n+% letters, non digits. The \\raggedright above means there will be\n+% an overfilled line only if some non-breakable \"word\" was\n+% encountered, which is longer than a line (it is moved always to\n+% be on its own on a new line).\n+% \n+% The \"forced\" line wrapping will parse the tokens to add potential\n+% breakpoints at each character. As some strings are highlighted,\n+% we have to apply the highlighting character per character, which\n+% requires to manipulate the output of the Pygments LaTeXFormatter.\n+%\n+% Doing this at latex level is complicated. The contents should\n+% be as expected: i.e. some active characters from\n+% \\sphinxbreaksviaactive, some Pygments character escapes such as\n+% \\PYGZdl{}, and the highlighting \\PYG macro with always 2\n+% arguments. No other macros should be there, except perhaps\n+% zero-parameter macros. In particular:\n+% - the texcomments Pygments option must be set to False\n+%\n+% With pdflatex, Unicode input gives multi-bytes characters\n+% where the first byte is active. We support the \"utf8\" macros\n+% only. \"utf8x\" is not supported.\n+%\n+% The highlighting macro \\PYG will be applied character per\n+% character. Highlighting via a colored background gives thus a\n+% chain of small colored boxes which may cause some artefact in\n+% some pdf viewers. Can't do anything here if we do want the line\n+% break to be possible.\n+%\n+% First a measurement step is done of what would the standard line\n+% wrapping give (i.e line breaks only at spaces and non-letter,\n+% non-digit ascii characters), cf TeX by Topic for the basic\n+% dissecting technique: TeX unfortunately when building a vertical\n+% box does not store in an accessible way what was the maximal\n+% line-width during paragraph building.\n+%\n+% Avoid LaTeX 2021 alteration of \\@@par which potentially could break our\n+% measurement step (typically if the para/after hook is configured to use\n+% \\vspace).  Of course, breakage could happen only from user or package\n+% adding things to basic Sphinx latex.  And perhaps spring LaTeX 2021 will\n+% provide a non-hooked \\@@par, but this should work anyway and can't be\n+% beaten for speed.\n+\\ltx@ifundefined{tex_par:D}\n+% We could use \\@ifl@t@r\\fmtversion{2020/02/02}{use \\tex_par:D}{use \\@@par}.\n+  {\\let\\spx@par\\@@par}% \\@@par is then expected to be TeX's original \\par\n+  {\\expandafter\\let\\expandafter\\spx@par\\csname tex_par:D\\endcsname}\n+% More hesitation for avoiding the at-start-of-par hooks for our\n+% measurement : 1. with old LaTeX, we can not avoid hooks from everyhook\n+% or similar packages, 2. and perhaps the hooks add stuff which we should\n+% actually measure.  Ideally, hooks are for inserting things in margin\n+% which do not change spacing.  Most everything else in fact should not be\n+% executed in our scratch box for measurement, such as counter stepping.\n+\\ltx@ifundefined{tex_everypar:D}\n+  {\\let\\spx@everypar\\everypar}\n+  {\\expandafter\\let\\expandafter\\spx@everypar\\csname tex_everypar:D\\endcsname}\n+%\n+% If the max width exceeds the linewidth by more than verbatimmaxoverfull\n+% character widths, or if the min width plus verbatimmaxunderfull character\n+% widths is inferior to linewidth, then we apply the \"force wrapping\" with\n+% potential line break at each character, else we don't.\n+\\long\\def\\spx@verb@FormatLineForceWrap#1{%\n+    % \\spx@image@box is a scratch box register that we can use here\n+    \\global\\let\\spx@verb@maxwidth\\z@\n+    \\global\\let\\spx@verb@minwidth\\linewidth\n+    \\setbox\\spx@image@box\n+    \\vtop{\\raggedright\\hyphenpenalty\\z@\\exhyphenpenalty\\z@\n+          \\doublehyphendemerits\\z@\\finalhyphendemerits\\z@\n+          \\spx@everypar{}\\noindent\\strut #1\\strut\\spx@par\n+          \\spx@verb@getwidths}%\n+    \\ifdim\\spx@verb@maxwidth>\n+          \\dimexpr\\linewidth+\\spx@opt@verbatimmaxoverfull\\fontcharwd\\font`X \\relax\n+      \\spx@verb@FormatLineWrap{\\spx@verb@wrapPYG #1\\spx@verb@wrapPYG}%\n+    \\else\n+      \\ifdim\\spx@verb@minwidth<\n+            \\dimexpr\\linewidth-\\spx@opt@verbatimmaxunderfull\\fontcharwd\\font`X \\relax\n+        \\spx@verb@FormatLineWrap{\\spx@verb@wrapPYG #1\\spx@verb@wrapPYG}%\n+      \\else\n+        \\spx@verb@FormatLineWrap{#1}%\n+    \\fi\\fi\n+}%\n+% auxiliary paragraph dissector to get max and min widths\n+% but minwidth must not take into account the last line\n+\\newbox\\spx@scratchbox\n+\\def\\spx@verb@getwidths {%\n+    \\unskip\\unpenalty\n+    \\setbox\\spx@scratchbox\\lastbox\n+    \\ifvoid\\spx@scratchbox\n+    \\else\n+       \\setbox\\spx@scratchbox\\hbox{\\unhbox\\spx@scratchbox}%\n+       \\ifdim\\spx@verb@maxwidth<\\wd\\spx@scratchbox\n+          \\xdef\\spx@verb@maxwidth{\\number\\wd\\spx@scratchbox sp}%\n+       \\fi\n+       \\expandafter\\spx@verb@getwidths@loop\n+    \\fi\n+}%\n+\\def\\spx@verb@getwidths@loop {%\n+    \\unskip\\unpenalty\n+    \\setbox\\spx@scratchbox\\lastbox\n+    \\ifvoid\\spx@scratchbox\n+    \\else\n+       \\setbox\\spx@scratchbox\\hbox{\\unhbox\\spx@scratchbox}%\n+       \\ifdim\\spx@verb@maxwidth<\\wd\\spx@scratchbox\n+          \\xdef\\spx@verb@maxwidth{\\number\\wd\\spx@scratchbox sp}%\n+       \\fi\n+       \\ifdim\\spx@verb@minwidth>\\wd\\spx@scratchbox\n+          \\xdef\\spx@verb@minwidth{\\number\\wd\\spx@scratchbox sp}%\n+       \\fi\n+       \\expandafter\\spx@verb@getwidths@loop\n+    \\fi\n+}%\n+% auxiliary macros to implement \"cut long line even in middle of word\"\n+\\catcode`Z=3 % safe delimiter\n+\\def\\spx@verb@wrapPYG{%\n+    \\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@i\n+}%\n+\\def\\spx@verb@wrapPYG@i{%\n+    \\ifx\\spx@nexttoken\\spx@verb@wrapPYG\\let\\next=\\@gobble\\else\n+    \\ifx\\spx@nexttoken\\PYG\\let\\next=\\spx@verb@wrapPYG@PYG@onebyone\\else\n+      \\discretionary{}{\\sphinxafterbreak}{}%\n+      \\let\\next\\spx@verb@wrapPYG@ii\n+    \\fi\\fi\n+    \\next\n+}%\n+% Let's recognize active characters. We don't support utf8x only utf8.\n+% And here #1 should not have picked up (non empty) braced contents\n+\\long\\def\\spx@verb@wrapPYG@ii#1{%\n+    \\ifcat\\noexpand~\\noexpand#1\\relax% active character\n+      \\expandafter\\spx@verb@wrapPYG@active\n+    \\else % non-active character, control sequence such as \\PYGZdl, or empty\n+      \\expandafter\\spx@verb@wrapPYG@one\n+    \\fi {#1}%\n+}%\n+\\long\\def\\spx@verb@wrapPYG@active#1{%\n+% Let's hope expansion of active character does not really require arguments,\n+% as we certainly don't want to go into expanding upfront token stream anyway.\n+    \\expandafter\\spx@verb@wrapPYG@iii#1{}{}{}{}{}{}{}{}{}Z#1%\n+}%\n+\\long\\def\\spx@verb@wrapPYG@iii#1#2Z{%\n+    \\ifx\\UTFviii@four@octets#1\\let\\next=\\spx@verb@wrapPYG@four\\else\n+    \\ifx\\UTFviii@three@octets#1\\let\\next=\\spx@verb@wrapPYG@three\\else\n+    \\ifx\\UTFviii@two@octets#1\\let\\next=\\spx@verb@wrapPYG@two\\else\n+    \\let\\next=\\spx@verb@wrapPYG@one\n+    \\fi\\fi\\fi\n+    \\next\n+}%\n+\\long\\def\\spx@verb@wrapPYG@one   #1{#1\\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@i}%\n+\\long\\def\\spx@verb@wrapPYG@two   #1#2{#1#2\\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@i}%\n+\\long\\def\\spx@verb@wrapPYG@three #1#2#3{#1#2#3\\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@i}%\n+\\long\\def\\spx@verb@wrapPYG@four  #1#2#3#4{#1#2#3#4\\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@i}%\n+% Replace \\PYG by itself applied one character at a time! This way breakpoints\n+% can be inserted.\n+\\def\\spx@verb@wrapPYG@PYG@onebyone#1#2#3{% #1 = \\PYG, #2 = highlight spec, #3 = tokens\n+    \\def\\spx@verb@wrapPYG@PYG@spec{{#2}}%\n+    \\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@PYG@i#3Z%\n+}%\n+\\def\\spx@verb@wrapPYG@PYG@i{%\n+    \\ifx\\spx@nexttokenZ\\let\\next=\\spx@verb@wrapPYG@PYG@done\\else\n+      \\discretionary{}{\\sphinxafterbreak}{}%\n+      \\let\\next\\spx@verb@wrapPYG@PYG@ii\n+    \\fi\n+    \\next\n+}%\n+\\def\\spx@verb@wrapPYG@PYG@doneZ{\\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@i}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@ii#1{%\n+    \\ifcat\\noexpand~\\noexpand#1\\relax% active character\n+      \\expandafter\\spx@verb@wrapPYG@PYG@active\n+    \\else % non-active character, control sequence such as \\PYGZdl, or empty\n+      \\expandafter\\spx@verb@wrapPYG@PYG@one\n+    \\fi {#1}%\n+}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@active#1{%\n+% Let's hope expansion of active character does not really require arguments,\n+% as we certainly don't want to go into expanding upfront token stream anyway.\n+    \\expandafter\\spx@verb@wrapPYG@PYG@iii#1{}{}{}{}{}{}{}{}{}Z#1%\n+}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@iii#1#2Z{%\n+    \\ifx\\UTFviii@four@octets#1\\let\\next=\\spx@verb@wrapPYG@PYG@four\\else\n+    \\ifx\\UTFviii@three@octets#1\\let\\next=\\spx@verb@wrapPYG@PYG@three\\else\n+    \\ifx\\UTFviii@two@octets#1\\let\\next=\\spx@verb@wrapPYG@PYG@two\\else\n+    \\let\\next=\\spx@verb@wrapPYG@PYG@one\n+    \\fi\\fi\\fi\n+    \\next\n+}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@one#1{%\n+    \\expandafter\\PYG\\spx@verb@wrapPYG@PYG@spec{#1}%\n+    \\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@PYG@i\n+}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@two#1#2{%\n+    \\expandafter\\PYG\\spx@verb@wrapPYG@PYG@spec{#1#2}%\n+    \\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@PYG@i\n+}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@three#1#2#3{%\n+    \\expandafter\\PYG\\spx@verb@wrapPYG@PYG@spec{#1#2#3}%\n+    \\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@PYG@i\n+}%\n+\\long\\def\\spx@verb@wrapPYG@PYG@four#1#2#3#4{%\n+    \\expandafter\\PYG\\spx@verb@wrapPYG@PYG@spec{#1#2#3#4}%\n+    \\futurelet\\spx@nexttoken\\spx@verb@wrapPYG@PYG@i\n+}%\n+\\catcode`Z 11 %\n+%\n+\\g@addto@macro\\FV@SetupFont{%\n+    \\sbox\\sphinxcontinuationbox {\\spx@opt@verbatimcontinued}%\n+    \\sbox\\sphinxvisiblespacebox {\\spx@opt@verbatimvisiblespace}%\n+}%\n+\\newenvironment{sphinxVerbatim}{%\n+  % first, let's check if there is a caption\n+  \\ifx\\sphinxVerbatimTitle\\empty\n+      \\sphinxvspacefixafterfrenchlists\n+      \\parskip\\z@skip\n+      \\vskip\\sphinxverbatimsmallskipamount\n+      % there was no caption. Check if nevertheless a label was set.\n+      \\ifx\\sphinxLiteralBlockLabel\\empty\\else\n+      % we require some space to be sure hyperlink target from \\phantomsection\n+      % will not be separated from upcoming verbatim by a page break\n+          \\needspace{\\sphinxliteralblockwithoutcaptionneedspace}%\n+          \\phantomsection\\sphinxLiteralBlockLabel\n+      \\fi\n+  \\else\n+     \\parskip\\z@skip\n+     \\if t\\spx@opt@literalblockcappos\n+       \\vskip\\spx@abovecaptionskip\n+       \\def\\sphinxVerbatim@Before\n+           {\\sphinxVerbatim@Title\\nointerlineskip\n+            \\kern\\dimexpr-\\dp\\strutbox+\\sphinxbelowcaptionspace\n+                 % if no frame (code-blocks inside table cells), remove\n+                 % the \"verbatimsep\" whitespace from the top (better visually)\n+                 \\ifspx@opt@verbatimwithframe\\else-\\sphinxverbatimsep\\fi\n+                 % caption package adds \\abovecaptionskip vspace, remove it\n+                 \\spx@ifcaptionpackage{-\\abovecaptionskip}{}\\relax}%\n+     \\else\n+       \\vskip\\sphinxverbatimsmallskipamount\n+       \\def\\sphinxVerbatim@After\n+          {\\nointerlineskip\\kern\\dimexpr\\dp\\strutbox\n+            \\ifspx@opt@verbatimwithframe\\else-\\sphinxverbatimsep\\fi\n+            \\spx@ifcaptionpackage{-\\abovecaptionskip}{}\\relax\n+           \\sphinxVerbatim@Title}%\n+     \\fi\n+     \\def\\@captype{literalblock}%\n+     \\capstart\n+     % \\sphinxVerbatimTitle must reset color\n+     \\setbox\\sphinxVerbatim@TitleBox\n+            \\hbox{\\begin{minipage}{\\linewidth}%\n+     % caption package may detect wrongly if top or bottom, so we help it\n+                    \\spx@ifcaptionpackage\n+                      {\\caption@setposition{\\spx@opt@literalblockcappos}}{}%\n+                    \\sphinxVerbatimTitle\n+                  \\end{minipage}}%\n+  \\fi\n+  \\global\\let\\sphinxLiteralBlockLabel\\empty\n+  \\global\\let\\sphinxVerbatimTitle\\empty\n+  \\fboxsep\\sphinxverbatimsep \\fboxrule\\sphinxverbatimborder\n+  \\ifspx@opt@verbatimwithframe\\else\\fboxrule\\z@\\fi\n+  \\let\\FrameCommand     \\sphinxVerbatim@FrameCommand\n+  \\let\\FirstFrameCommand\\sphinxVerbatim@FirstFrameCommand\n+  \\let\\MidFrameCommand  \\sphinxVerbatim@MidFrameCommand\n+  \\let\\LastFrameCommand \\sphinxVerbatim@LastFrameCommand\n+  \\ifspx@opt@verbatimhintsturnover\\else\n+      \\let\\sphinxVerbatim@Continued\\@empty\n+      \\let\\sphinxVerbatim@Continues\\@empty\n+  \\fi\n+  \\ifspx@opt@verbatimwrapslines\n+  % fancyvrb's Verbatim puts each input line in (unbreakable) horizontal boxes.\n+  % This customization wraps each line from the input in a \\vtop, thus\n+  % allowing it to wrap and display on two or more lines in the latex output.\n+  %     - The codeline counter will be increased only once.\n+  %     - The wrapped material will not break across pages, it is impossible\n+  %       to achieve this without extensive rewrite of fancyvrb.\n+  %     - The (not used in sphinx) obeytabs option to Verbatim is\n+  %       broken by this change (showtabs and tabspace work).\n+    \\let\\sphinxVerbatimFormatLine\\sphinxVerbatimFormatLineWrap\n+    \\let\\FV@Space\\spx@verbatim@space\n+  % Allow breaks at special characters using \\PYG... macros.\n+    \\sphinxbreaksatspecials\n+  % Breaks at punctuation characters . , ; ? ! and / (needs catcode activation)\n+    \\fvset{codes*=\\sphinxbreaksviaactive}%\n+  \\else % end of conditional code for wrapping long code lines\n+    \\let\\sphinxVerbatimFormatLine\\sphinxVerbatimFormatLineNoWrap\n+  \\fi\n+  \\let\\FancyVerbFormatLine\\sphinxFancyVerbFormatLine\n+  \\VerbatimEnvironment\n+  % workaround to fancyvrb's check of current list depth\n+  \\def\\@toodeep {\\advance\\@listdepth\\@ne}%\n+  % The list environment is needed to control perfectly the vertical space.\n+  % Note: \\OuterFrameSep used by framed.sty is later set to \\topsep hence 0pt.\n+  % - if caption: distance from last text baseline to caption baseline is\n+  %   A+(B-F)+\\ht\\strutbox, A = \\abovecaptionskip (default 10pt), B =\n+  %   \\baselineskip, F is the framed.sty \\FrameHeightAdjust macro, default 6pt.\n+  %   Formula valid for F < 10pt.\n+  % - distance of baseline of caption to top of frame is like for tables:\n+  %   \\sphinxbelowcaptionspace (=0.5\\baselineskip)\n+  % - if no caption: distance of last text baseline to code frame is S+(B-F),\n+  %   with S = \\sphinxverbatimtopskip (=\\smallskip)\n+  % - and distance from bottom of frame to next text baseline is\n+  %   \\baselineskip+\\parskip.\n+  % The \\trivlist is used to avoid possible \"too deeply nested\" error.\n+  \\itemsep   \\z@skip\n+  \\topsep    \\z@skip\n+  \\partopsep \\z@skip\n+  % trivlist will set \\parsep to \\parskip (which itself is set to zero above)\n+  % \\leftmargin will be set to zero by trivlist\n+  \\rightmargin\\z@\n+  \\parindent  \\z@% becomes \\itemindent. Default zero, but perhaps overwritten.\n+  \\trivlist\\item\\relax\n+     \\ifspx@inframed\\setbox\\sphinxVerbatim@ContentsBox\\vbox\\bgroup\n+        \\@setminipage\\hsize\\linewidth\n+        % use bulk of minipage paragraph shape restores (this is needed\n+        % in indented contexts, at least for some)\n+        \\textwidth\\hsize \\columnwidth\\hsize \\@totalleftmargin\\z@\n+        \\leftskip\\z@skip \\rightskip\\z@skip  \\@rightskip\\z@skip\n+     \\else\n+       \\ifsphinxverbatimwithminipage\\noindent\\begin{minipage}{\\linewidth}\\fi\n+       \\MakeFramed {% adapted over from framed.sty's snugshade environment\n+        \\advance\\hsize-\\width\\@totalleftmargin\\z@\\linewidth\\hsize\\@setminipage\n+        }%\n+     \\fi\n+     % For grid placement from \\strut's in \\FancyVerbFormatLine\n+     \\lineskip\\z@skip\n+     % active comma should not be overwritten by \\@noligs\n+     \\ifspx@opt@verbatimwrapslines\n+       \\let\\verbatim@nolig@list \\sphinx@verbatim@nolig@list\n+     \\fi\n+     % will fetch its optional arguments if any\n+     \\OriginalVerbatim\n+}\n+{%\n+  \\endOriginalVerbatim\n+  \\ifspx@inframed\n+   \\egroup % finish \\sphinxVerbatim@ContentsBox vbox\n+   \\nobreak % update page totals\n+   \\ifdim\\dimexpr\\ht\\sphinxVerbatim@ContentsBox+\n+         \\dp\\sphinxVerbatim@ContentsBox+\n+         \\ht\\sphinxVerbatim@TitleBox+\n+         \\dp\\sphinxVerbatim@TitleBox+\n+         2\\fboxsep+2\\fboxrule+\n+         % try to account for external frame parameters\n+         \\FrameSep+\\FrameRule+\n+         % Usage here of 2 baseline distances is empirical.\n+         % In border case where code-block fits barely in remaining space,\n+         % it gets framed and looks good but the outer frame may continue\n+         % on top of next page and give (if no contents after code-block)\n+         % an empty framed line, as testing showed.\n+         2\\baselineskip+\n+         % now add all to accumulated page totals and compare to \\pagegoal\n+         \\pagetotal+\\pagedepth>\\pagegoal\n+    % long contents: do not \\MakeFramed. Do make a caption (either before or\n+    % after) if title exists. Continuation hints across pagebreaks dropped.\n+    % FIXME? a bottom caption may end up isolated at top of next page\n+    %        (no problem with a top caption, which is default)\n+    \\spx@opt@verbatimwithframefalse\n+    \\def\\sphinxVerbatim@Title{\\noindent\\box\\sphinxVerbatim@TitleBox\\par}%\n+    \\sphinxVerbatim@Before\n+    \\noindent\\unvbox\\sphinxVerbatim@ContentsBox\\par\n+    \\sphinxVerbatim@After\n+   \\else\n+    % short enough contents: use \\MakeFramed. As it is nested, this requires\n+    % minipage encapsulation.\n+    \\noindent\\begin{minipage}{\\linewidth}%\n+     \\MakeFramed {% Use it now with the fetched contents\n+      \\advance\\hsize-\\width\\@totalleftmargin\\z@\\linewidth\\hsize\\@setminipage\n+      }%\n+     \\unvbox\\sphinxVerbatim@ContentsBox\n+     % some of this may be superfluous:\n+     \\par\\unskip\\@minipagefalse\\endMakeFramed\n+    \\end{minipage}%\n+   \\fi\n+  \\else % non-nested \\MakeFramed\n+    \\par\\unskip\\@minipagefalse\\endMakeFramed % from framed.sty snugshade\n+    \\ifsphinxverbatimwithminipage\\end{minipage}\\fi\n+  \\fi\n+  \\endtrivlist\n+}\n+\\newenvironment {sphinxVerbatimNoFrame}\n+  {\\spx@opt@verbatimwithframefalse\n+   \\VerbatimEnvironment\n+   \\begin{sphinxVerbatim}}\n+  {\\end{sphinxVerbatim}}\n+\\newenvironment {sphinxVerbatimintable}\n+  {% don't use a frame if in a table cell\n+   \\spx@opt@verbatimwithframefalse\n+   \\sphinxverbatimwithminipagetrue\n+   % the literal block caption uses \\sphinxcaption which is wrapper of \\caption,\n+   % but \\caption must be modified because longtable redefines it to work only\n+   % for the own table caption, and tabulary has multiple passes\n+   \\let\\caption\\sphinxfigcaption\n+   % reduce above caption skip\n+   \\def\\spx@abovecaptionskip{\\sphinxverbatimsmallskipamount}%\n+   \\VerbatimEnvironment\n+   \\begin{sphinxVerbatim}}\n+  {\\end{sphinxVerbatim}}\n+\n+\n+%% PARSED LITERALS\n+% allow long lines to wrap like they do in code-blocks\n+\n+% this should be kept in sync with definitions in sphinx.util.texescape\n+\\newcommand*\\sphinxbreaksattexescapedchars{%\n+  \\def\\do##1##2% put potential break point before character\n+     {\\def##1{\\discretionary{}{\\sphinxafterbreak\\char`##2}{\\char`##2}}}%\n+  \\do\\{\\{\\do\\textless\\<\\do\\#\\#\\do\\%\\%\\do\\$\\$% {, <, #, %, $\n+  \\def\\do##1##2% put potential break point after character\n+     {\\def##1{\\discretionary{\\char`##2}{\\sphinxafterbreak}{\\char`##2}}}%\n+  \\do\\_\\_\\do\\}\\}\\do\\textasciicircum\\^\\do\\&\\&% _, }, ^, &,\n+  \\do\\textgreater\\>\\do\\textasciitilde\\~% >, ~\n+  \\do\\textbackslash\\\\% \\\n+}\n+\\newcommand*\\sphinxbreaksviaactiveinparsedliteral{%\n+  \\sphinxbreaksviaactive % by default handles . , ; ? ! /\n+  \\lccode`\\~`\\~ %\n+  % update \\dospecials as it is used by \\url\n+  % but deactivation will already have been done hence this is unneeded:\n+  %  \\expandafter\\def\\expandafter\\dospecials\\expandafter{\\dospecials\n+  %   \\sphinxbreaksbeforeactivelist\\sphinxbreaksafteractivelist\\do\\-}%\n+}\n+\\newcommand*\\sphinxbreaksatspaceinparsedliteral{%\n+  \\lccode`~32 \\lowercase{\\let~}\\spx@verbatim@space\\lccode`\\~`\\~\n+}\n+\\newcommand*{\\sphinxunactivateextras}{\\let\\do\\@makeother\n+      \\sphinxbreaksbeforeactivelist\\sphinxbreaksafteractivelist}%\n+% the \\catcode13=5\\relax (deactivate end of input lines) is left to callers\n+\\newcommand*{\\sphinxunactivateextrasandspace}{\\catcode32=10\\relax\n+      \\sphinxunactivateextras}%\n+% alltt uses a monospace font and linebreaks at dashes (which are escaped\n+% to \\sphinxhyphen{} which expands to -\\kern\\z@) are inhibited with pdflatex.\n+% Not with xelatex (cf \\defaultfontfeatures in latex writer), so:\n+\\newcommand*{\\sphinxhypheninparsedliteral}{\\sphinxhyphennobreak}\n+% now for the modified alltt environment\n+\\newenvironment{sphinxalltt}\n+{% at start of next line to workaround Emacs/AUCTeX issue with this file\n+\\begin{alltt}%\n+ \\ifspx@opt@parsedliteralwraps\n+   \\sbox\\sphinxcontinuationbox {\\spx@opt@verbatimcontinued}%\n+   \\sbox\\sphinxvisiblespacebox {\\spx@opt@verbatimvisiblespace}%\n+   \\let\\sphinxhyphen\\sphinxhypheninparsedliteral\n+   \\sphinxbreaksattexescapedchars\n+   \\sphinxbreaksviaactiveinparsedliteral\n+   \\sphinxbreaksatspaceinparsedliteral\n+% alltt takes care of the ' as derivative (\"prime\") in math mode\n+   \\everymath\\expandafter{\\the\\everymath\\sphinxunactivateextrasandspace\n+             \\catcode`\\<=12\\catcode`\\>=12\\catcode`\\^=7\\catcode`\\_=8 }%\n+% not sure if displayed math (align,...) can end up in parsed-literal, anyway\n+   \\everydisplay\\expandafter{\\the\\everydisplay\n+             \\catcode13=5 \\sphinxunactivateextrasandspace\n+             \\catcode`\\<=12\\catcode`\\>=12\\catcode`\\^=7\\catcode`\\_=8 }%\n+ \\fi }\n+{\\end{alltt}}\n+\n+\n+%% INLINE MARK-UP\n+%\n+\n+% Protect \\href's first argument in contexts such as sphinxalltt (or\n+% \\sphinxcode). Sphinx uses \\#, \\%, \\& ... always inside \\sphinxhref.\n+\\protected\\def\\sphinxhref#1#2{{%\n+    \\sphinxunactivateextrasandspace % never do \\scantokens with active space!\n+% for the \\endlinechar business, https://github.com/latex3/latex2e/issues/286\n+    \\endlinechar\\m@ne\\everyeof{{\\endlinechar13 #2}}% keep catcode regime for #2\n+    \\scantokens{\\href{#1}}% normalise it for #1 during \\href expansion\n+}}\n+% Same for \\url. And also \\nolinkurl for coherence.\n+\\protected\\def\\sphinxurl#1{{%\n+    \\sphinxunactivateextrasandspace\\everyeof{}% (<- precaution for \\scantokens)\n+    \\endlinechar\\m@ne\\scantokens{\\url{#1}}%\n+}}\n+\\protected\\def\\sphinxnolinkurl#1{{%\n+    \\sphinxunactivateextrasandspace\\everyeof{}%\n+    \\endlinechar\\m@ne\\scantokens{\\nolinkurl{#1}}%\n+}}\n+\n+% \\sphinxupquote\n+% to obtain straight quotes we execute \\@noligs as patched by upquote, and\n+% \\scantokens is needed in cases where it would be too late for the macro to\n+% first set catcodes and then fetch its argument. We also make the contents\n+% breakable at non-escaped . , ; ? ! / using \\sphinxbreaksviaactive,\n+% and also at \\ character (which is escaped to \\textbackslash{}).\n+\\protected\\def\\sphinxtextbackslashbreakbefore\n+ {\\discretionary{}{\\sphinxafterbreak\\sphinx@textbackslash}{\\sphinx@textbackslash}}\n+\\protected\\def\\sphinxtextbackslashbreakafter\n+ {\\discretionary{\\sphinx@textbackslash}{\\sphinxafterbreak}{\\sphinx@textbackslash}}\n+\\let\\sphinxtextbackslash\\sphinxtextbackslashbreakafter\n+% - is escaped to \\sphinxhyphen{} and this default ensures no linebreak\n+% behaviour (also with a non monospace font, or with xelatex)\n+\\newcommand*{\\sphinxhyphenininlineliteral}{\\sphinxhyphennobreak}\n+% the macro must be protected if it ends up used in moving arguments,\n+% in 'alltt' \\@noligs is done already, and the \\scantokens must be avoided.\n+\\protected\\def\\sphinxupquote#1{{\\def\\@tempa{alltt}%\n+  \\ifx\\@tempa\\@currenvir\\else\n+   \\let\\sphinxhyphen\\sphinxhyphenininlineliteral\n+   \\ifspx@opt@inlineliteralwraps\n+      % break at . , ; ? ! /\n+      \\sphinxbreaksviaactive\n+      % break also at \\\n+      \\setbox8=\\hbox{\\textbackslash}%\n+      \\def\\sphinx@textbackslash{\\copy8}%\n+      \\let\\textbackslash\\sphinxtextbackslash\n+      % by default, no continuation symbol on next line but may be added\n+      \\let\\sphinxafterbreak\\sphinxafterbreakofinlineliteral\n+      % do not overwrite the comma set-up\n+      \\let\\verbatim@nolig@list\\sphinx@literal@nolig@list\n+   \\fi\n+   % fix a space-gobbling issue due to LaTeX's original \\do@noligs\n+% TODO: using \\@noligs as patched by upquote.sty is now unneeded because\n+% either ` and ' are escaped (non-unicode engines) or they don't build\n+% ligatures (unicode engines). Thus remove this and unify handling of `, <, >,\n+% ' and - with the characters . , ; ? ! / as handled via\n+% \\sphinxbreaksviaactive.\n+% Hence \\sphinx@do@noligs will be removed, or rather replaced  with code\n+% inserting discretionaries, as they allow a continuation symbol on start of\n+% next line to achieve common design with code-blocks.\n+   \\let\\do@noligs\\sphinx@do@noligs\n+   \\@noligs\\endlinechar\\m@ne\\everyeof{}% (<- in case inside \\sphinxhref)\n+   \\expandafter\\scantokens\n+  \\fi {{#1}}}}% extra brace pair to fix end-space gobbling issue...\n+\\def\\sphinx@do@noligs #1{\\catcode`#1\\active\\begingroup\\lccode`\\~`#1\\relax\n+    \\lowercase{\\endgroup\\def~{\\leavevmode\\kern\\z@\\char`#1 }}}\n+\\def\\sphinx@literal@nolig@list {\\do\\`\\do\\<\\do\\>\\do\\'\\do\\-}%\n+\\let\\sphinxafterbreakofinlineliteral\\empty\n+\n+\n+\\endinput\ndiff --git a/sphinx/writers/latex.py.bak b/sphinx/writers/latex.py.bak\nnew file mode 100644\nindex 000000000..e0c7d56f8\n--- /dev/null\n+++ b/sphinx/writers/latex.py.bak\n@@ -0,0 +1,2061 @@\n+\"\"\"Custom docutils writer for LaTeX.\n+\n+Much of this code is adapted from Dave Kuhlman's \"docpy\" writer from his\n+docutils sandbox.\n+\"\"\"\n+\n+import re\n+import warnings\n+from collections import defaultdict\n+from os import path\n+from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast\n+\n+from docutils import nodes, writers\n+from docutils.nodes import Element, Node, Text\n+\n+from sphinx import addnodes, highlighting\n+from sphinx.deprecation import RemovedInSphinx70Warning\n+from sphinx.domains import IndexEntry\n+from sphinx.domains.std import StandardDomain\n+from sphinx.errors import SphinxError\n+from sphinx.locale import _, __, admonitionlabels\n+from sphinx.util import logging, split_into, texescape\n+from sphinx.util.docutils import SphinxTranslator\n+from sphinx.util.nodes import clean_astext, get_prev_node\n+from sphinx.util.template import LaTeXRenderer\n+from sphinx.util.texescape import tex_replace_map\n+\n+try:\n+    from docutils.utils.roman import toRoman\n+except ImportError:\n+    # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman\n+    from roman import toRoman  # type: ignore\n+\n+if TYPE_CHECKING:\n+    from sphinx.builders.latex import LaTeXBuilder\n+    from sphinx.builders.latex.theming import Theme\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+MAX_CITATION_LABEL_LENGTH = 8\n+LATEXSECTIONNAMES = [\"part\", \"chapter\", \"section\", \"subsection\",\n+                     \"subsubsection\", \"paragraph\", \"subparagraph\"]\n+ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\\arabic',\n+                                   {\n+                                       'arabic': r'\\arabic',\n+                                       'loweralpha': r'\\alph',\n+                                       'upperalpha': r'\\Alph',\n+                                       'lowerroman': r'\\roman',\n+                                       'upperroman': r'\\Roman',\n+                                   })\n+\n+CR = '\\n'\n+BLANKLINE = '\\n\\n'\n+EXTRA_RE = re.compile(r'^(.*\\S)\\s+\\(([^()]*)\\)\\s*$')\n+\n+\n+class collected_footnote(nodes.footnote):\n+    \"\"\"Footnotes that are collected are assigned this class.\"\"\"\n+\n+\n+class UnsupportedError(SphinxError):\n+    category = 'Markup is unsupported in LaTeX'\n+\n+\n+class LaTeXWriter(writers.Writer):\n+\n+    supported = ('sphinxlatex',)\n+\n+    settings_spec = ('LaTeX writer options', '', (\n+        ('Document name', ['--docname'], {'default': ''}),\n+        ('Document class', ['--docclass'], {'default': 'manual'}),\n+        ('Author', ['--author'], {'default': ''}),\n+    ))\n+    settings_defaults: Dict = {}\n+\n+    output = None\n+\n+    def __init__(self, builder: \"LaTeXBuilder\") -> None:\n+        super().__init__()\n+        self.builder = builder\n+        self.theme: Theme = None\n+\n+    def translate(self) -> None:\n+        visitor = self.builder.create_translator(self.document, self.builder, self.theme)\n+        self.document.walkabout(visitor)\n+        self.output = cast(LaTeXTranslator, visitor).astext()\n+\n+\n+# Helper classes\n+\n+class Table:\n+    \"\"\"A table data\"\"\"\n+\n+    def __init__(self, node: Element) -> None:\n+        self.header: List[str] = []\n+        self.body: List[str] = []\n+        self.align = node.get('align', 'default')\n+        self.classes: List[str] = node.get('classes', [])\n+        self.colcount = 0\n+        self.colspec: str = None\n+        self.colwidths: List[int] = []\n+        self.has_problematic = False\n+        self.has_oldproblematic = False\n+        self.has_verbatim = False\n+        self.caption: List[str] = None\n+        self.stubs: List[int] = []\n+\n+        # current position\n+        self.col = 0\n+        self.row = 0\n+\n+        # A dict mapping a table location to a cell_id (cell = rectangular area)\n+        self.cells: Dict[Tuple[int, int], int] = defaultdict(int)\n+        self.cell_id = 0  # last assigned cell_id\n+\n+    def is_longtable(self) -> bool:\n+        \"\"\"True if and only if table uses longtable environment.\"\"\"\n+        return self.row > 30 or 'longtable' in self.classes\n+\n+    def get_table_type(self) -> str:\n+        \"\"\"Returns the LaTeX environment name for the table.\n+\n+        The class currently supports:\n+\n+        * longtable\n+        * tabular\n+        * tabulary\n+        \"\"\"\n+        if self.is_longtable():\n+            return 'longtable'\n+        elif self.has_verbatim:\n+            return 'tabular'\n+        elif self.colspec:\n+            return 'tabulary'\n+        elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):\n+            return 'tabular'\n+        else:\n+            return 'tabulary'\n+\n+    def get_colspec(self) -> str:\n+        \"\"\"Returns a column spec of table.\n+\n+        This is what LaTeX calls the 'preamble argument' of the used table environment.\n+\n+        .. note:: the ``\\\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.\n+        \"\"\"\n+        if self.colspec:\n+            return self.colspec\n+        elif self.colwidths and 'colwidths-given' in self.classes:\n+            total = sum(self.colwidths)\n+            colspecs = [r'\\X{%d}{%d}' % (width, total) for width in self.colwidths]\n+            return '{|%s|}' % '|'.join(colspecs) + CR\n+        elif self.has_problematic:\n+            return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n+        elif self.get_table_type() == 'tabulary':\n+            # sphinx.sty sets T to be J by default.\n+            return '{|' + ('T|' * self.colcount) + '}' + CR\n+        elif self.has_oldproblematic:\n+            return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n+        else:\n+            return '{|' + ('l|' * self.colcount) + '}' + CR\n+\n+    def add_cell(self, height: int, width: int) -> None:\n+        \"\"\"Adds a new cell to a table.\n+\n+        It will be located at current position: (``self.row``, ``self.col``).\n+        \"\"\"\n+        self.cell_id += 1\n+        for col in range(width):\n+            for row in range(height):\n+                assert self.cells[(self.row + row, self.col + col)] == 0\n+                self.cells[(self.row + row, self.col + col)] = self.cell_id\n+\n+    def cell(self, row: int = None, col: int = None) -> \"TableCell\":\n+        \"\"\"Returns a cell object (i.e. rectangular area) containing given position.\n+\n+        If no option arguments: ``row`` or ``col`` are given, the current position;\n+        ``self.row`` and ``self.col`` are used to get a cell object by default.\n+        \"\"\"\n+        try:\n+            if row is None:\n+                row = self.row\n+            if col is None:\n+                col = self.col\n+            return TableCell(self, row, col)\n+        except IndexError:\n+            return None\n+\n+\n+class TableCell:\n+    \"\"\"Data of a cell in a table.\"\"\"\n+\n+    def __init__(self, table: Table, row: int, col: int) -> None:\n+        if table.cells[(row, col)] == 0:\n+            raise IndexError\n+\n+        self.table = table\n+        self.cell_id = table.cells[(row, col)]\n+        self.row = row\n+        self.col = col\n+\n+        # adjust position for multirow/multicol cell\n+        while table.cells[(self.row - 1, self.col)] == self.cell_id:\n+            self.row -= 1\n+        while table.cells[(self.row, self.col - 1)] == self.cell_id:\n+            self.col -= 1\n+\n+    @property\n+    def width(self) -> int:\n+        \"\"\"Returns the cell width.\"\"\"\n+        width = 0\n+        while self.table.cells[(self.row, self.col + width)] == self.cell_id:\n+            width += 1\n+        return width\n+\n+    @property\n+    def height(self) -> int:\n+        \"\"\"Returns the cell height.\"\"\"\n+        height = 0\n+        while self.table.cells[(self.row + height, self.col)] == self.cell_id:\n+            height += 1\n+        return height\n+\n+\n+def escape_abbr(text: str) -> str:\n+    \"\"\"Adjust spacing after abbreviations.\"\"\"\n+    return re.sub(r'\\.(?=\\s|$)', r'.\\@', text)\n+\n+\n+def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:\n+    \"\"\"Convert `width_str` with rst length to LaTeX length.\"\"\"\n+    match = re.match(r'^(\\d*\\.?\\d*)\\s*(\\S*)$', width_str)\n+    if not match:\n+        raise ValueError\n+    res = width_str\n+    amount, unit = match.groups()[:2]\n+    if scale == 100:\n+        float(amount)  # validate amount is float\n+        if unit in ('', \"px\"):\n+            res = r\"%s\\sphinxpxdimen\" % amount\n+        elif unit == 'pt':\n+            res = '%sbp' % amount  # convert to 'bp'\n+        elif unit == \"%\":\n+            res = r\"%.3f\\linewidth\" % (float(amount) / 100.0)\n+    else:\n+        amount_float = float(amount) * scale / 100.0\n+        if unit in ('', \"px\"):\n+            res = r\"%.5f\\sphinxpxdimen\" % amount_float\n+        elif unit == 'pt':\n+            res = '%.5fbp' % amount_float\n+        elif unit == \"%\":\n+            res = r\"%.5f\\linewidth\" % (amount_float / 100.0)\n+        else:\n+            res = \"%.5f%s\" % (amount_float, unit)\n+    return res\n+\n+\n+class LaTeXTranslator(SphinxTranslator):\n+    builder: \"LaTeXBuilder\" = None\n+\n+    secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls\n+    # default is originally 3. For book/report, 2 is already LaTeX default.\n+    ignore_missing_images = False\n+\n+    def __init__(self, document: nodes.document, builder: \"LaTeXBuilder\",\n+                 theme: \"Theme\") -> None:\n+        super().__init__(document, builder)\n+        self.body: List[str] = []\n+        self.theme = theme\n+\n+        # flags\n+        self.in_title = 0\n+        self.in_production_list = 0\n+        self.in_footnote = 0\n+        self.in_caption = 0\n+        self.in_term = 0\n+        self.needs_linetrimming = 0\n+        self.in_minipage = 0\n+        self.no_latex_floats = 0\n+        self.first_document = 1\n+        self.this_is_the_title = 1\n+        self.literal_whitespace = 0\n+        self.in_parsed_literal = 0\n+        self.compact_list = 0\n+        self.first_param = 0\n+        self.in_desc_signature = False\n+\n+        sphinxpkgoptions = []\n+\n+        # sort out some elements\n+        self.elements = self.builder.context.copy()\n+\n+        # initial section names\n+        self.sectionnames = LATEXSECTIONNAMES[:]\n+        if self.theme.toplevel_sectioning == 'section':\n+            self.sectionnames.remove('chapter')\n+\n+        # determine top section level\n+        self.top_sectionlevel = 1\n+        if self.config.latex_toplevel_sectioning:\n+            try:\n+                self.top_sectionlevel = \\\n+                    self.sectionnames.index(self.config.latex_toplevel_sectioning)\n+            except ValueError:\n+                logger.warning(__('unknown %r toplevel_sectioning for class %r') %\n+                               (self.config.latex_toplevel_sectioning, self.theme.docclass))\n+\n+        if self.config.numfig:\n+            self.numfig_secnum_depth = self.config.numfig_secnum_depth\n+            if self.numfig_secnum_depth > 0:  # default is 1\n+                # numfig_secnum_depth as passed to sphinx.sty indices same names as in\n+                # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...\n+                if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n+                   self.top_sectionlevel > 0:\n+                    self.numfig_secnum_depth += self.top_sectionlevel\n+                else:\n+                    self.numfig_secnum_depth += self.top_sectionlevel - 1\n+                # this (minus one) will serve as minimum to LaTeX's secnumdepth\n+                self.numfig_secnum_depth = min(self.numfig_secnum_depth,\n+                                               len(LATEXSECTIONNAMES) - 1)\n+                # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty\n+                sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)\n+            else:\n+                sphinxpkgoptions.append('nonumfigreset')\n+\n+        if self.config.numfig and self.config.math_numfig:\n+            sphinxpkgoptions.append('mathnumfig')\n+\n+        if (self.config.language not in {'en', 'ja'} and\n+                'fncychap' not in self.config.latex_elements):\n+            # use Sonny style if any language specified (except English)\n+            self.elements['fncychap'] = (r'\\usepackage[Sonny]{fncychap}' + CR +\n+                                         r'\\ChNameVar{\\Large\\normalfont\\sffamily}' + CR +\n+                                         r'\\ChTitleVar{\\Large\\normalfont\\sffamily}')\n+\n+        self.babel = self.builder.babel\n+        if not self.babel.is_supported_language():\n+            # emit warning if specified language is invalid\n+            # (only emitting, nothing changed to processing)\n+            logger.warning(__('no Babel option known for language %r'),\n+                           self.config.language)\n+\n+        minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto\n+        if self.document.get('tocdepth'):\n+            # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel\n+            #   tocdepth = -1: show only parts\n+            #   tocdepth =  0: show parts and chapters\n+            #   tocdepth =  1: show parts, chapters and sections\n+            #   tocdepth =  2: show parts, chapters, sections and subsections\n+            #   ...\n+            tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2\n+            if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n+               self.top_sectionlevel > 0:\n+                tocdepth += 1  # because top_sectionlevel is shifted by -1\n+            if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph\n+                logger.warning(__('too large :maxdepth:, ignored.'))\n+                tocdepth = len(LATEXSECTIONNAMES) - 2\n+\n+            self.elements['tocdepth'] = r'\\setcounter{tocdepth}{%d}' % tocdepth\n+            minsecnumdepth = max(minsecnumdepth, tocdepth)\n+\n+        if self.config.numfig and (self.config.numfig_secnum_depth > 0):\n+            minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)\n+\n+        if minsecnumdepth > self.secnumdepth:\n+            self.elements['secnumdepth'] = r'\\setcounter{secnumdepth}{%d}' %\\\n+                                           minsecnumdepth\n+\n+        contentsname = document.get('contentsname')\n+        if contentsname:\n+            self.elements['contentsname'] = self.babel_renewcommand(r'\\contentsname',\n+                                                                    contentsname)\n+\n+        if self.elements['maxlistdepth']:\n+            sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])\n+        if sphinxpkgoptions:\n+            self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)\n+        if self.elements['sphinxsetup']:\n+            self.elements['sphinxsetup'] = (r'\\sphinxsetup{%s}' % self.elements['sphinxsetup'])\n+        if self.elements['extraclassoptions']:\n+            self.elements['classoptions'] += ',' + \\\n+                                             self.elements['extraclassoptions']\n+\n+        self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,\n+                                                       latex_engine=self.config.latex_engine)\n+        self.context: List[Any] = []\n+        self.descstack: List[str] = []\n+        self.tables: List[Table] = []\n+        self.next_table_colspec: str = None\n+        self.bodystack: List[List[str]] = []\n+        self.footnote_restricted: Element = None\n+        self.pending_footnotes: List[nodes.footnote_reference] = []\n+        self.curfilestack: List[str] = []\n+        self.handled_abbrs: Set[str] = set()\n+\n+    def pushbody(self, newbody: List[str]) -> None:\n+        self.bodystack.append(self.body)\n+        self.body = newbody\n+\n+    def popbody(self) -> List[str]:\n+        body = self.body\n+        self.body = self.bodystack.pop()\n+        return body\n+\n+    def astext(self) -> str:\n+        self.elements.update({\n+            'body': ''.join(self.body),\n+            'indices': self.generate_indices()\n+        })\n+        return self.render('latex.tex_t', self.elements)\n+\n+    def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:\n+        if withdoc:\n+            id = self.curfilestack[-1] + ':' + id\n+        return (r'\\phantomsection' if anchor else '') + r'\\label{%s}' % self.idescape(id)\n+\n+    def hypertarget_to(self, node: Element, anchor: bool = False) -> str:\n+        labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])\n+        if anchor:\n+            return r'\\phantomsection' + labels\n+        else:\n+            return labels\n+\n+    def hyperlink(self, id: str) -> str:\n+        return r'{\\hyperref[%s]{' % self.idescape(id)\n+\n+    def hyperpageref(self, id: str) -> str:\n+        return r'\\autopageref*{%s}' % self.idescape(id)\n+\n+    def escape(self, s: str) -> str:\n+        return texescape.escape(s, self.config.latex_engine)\n+\n+    def idescape(self, id: str) -> str:\n+        return r'\\detokenize{%s}' % str(id).translate(tex_replace_map).\\\n+            encode('ascii', 'backslashreplace').decode('ascii').\\\n+            replace('\\\\', '_')\n+\n+    def babel_renewcommand(self, command: str, definition: str) -> str:\n+        if self.elements['multilingual']:\n+            prefix = r'\\addto\\captions%s{' % self.babel.get_language()\n+            suffix = '}'\n+        else:  # babel is disabled (mainly for Japanese environment)\n+            prefix = ''\n+            suffix = ''\n+\n+        return r'%s\\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR\n+\n+    def generate_indices(self) -> str:\n+        def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:\n+            ret.append(r'\\begin{sphinxtheindex}' + CR)\n+            ret.append(r'\\let\\bigletter\\sphinxstyleindexlettergroup' + CR)\n+            for i, (letter, entries) in enumerate(content):\n+                if i > 0:\n+                    ret.append(r'\\indexspace' + CR)\n+                ret.append(r'\\bigletter{%s}' % self.escape(letter) + CR)\n+                for entry in entries:\n+                    if not entry[3]:\n+                        continue\n+                    ret.append(r'\\item\\relax\\sphinxstyleindexentry{%s}' %\n+                               self.encode(entry[0]))\n+                    if entry[4]:\n+                        # add \"extra\" info\n+                        ret.append(r'\\sphinxstyleindexextra{%s}' % self.encode(entry[4]))\n+                    ret.append(r'\\sphinxstyleindexpageref{%s:%s}' %\n+                               (entry[2], self.idescape(entry[3])) + CR)\n+            ret.append(r'\\end{sphinxtheindex}' + CR)\n+\n+        ret = []\n+        # latex_domain_indices can be False/True or a list of index names\n+        indices_config = self.config.latex_domain_indices\n+        if indices_config:\n+            for domain in self.builder.env.domains.values():\n+                for indexcls in domain.indices:\n+                    indexname = '%s-%s' % (domain.name, indexcls.name)\n+                    if isinstance(indices_config, list):\n+                        if indexname not in indices_config:\n+                            continue\n+                    content, collapsed = indexcls(domain).generate(\n+                        self.builder.docnames)\n+                    if not content:\n+                        continue\n+                    ret.append(r'\\renewcommand{\\indexname}{%s}' % indexcls.localname + CR)\n+                    generate(content, collapsed)\n+\n+        return ''.join(ret)\n+\n+    def render(self, template_name: str, variables: Dict) -> str:\n+        renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)\n+        for template_dir in self.config.templates_path:\n+            template = path.join(self.builder.confdir, template_dir,\n+                                 template_name)\n+            if path.exists(template):\n+                return renderer.render(template, variables)\n+\n+        return renderer.render(template_name, variables)\n+\n+    @property\n+    def table(self) -> Table:\n+        \"\"\"Get current table.\"\"\"\n+        if self.tables:\n+            return self.tables[-1]\n+        else:\n+            return None\n+\n+    def visit_document(self, node: Element) -> None:\n+        self.curfilestack.append(node.get('docname', ''))\n+        if self.first_document == 1:\n+            # the first document is all the regular content ...\n+            self.first_document = 0\n+        elif self.first_document == 0:\n+            # ... and all others are the appendices\n+            self.body.append(CR + r'\\appendix' + CR)\n+            self.first_document = -1\n+        if 'docname' in node:\n+            self.body.append(self.hypertarget(':doc'))\n+        # \"- 1\" because the level is increased before the title is visited\n+        self.sectionlevel = self.top_sectionlevel - 1\n+\n+    def depart_document(self, node: Element) -> None:\n+        pass\n+\n+    def visit_start_of_file(self, node: Element) -> None:\n+        self.curfilestack.append(node['docname'])\n+        self.body.append(CR + r'\\sphinxstepscope' + CR)\n+\n+    def depart_start_of_file(self, node: Element) -> None:\n+        self.curfilestack.pop()\n+\n+    def visit_section(self, node: Element) -> None:\n+        if not self.this_is_the_title:\n+            self.sectionlevel += 1\n+        self.body.append(BLANKLINE)\n+\n+    def depart_section(self, node: Element) -> None:\n+        self.sectionlevel = max(self.sectionlevel - 1,\n+                                self.top_sectionlevel - 1)\n+\n+    def visit_problematic(self, node: Element) -> None:\n+        self.body.append(r'{\\color{red}\\bfseries{}')\n+\n+    def depart_problematic(self, node: Element) -> None:\n+        self.body.append('}')\n+\n+    def visit_topic(self, node: Element) -> None:\n+        self.in_minipage = 1\n+        self.body.append(CR + r'\\begin{sphinxShadowBox}' + CR)\n+\n+    def depart_topic(self, node: Element) -> None:\n+        self.in_minipage = 0\n+        self.body.append(r'\\end{sphinxShadowBox}' + CR)\n+    visit_sidebar = visit_topic\n+    depart_sidebar = depart_topic\n+\n+    def visit_glossary(self, node: Element) -> None:\n+        pass\n+\n+    def depart_glossary(self, node: Element) -> None:\n+        pass\n+\n+    def visit_productionlist(self, node: Element) -> None:\n+        self.body.append(BLANKLINE)\n+        self.body.append(r'\\begin{productionlist}' + CR)\n+        self.in_production_list = 1\n+\n+    def depart_productionlist(self, node: Element) -> None:\n+        self.body.append(r'\\end{productionlist}' + BLANKLINE)\n+        self.in_production_list = 0\n+\n+    def visit_production(self, node: Element) -> None:\n+        if node['tokenname']:\n+            tn = node['tokenname']\n+            self.body.append(self.hypertarget('grammar-token-' + tn))\n+            self.body.append(r'\\production{%s}{' % self.encode(tn))\n+        else:\n+            self.body.append(r'\\productioncont{')\n+\n+    def depart_production(self, node: Element) -> None:\n+        self.body.append('}' + CR)\n+\n+    def visit_transition(self, node: Element) -> None:\n+        self.body.append(self.elements['transition'])\n+\n+    def depart_transition(self, node: Element) -> None:\n+        pass\n+\n+    def visit_title(self, node: Element) -> None:\n+        parent = node.parent\n+        if isinstance(parent, addnodes.seealso):\n+            # the environment already handles this\n+            raise nodes.SkipNode\n+        elif isinstance(parent, nodes.section):\n+            if self.this_is_the_title:\n+                if len(node.children) != 1 and not isinstance(node.children[0],\n+                                                              nodes.Text):\n+                    logger.warning(__('document title is not a single Text node'),\n+                                   location=node)\n+                if not self.elements['title']:\n+                    # text needs to be escaped since it is inserted into\n+                    # the output literally\n+                    self.elements['title'] = self.escape(node.astext())\n+                self.this_is_the_title = 0\n+                raise nodes.SkipNode\n+            else:\n+                short = ''\n+                if any(node.findall(nodes.image)):\n+                    short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))\n+\n+                try:\n+                    self.body.append(r'\\%s%s{' % (self.sectionnames[self.sectionlevel], short))\n+                except IndexError:\n+                    # just use \"subparagraph\", it's not numbered anyway\n+                    self.body.append(r'\\%s%s{' % (self.sectionnames[-1], short))\n+                self.context.append('}' + CR + self.hypertarget_to(node.parent))\n+        elif isinstance(parent, nodes.topic):\n+            self.body.append(r'\\sphinxstyletopictitle{')\n+            self.context.append('}' + CR)\n+        elif isinstance(parent, nodes.sidebar):\n+            self.body.append(r'\\sphinxstylesidebartitle{')\n+            self.context.append('}' + CR)\n+        elif isinstance(parent, nodes.Admonition):\n+            self.body.append('{')\n+            self.context.append('}' + CR)\n+        elif isinstance(parent, nodes.table):\n+            # Redirect body output until title is finished.\n+            self.pushbody([])\n+        else:\n+            logger.warning(__('encountered title node not in section, topic, table, '\n+                              'admonition or sidebar'),\n+                           location=node)\n+            self.body.append(r'\\sphinxstyleothertitle{')\n+            self.context.append('}' + CR)\n+        self.in_title = 1\n+\n+    def depart_title(self, node: Element) -> None:\n+        self.in_title = 0\n+        if isinstance(node.parent, nodes.table):\n+            self.table.caption = self.popbody()\n+        else:\n+            self.body.append(self.context.pop())\n+\n+    def visit_subtitle(self, node: Element) -> None:\n+        if isinstance(node.parent, nodes.sidebar):\n+            self.body.append(r'\\sphinxstylesidebarsubtitle{')\n+            self.context.append('}' + CR)\n+        else:\n+            self.context.append('')\n+\n+    def depart_subtitle(self, node: Element) -> None:\n+        self.body.append(self.context.pop())\n+\n+    #############################################################\n+    # Domain-specific object descriptions\n+    #############################################################\n+\n+    # Top-level nodes for descriptions\n+    ##################################\n+\n+    def visit_desc(self, node: Element) -> None:\n+        if self.config.latex_show_urls == 'footnote':\n+            self.body.append(BLANKLINE)\n+            self.body.append(r'\\begin{savenotes}\\begin{fulllineitems}' + CR)\n+        else:\n+            self.body.append(BLANKLINE)\n+            self.body.append(r'\\begin{fulllineitems}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_desc(self, node: Element) -> None:\n+        if self.in_desc_signature:\n+            self.body.append(CR + r'\\pysigstopsignatures')\n+            self.in_desc_signature = False\n+        if self.config.latex_show_urls == 'footnote':\n+            self.body.append(CR + r'\\end{fulllineitems}\\end{savenotes}' + BLANKLINE)\n+        else:\n+            self.body.append(CR + r'\\end{fulllineitems}' + BLANKLINE)\n+\n+    def _visit_signature_line(self, node: Element) -> None:\n+        for child in node:\n+            if isinstance(child, addnodes.desc_parameterlist):\n+                self.body.append(CR + r'\\pysiglinewithargsret{')\n+                break\n+        else:\n+            self.body.append(CR + r'\\pysigline{')\n+\n+    def _depart_signature_line(self, node: Element) -> None:\n+        self.body.append('}')\n+\n+    def visit_desc_signature(self, node: Element) -> None:\n+        if node.parent['objtype'] != 'describe' and node['ids']:\n+            hyper = self.hypertarget(node['ids'][0])\n+        else:\n+            hyper = ''\n+        self.body.append(hyper)\n+        if not self.in_desc_signature:\n+            self.in_desc_signature = True\n+            self.body.append(CR + r'\\pysigstartsignatures')\n+        if not node.get('is_multiline'):\n+            self._visit_signature_line(node)\n+        else:\n+            self.body.append(CR + r'\\pysigstartmultiline')\n+\n+    def depart_desc_signature(self, node: Element) -> None:\n+        if not node.get('is_multiline'):\n+            self._depart_signature_line(node)\n+        else:\n+            self.body.append(CR + r'\\pysigstopmultiline')\n+\n+    def visit_desc_signature_line(self, node: Element) -> None:\n+        self._visit_signature_line(node)\n+\n+    def depart_desc_signature_line(self, node: Element) -> None:\n+        self._depart_signature_line(node)\n+\n+    def visit_desc_content(self, node: Element) -> None:\n+        assert self.in_desc_signature\n+        self.body.append(CR + r'\\pysigstopsignatures')\n+        self.in_desc_signature = False\n+\n+    def depart_desc_content(self, node: Element) -> None:\n+        pass\n+\n+    def visit_desc_inline(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+\n+    def depart_desc_inline(self, node: Element) -> None:\n+        self.body.append('}}')\n+\n+    # Nodes for high-level structure in signatures\n+    ##############################################\n+\n+    def visit_desc_name(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n+        self.literal_whitespace += 1\n+\n+    def depart_desc_name(self, node: Element) -> None:\n+        self.body.append('}}')\n+        self.literal_whitespace -= 1\n+\n+    def visit_desc_addname(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+        self.literal_whitespace += 1\n+\n+    def depart_desc_addname(self, node: Element) -> None:\n+        self.body.append('}}')\n+        self.literal_whitespace -= 1\n+\n+    def visit_desc_type(self, node: Element) -> None:\n+        pass\n+\n+    def depart_desc_type(self, node: Element) -> None:\n+        pass\n+\n+    def visit_desc_returns(self, node: Element) -> None:\n+        self.body.append(r'{ $\\rightarrow$ ')\n+\n+    def depart_desc_returns(self, node: Element) -> None:\n+        self.body.append(r'}')\n+\n+    def visit_desc_parameterlist(self, node: Element) -> None:\n+        # close name, open parameterlist\n+        self.body.append('}{')\n+        self.first_param = 1\n+\n+    def depart_desc_parameterlist(self, node: Element) -> None:\n+        # close parameterlist, open return annotation\n+        self.body.append('}{')\n+\n+    def visit_desc_parameter(self, node: Element) -> None:\n+        if not self.first_param:\n+            self.body.append(', ')\n+        else:\n+            self.first_param = 0\n+        if not node.hasattr('noemph'):\n+            self.body.append(r'\\emph{')\n+\n+    def depart_desc_parameter(self, node: Element) -> None:\n+        if not node.hasattr('noemph'):\n+            self.body.append('}')\n+\n+    def visit_desc_optional(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxoptional{')\n+\n+    def depart_desc_optional(self, node: Element) -> None:\n+        self.body.append('}')\n+\n+    def visit_desc_annotation(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n+\n+    def depart_desc_annotation(self, node: Element) -> None:\n+        self.body.append('}}')\n+\n+    ##############################################\n+\n+    def visit_seealso(self, node: Element) -> None:\n+        self.body.append(BLANKLINE)\n+        self.body.append(r'\\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)\n+        self.body.append(r'\\nopagebreak' + BLANKLINE)\n+\n+    def depart_seealso(self, node: Element) -> None:\n+        self.body.append(BLANKLINE)\n+\n+    def visit_rubric(self, node: Element) -> None:\n+        if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):\n+            raise nodes.SkipNode\n+        self.body.append(r'\\subsubsection*{')\n+        self.context.append('}' + CR)\n+        self.in_title = 1\n+\n+    def depart_rubric(self, node: Element) -> None:\n+        self.in_title = 0\n+        self.body.append(self.context.pop())\n+\n+    def visit_footnote(self, node: Element) -> None:\n+        self.in_footnote += 1\n+        label = cast(nodes.label, node[0])\n+        if self.in_parsed_literal:\n+            self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n+        else:\n+            self.body.append('%' + CR)\n+            self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n+        if 'referred' in node:\n+            # TODO: in future maybe output a latex macro with backrefs here\n+            pass\n+        self.body.append(r'\\sphinxAtStartFootnote' + CR)\n+\n+    def depart_footnote(self, node: Element) -> None:\n+        if self.in_parsed_literal:\n+            self.body.append(r'\\end{footnote}')\n+        else:\n+            self.body.append('%' + CR)\n+            self.body.append(r'\\end{footnote}')\n+        self.in_footnote -= 1\n+\n+    def visit_label(self, node: Element) -> None:\n+        raise nodes.SkipNode\n+\n+    def visit_tabular_col_spec(self, node: Element) -> None:\n+        self.next_table_colspec = node['spec']\n+        raise nodes.SkipNode\n+\n+    def visit_table(self, node: Element) -> None:\n+        if len(self.tables) == 1:\n+            if self.table.get_table_type() == 'longtable':\n+                raise UnsupportedError(\n+                    '%s:%s: longtable does not support nesting a table.' %\n+                    (self.curfilestack[-1], node.line or ''))\n+            else:\n+                # change type of parent table to tabular\n+                # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ\n+                self.table.has_problematic = True\n+        elif len(self.tables) > 2:\n+            raise UnsupportedError(\n+                '%s:%s: deeply nested tables are not implemented.' %\n+                (self.curfilestack[-1], node.line or ''))\n+\n+        self.tables.append(Table(node))\n+        if self.next_table_colspec:\n+            self.table.colspec = '{%s}' % self.next_table_colspec + CR\n+            if 'colwidths-given' in node.get('classes', []):\n+                logger.info(__('both tabularcolumns and :widths: option are given. '\n+                               ':widths: is ignored.'), location=node)\n+        self.next_table_colspec = None\n+\n+    def depart_table(self, node: Element) -> None:\n+        labels = self.hypertarget_to(node)\n+        table_type = self.table.get_table_type()\n+        table = self.render(table_type + '.tex_t',\n+                            dict(table=self.table, labels=labels))\n+        self.body.append(BLANKLINE)\n+        self.body.append(table)\n+        self.body.append(CR)\n+\n+        self.tables.pop()\n+\n+    def visit_colspec(self, node: Element) -> None:\n+        self.table.colcount += 1\n+        if 'colwidth' in node:\n+            self.table.colwidths.append(node['colwidth'])\n+        if 'stub' in node:\n+            self.table.stubs.append(self.table.colcount - 1)\n+\n+    def depart_colspec(self, node: Element) -> None:\n+        pass\n+\n+    def visit_tgroup(self, node: Element) -> None:\n+        pass\n+\n+    def depart_tgroup(self, node: Element) -> None:\n+        pass\n+\n+    def visit_thead(self, node: Element) -> None:\n+        # Redirect head output until header is finished.\n+        self.pushbody(self.table.header)\n+\n+    def depart_thead(self, node: Element) -> None:\n+        self.popbody()\n+\n+    def visit_tbody(self, node: Element) -> None:\n+        # Redirect body output until table is finished.\n+        self.pushbody(self.table.body)\n+\n+    def depart_tbody(self, node: Element) -> None:\n+        self.popbody()\n+\n+    def visit_row(self, node: Element) -> None:\n+        self.table.col = 0\n+\n+        # fill columns if the row starts with the bottom of multirow cell\n+        while True:\n+            cell = self.table.cell(self.table.row, self.table.col)\n+            if cell is None:  # not a bottom of multirow cell\n+                break\n+            else:  # a bottom of multirow cell\n+                self.table.col += cell.width\n+                if cell.col:\n+                    self.body.append('&')\n+                if cell.width == 1:\n+                    # insert suitable strut for equalizing row heights in given multirow\n+                    self.body.append(r'\\sphinxtablestrut{%d}' % cell.cell_id)\n+                else:  # use \\multicolumn for wide multirow cell\n+                    self.body.append(r'\\multicolumn{%d}{|l|}{\\sphinxtablestrut{%d}}' %\n+                                     (cell.width, cell.cell_id))\n+\n+    def depart_row(self, node: Element) -> None:\n+        self.body.append(r'\\\\' + CR)\n+        cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]\n+        underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]\n+        if all(underlined):\n+            self.body.append(r'\\hline')\n+        else:\n+            i = 0\n+            underlined.extend([False])  # sentinel\n+            while i < len(underlined):\n+                if underlined[i] is True:\n+                    j = underlined[i:].index(False)\n+                    self.body.append(r'\\cline{%d-%d}' % (i + 1, i + j))\n+                    i += j\n+                i += 1\n+        self.table.row += 1\n+\n+    def visit_entry(self, node: Element) -> None:\n+        if self.table.col > 0:\n+            self.body.append('&')\n+        self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)\n+        cell = self.table.cell()\n+        context = ''\n+        if cell.width > 1:\n+            if self.config.latex_use_latex_multicolumn:\n+                if self.table.col == 0:\n+                    self.body.append(r'\\multicolumn{%d}{|l|}{%%' % cell.width + CR)\n+                else:\n+                    self.body.append(r'\\multicolumn{%d}{l|}{%%' % cell.width + CR)\n+                context = '}%' + CR\n+            else:\n+                self.body.append(r'\\sphinxstartmulticolumn{%d}%%' % cell.width + CR)\n+                context = r'\\sphinxstopmulticolumn' + CR\n+        if cell.height > 1:\n+            # \\sphinxmultirow 2nd arg \"cell_id\" will serve as id for LaTeX macros as well\n+            self.body.append(r'\\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)\n+            context = '}%' + CR + context\n+        if cell.width > 1 or cell.height > 1:\n+            self.body.append(r'\\begin{varwidth}[t]{\\sphinxcolwidth{%d}{%d}}'\n+                             % (cell.width, self.table.colcount) + CR)\n+            context = (r'\\par' + CR + r'\\vskip-\\baselineskip'\n+                       r'\\vbox{\\hbox{\\strut}}\\end{varwidth}%' + CR + context)\n+            self.needs_linetrimming = 1\n+        if len(list(node.findall(nodes.paragraph))) >= 2:\n+            self.table.has_oldproblematic = True\n+        if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):\n+            if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':\n+                pass\n+            else:\n+                self.body.append(r'\\sphinxstyletheadfamily ')\n+        if self.needs_linetrimming:\n+            self.pushbody([])\n+        self.context.append(context)\n+\n+    def depart_entry(self, node: Element) -> None:\n+        if self.needs_linetrimming:\n+            self.needs_linetrimming = 0\n+            body = self.popbody()\n+\n+            # Remove empty lines from top of merged cell\n+            while body and body[0] == CR:\n+                body.pop(0)\n+            self.body.extend(body)\n+\n+        self.body.append(self.context.pop())\n+\n+        cell = self.table.cell()\n+        self.table.col += cell.width\n+\n+        # fill columns if next ones are a bottom of wide-multirow cell\n+        while True:\n+            nextcell = self.table.cell()\n+            if nextcell is None:  # not a bottom of multirow cell\n+                break\n+            else:  # a bottom part of multirow cell\n+                self.table.col += nextcell.width\n+                self.body.append('&')\n+                if nextcell.width == 1:\n+                    # insert suitable strut for equalizing row heights in multirow\n+                    # they also serve to clear colour panels which would hide the text\n+                    self.body.append(r'\\sphinxtablestrut{%d}' % nextcell.cell_id)\n+                else:\n+                    # use \\multicolumn for wide multirow cell\n+                    self.body.append(r'\\multicolumn{%d}{l|}{\\sphinxtablestrut{%d}}' %\n+                                     (nextcell.width, nextcell.cell_id))\n+\n+    def visit_acks(self, node: Element) -> None:\n+        # this is a list in the source, but should be rendered as a\n+        # comma-separated list here\n+        bullet_list = cast(nodes.bullet_list, node[0])\n+        list_items = cast(Iterable[nodes.list_item], bullet_list)\n+        self.body.append(BLANKLINE)\n+        self.body.append(', '.join(n.astext() for n in list_items) + '.')\n+        self.body.append(BLANKLINE)\n+        raise nodes.SkipNode\n+\n+    def visit_bullet_list(self, node: Element) -> None:\n+        if not self.compact_list:\n+            self.body.append(r'\\begin{itemize}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_bullet_list(self, node: Element) -> None:\n+        if not self.compact_list:\n+            self.body.append(r'\\end{itemize}' + CR)\n+\n+    def visit_enumerated_list(self, node: Element) -> None:\n+        def get_enumtype(node: Element) -> str:\n+            enumtype = node.get('enumtype', 'arabic')\n+            if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):\n+                # fallback to arabic if alphabet counter overflows\n+                enumtype = 'arabic'\n+\n+            return enumtype\n+\n+        def get_nested_level(node: Element) -> int:\n+            if node is None:\n+                return 0\n+            elif isinstance(node, nodes.enumerated_list):\n+                return get_nested_level(node.parent) + 1\n+            else:\n+                return get_nested_level(node.parent)\n+\n+        enum = \"enum%s\" % toRoman(get_nested_level(node)).lower()\n+        enumnext = \"enum%s\" % toRoman(get_nested_level(node) + 1).lower()\n+        style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))\n+        prefix = node.get('prefix', '')\n+        suffix = node.get('suffix', '.')\n+\n+        self.body.append(r'\\begin{enumerate}' + CR)\n+        self.body.append(r'\\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %\n+                         (style, enum, enumnext, prefix, suffix) + CR)\n+        if 'start' in node:\n+            self.body.append(r'\\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_enumerated_list(self, node: Element) -> None:\n+        self.body.append(r'\\end{enumerate}' + CR)\n+\n+    def visit_list_item(self, node: Element) -> None:\n+        # Append \"{}\" in case the next character is \"[\", which would break\n+        # LaTeX's list environment (no numbering and the \"[\" is not printed).\n+        self.body.append(r'\\item {} ')\n+\n+    def depart_list_item(self, node: Element) -> None:\n+        self.body.append(CR)\n+\n+    def visit_definition_list(self, node: Element) -> None:\n+        self.body.append(r'\\begin{description}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_definition_list(self, node: Element) -> None:\n+        self.body.append(r'\\end{description}' + CR)\n+\n+    def visit_definition_list_item(self, node: Element) -> None:\n+        pass\n+\n+    def depart_definition_list_item(self, node: Element) -> None:\n+        pass\n+\n+    def visit_term(self, node: Element) -> None:\n+        self.in_term += 1\n+        ctx = ''\n+        if node.get('ids'):\n+            ctx = r'\\phantomsection'\n+            for node_id in node['ids']:\n+                ctx += self.hypertarget(node_id, anchor=False)\n+        ctx += r'}'\n+        self.body.append(r'\\sphinxlineitem{')\n+        self.context.append(ctx)\n+\n+    def depart_term(self, node: Element) -> None:\n+        self.body.append(self.context.pop())\n+        self.in_term -= 1\n+\n+    def visit_classifier(self, node: Element) -> None:\n+        self.body.append('{[}')\n+\n+    def depart_classifier(self, node: Element) -> None:\n+        self.body.append('{]}')\n+\n+    def visit_definition(self, node: Element) -> None:\n+        pass\n+\n+    def depart_definition(self, node: Element) -> None:\n+        self.body.append(CR)\n+\n+    def visit_field_list(self, node: Element) -> None:\n+        self.body.append(r'\\begin{quote}\\begin{description}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_field_list(self, node: Element) -> None:\n+        self.body.append(r'\\end{description}\\end{quote}' + CR)\n+\n+    def visit_field(self, node: Element) -> None:\n+        pass\n+\n+    def depart_field(self, node: Element) -> None:\n+        pass\n+\n+    visit_field_name = visit_term\n+    depart_field_name = depart_term\n+\n+    visit_field_body = visit_definition\n+    depart_field_body = depart_definition\n+\n+    def visit_paragraph(self, node: Element) -> None:\n+        index = node.parent.index(node)\n+        if (index > 0 and isinstance(node.parent, nodes.compound) and\n+                not isinstance(node.parent[index - 1], nodes.paragraph) and\n+                not isinstance(node.parent[index - 1], nodes.compound)):\n+            # insert blank line, if the paragraph follows a non-paragraph node in a compound\n+            self.body.append(r'\\noindent' + CR)\n+        elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):\n+            # don't insert blank line, if the paragraph is second child of a footnote\n+            # (first one is label node)\n+            pass\n+        else:\n+            # the \\sphinxAtStartPar is to allow hyphenation of first word of\n+            # a paragraph in narrow contexts such as in a table cell\n+            # added as two items (cf. line trimming in depart_entry())\n+            self.body.extend([CR, r'\\sphinxAtStartPar' + CR])\n+\n+    def depart_paragraph(self, node: Element) -> None:\n+        self.body.append(CR)\n+\n+    def visit_centered(self, node: Element) -> None:\n+        self.body.append(CR + r'\\begin{center}')\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_centered(self, node: Element) -> None:\n+        self.body.append(CR + r'\\end{center}')\n+\n+    def visit_hlist(self, node: Element) -> None:\n+        self.compact_list += 1\n+        ncolumns = node['ncolumns']\n+        if self.compact_list > 1:\n+            self.body.append(r'\\setlength{\\multicolsep}{0pt}' + CR)\n+        self.body.append(r'\\begin{multicols}{' + ncolumns + r'}\\raggedright' + CR)\n+        self.body.append(r'\\begin{itemize}\\setlength{\\itemsep}{0pt}'\n+                         r'\\setlength{\\parskip}{0pt}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_hlist(self, node: Element) -> None:\n+        self.compact_list -= 1\n+        self.body.append(r'\\end{itemize}\\raggedcolumns\\end{multicols}' + CR)\n+\n+    def visit_hlistcol(self, node: Element) -> None:\n+        pass\n+\n+    def depart_hlistcol(self, node: Element) -> None:\n+        # \\columnbreak would guarantee same columns as in html output.  But\n+        # some testing with long items showed that columns may be too uneven.\n+        # And in case only of short items, the automatic column breaks should\n+        # match the ones pre-computed by the hlist() directive.\n+        # self.body.append(r'\\columnbreak\\n')\n+        pass\n+\n+    def latex_image_length(self, width_str: str, scale: int = 100) -> str:\n+        try:\n+            return rstdim_to_latexdim(width_str, scale)\n+        except ValueError:\n+            logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)\n+            return None\n+\n+    def is_inline(self, node: Element) -> bool:\n+        \"\"\"Check whether a node represents an inline element.\"\"\"\n+        return isinstance(node.parent, nodes.TextElement)\n+\n+    def visit_image(self, node: Element) -> None:\n+        pre: List[str] = []  # in reverse order\n+        post: List[str] = []\n+        include_graphics_options = []\n+        has_hyperlink = isinstance(node.parent, nodes.reference)\n+        if has_hyperlink:\n+            is_inline = self.is_inline(node.parent)\n+        else:\n+            is_inline = self.is_inline(node)\n+        if 'width' in node:\n+            if 'scale' in node:\n+                w = self.latex_image_length(node['width'], node['scale'])\n+            else:\n+                w = self.latex_image_length(node['width'])\n+            if w:\n+                include_graphics_options.append('width=%s' % w)\n+        if 'height' in node:\n+            if 'scale' in node:\n+                h = self.latex_image_length(node['height'], node['scale'])\n+            else:\n+                h = self.latex_image_length(node['height'])\n+            if h:\n+                include_graphics_options.append('height=%s' % h)\n+        if 'scale' in node:\n+            if not include_graphics_options:\n+                # if no \"width\" nor \"height\", \\sphinxincludegraphics will fit\n+                # to the available text width if oversized after rescaling.\n+                include_graphics_options.append('scale=%s'\n+                                                % (float(node['scale']) / 100.0))\n+        if 'align' in node:\n+            align_prepost = {\n+                # By default latex aligns the top of an image.\n+                (1, 'top'): ('', ''),\n+                (1, 'middle'): (r'\\raisebox{-0.5\\height}{', '}'),\n+                (1, 'bottom'): (r'\\raisebox{-\\height}{', '}'),\n+                (0, 'center'): (r'{\\hspace*{\\fill}', r'\\hspace*{\\fill}}'),\n+                # These 2 don't exactly do the right thing.  The image should\n+                # be floated alongside the paragraph.  See\n+                # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG\n+                (0, 'left'): ('{', r'\\hspace*{\\fill}}'),\n+                (0, 'right'): (r'{\\hspace*{\\fill}', '}'),\n+            }\n+            try:\n+                pre.append(align_prepost[is_inline, node['align']][0])\n+                post.append(align_prepost[is_inline, node['align']][1])\n+            except KeyError:\n+                pass\n+        if self.in_parsed_literal:\n+            pre.append(r'{\\sphinxunactivateextrasandspace ')\n+            post.append('}')\n+        if not is_inline and not has_hyperlink:\n+            pre.append(CR + r'\\noindent')\n+            post.append(CR)\n+        pre.reverse()\n+        if node['uri'] in self.builder.images:\n+            uri = self.builder.images[node['uri']]\n+        else:\n+            # missing image!\n+            if self.ignore_missing_images:\n+                return\n+            uri = node['uri']\n+        if uri.find('://') != -1:\n+            # ignore remote images\n+            return\n+        self.body.extend(pre)\n+        options = ''\n+        if include_graphics_options:\n+            options = '[%s]' % ','.join(include_graphics_options)\n+        base, ext = path.splitext(uri)\n+        if self.in_title and base:\n+            # Lowercase tokens forcely because some fncychap themes capitalize\n+            # the options of \\sphinxincludegraphics unexpectedly (ex. WIDTH=...).\n+            self.body.append(r'\\lowercase{\\sphinxincludegraphics%s}{{%s}%s}' %\n+                             (options, base, ext))\n+        else:\n+            self.body.append(r'\\sphinxincludegraphics%s{{%s}%s}' %\n+                             (options, base, ext))\n+        self.body.extend(post)\n+\n+    def depart_image(self, node: Element) -> None:\n+        pass\n+\n+    def visit_figure(self, node: Element) -> None:\n+        align = self.elements['figure_align']\n+        if self.no_latex_floats:\n+            align = \"H\"\n+        if self.table:\n+            # TODO: support align option\n+            if 'width' in node:\n+                length = self.latex_image_length(node['width'])\n+                if length:\n+                    self.body.append(r'\\begin{sphinxfigure-in-table}[%s]' % length + CR)\n+                    self.body.append(r'\\centering' + CR)\n+            else:\n+                self.body.append(r'\\begin{sphinxfigure-in-table}' + CR)\n+                self.body.append(r'\\centering' + CR)\n+            if any(isinstance(child, nodes.caption) for child in node):\n+                self.body.append(r'\\capstart')\n+            self.context.append(r'\\end{sphinxfigure-in-table}\\relax' + CR)\n+        elif node.get('align', '') in ('left', 'right'):\n+            length = None\n+            if 'width' in node:\n+                length = self.latex_image_length(node['width'])\n+            elif isinstance(node[0], nodes.image) and 'width' in node[0]:\n+                length = self.latex_image_length(node[0]['width'])\n+            self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop\n+                                            # https://github.com/sphinx-doc/sphinx/issues/7059\n+            self.body.append(r'\\begin{wrapfigure}{%s}{%s}' %\n+                             ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)\n+            self.body.append(r'\\centering')\n+            self.context.append(r'\\end{wrapfigure}' + CR)\n+        elif self.in_minipage:\n+            self.body.append(CR + r'\\begin{center}')\n+            self.context.append(r'\\end{center}' + CR)\n+        else:\n+            self.body.append(CR + r'\\begin{figure}[%s]' % align + CR)\n+            self.body.append(r'\\centering' + CR)\n+            if any(isinstance(child, nodes.caption) for child in node):\n+                self.body.append(r'\\capstart' + CR)\n+            self.context.append(r'\\end{figure}' + CR)\n+\n+    def depart_figure(self, node: Element) -> None:\n+        self.body.append(self.context.pop())\n+\n+    def visit_caption(self, node: Element) -> None:\n+        self.in_caption += 1\n+        if isinstance(node.parent, captioned_literal_block):\n+            self.body.append(r'\\sphinxSetupCaptionForVerbatim{')\n+        elif self.in_minipage and isinstance(node.parent, nodes.figure):\n+            self.body.append(r'\\captionof{figure}{')\n+        elif self.table and node.parent.tagname == 'figure':\n+            self.body.append(r'\\sphinxfigcaption{')\n+        else:\n+            self.body.append(r'\\caption{')\n+\n+    def depart_caption(self, node: Element) -> None:\n+        self.body.append('}')\n+        if isinstance(node.parent, nodes.figure):\n+            labels = self.hypertarget_to(node.parent)\n+            self.body.append(labels)\n+        self.in_caption -= 1\n+\n+    def visit_legend(self, node: Element) -> None:\n+        self.body.append(CR + r'\\begin{sphinxlegend}')\n+\n+    def depart_legend(self, node: Element) -> None:\n+        self.body.append(r'\\end{sphinxlegend}' + CR)\n+\n+    def visit_admonition(self, node: Element) -> None:\n+        self.body.append(CR + r'\\begin{sphinxadmonition}{note}')\n+        self.no_latex_floats += 1\n+\n+    def depart_admonition(self, node: Element) -> None:\n+        self.body.append(r'\\end{sphinxadmonition}' + CR)\n+        self.no_latex_floats -= 1\n+\n+    def _visit_named_admonition(self, node: Element) -> None:\n+        label = admonitionlabels[node.tagname]\n+        self.body.append(CR + r'\\begin{sphinxadmonition}{%s}{%s:}' %\n+                         (node.tagname, label))\n+        self.no_latex_floats += 1\n+\n+    def _depart_named_admonition(self, node: Element) -> None:\n+        self.body.append(r'\\end{sphinxadmonition}' + CR)\n+        self.no_latex_floats -= 1\n+\n+    visit_attention = _visit_named_admonition\n+    depart_attention = _depart_named_admonition\n+    visit_caution = _visit_named_admonition\n+    depart_caution = _depart_named_admonition\n+    visit_danger = _visit_named_admonition\n+    depart_danger = _depart_named_admonition\n+    visit_error = _visit_named_admonition\n+    depart_error = _depart_named_admonition\n+    visit_hint = _visit_named_admonition\n+    depart_hint = _depart_named_admonition\n+    visit_important = _visit_named_admonition\n+    depart_important = _depart_named_admonition\n+    visit_note = _visit_named_admonition\n+    depart_note = _depart_named_admonition\n+    visit_tip = _visit_named_admonition\n+    depart_tip = _depart_named_admonition\n+    visit_warning = _visit_named_admonition\n+    depart_warning = _depart_named_admonition\n+\n+    def visit_versionmodified(self, node: Element) -> None:\n+        pass\n+\n+    def depart_versionmodified(self, node: Element) -> None:\n+        pass\n+\n+    def visit_target(self, node: Element) -> None:\n+        def add_target(id: str) -> None:\n+            # indexing uses standard LaTeX index markup, so the targets\n+            # will be generated differently\n+            if id.startswith('index-'):\n+                return\n+\n+            # equations also need no extra blank line nor hypertarget\n+            # TODO: fix this dependency on mathbase extension internals\n+            if id.startswith('equation-'):\n+                return\n+\n+            # insert blank line, if the target follows a paragraph node\n+            index = node.parent.index(node)\n+            if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):\n+                self.body.append(CR)\n+\n+            # do not generate \\phantomsection in \\section{}\n+            anchor = not self.in_title\n+            self.body.append(self.hypertarget(id, anchor=anchor))\n+\n+        # skip if visitor for next node supports hyperlink\n+        next_node: Node = node\n+        while isinstance(next_node, nodes.target):\n+            next_node = next_node.next_node(ascend=True)\n+\n+        domain = cast(StandardDomain, self.builder.env.get_domain('std'))\n+        if isinstance(next_node, HYPERLINK_SUPPORT_NODES):\n+            return\n+        elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):\n+            return\n+\n+        if 'refuri' in node:\n+            return\n+        if 'anonymous' in node:\n+            return\n+        if node.get('refid'):\n+            prev_node = get_prev_node(node)\n+            if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:\n+                # a target for a hyperlink reference having alias\n+                pass\n+            else:\n+                add_target(node['refid'])\n+        for id in node['ids']:\n+            add_target(id)\n+\n+    def depart_target(self, node: Element) -> None:\n+        pass\n+\n+    def visit_attribution(self, node: Element) -> None:\n+        self.body.append(CR + r'\\begin{flushright}' + CR)\n+        self.body.append('---')\n+\n+    def depart_attribution(self, node: Element) -> None:\n+        self.body.append(CR + r'\\end{flushright}' + CR)\n+\n+    def visit_index(self, node: Element) -> None:\n+        def escape(value: str) -> str:\n+            value = self.encode(value)\n+            value = value.replace(r'\\{', r'\\sphinxleftcurlybrace{}')\n+            value = value.replace(r'\\}', r'\\sphinxrightcurlybrace{}')\n+            value = value.replace('\"', '\"\"')\n+            value = value.replace('@', '\"@')\n+            value = value.replace('!', '\"!')\n+            value = value.replace('|', r'\\textbar{}')\n+            return value\n+\n+        def style(string: str) -> str:\n+            match = EXTRA_RE.match(string)\n+            if match:\n+                return match.expand(r'\\\\spxentry{\\1}\\\\spxextra{\\2}')\n+            else:\n+                return r'\\spxentry{%s}' % string\n+\n+        if not node.get('inline', True):\n+            self.body.append(CR)\n+        entries = node['entries']\n+        for type, string, _tid, ismain, _key in entries:\n+            m = ''\n+            if ismain:\n+                m = '|spxpagem'\n+            try:\n+                if type == 'single':\n+                    try:\n+                        p1, p2 = [escape(x) for x in split_into(2, 'single', string)]\n+                        P1, P2 = style(p1), style(p2)\n+                        self.body.append(r'\\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))\n+                    except ValueError:\n+                        p = escape(split_into(1, 'single', string)[0])\n+                        P = style(p)\n+                        self.body.append(r'\\index{%s@%s%s}' % (p, P, m))\n+                elif type == 'pair':\n+                    p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]\n+                    P1, P2 = style(p1), style(p2)\n+                    self.body.append(r'\\index{%s@%s!%s@%s%s}\\index{%s@%s!%s@%s%s}' %\n+                                     (p1, P1, p2, P2, m, p2, P2, p1, P1, m))\n+                elif type == 'triple':\n+                    p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]\n+                    P1, P2, P3 = style(p1), style(p2), style(p3)\n+                    self.body.append(\n+                        r'\\index{%s@%s!%s %s@%s %s%s}'\n+                        r'\\index{%s@%s!%s, %s@%s, %s%s}'\n+                        r'\\index{%s@%s!%s %s@%s %s%s}' %\n+                        (p1, P1, p2, p3, P2, P3, m,\n+                         p2, P2, p3, p1, P3, P1, m,\n+                         p3, P3, p1, p2, P1, P2, m))\n+                elif type == 'see':\n+                    p1, p2 = [escape(x) for x in split_into(2, 'see', string)]\n+                    P1 = style(p1)\n+                    self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n+                elif type == 'seealso':\n+                    p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]\n+                    P1 = style(p1)\n+                    self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n+                else:\n+                    logger.warning(__('unknown index entry type %s found'), type)\n+            except ValueError as err:\n+                logger.warning(str(err))\n+        if not node.get('inline', True):\n+            self.body.append(r'\\ignorespaces ')\n+        raise nodes.SkipNode\n+\n+    def visit_raw(self, node: Element) -> None:\n+        if not self.is_inline(node):\n+            self.body.append(CR)\n+        if 'latex' in node.get('format', '').split():\n+            self.body.append(node.astext())\n+        if not self.is_inline(node):\n+            self.body.append(CR)\n+        raise nodes.SkipNode\n+\n+    def visit_reference(self, node: Element) -> None:\n+        if not self.in_title:\n+            for id in node.get('ids'):\n+                anchor = not self.in_caption\n+                self.body += self.hypertarget(id, anchor=anchor)\n+        if not self.is_inline(node):\n+            self.body.append(CR)\n+        uri = node.get('refuri', '')\n+        if not uri and node.get('refid'):\n+            uri = '%' + self.curfilestack[-1] + '#' + node['refid']\n+        if self.in_title or not uri:\n+            self.context.append('')\n+        elif uri.startswith('#'):\n+            # references to labels in the same document\n+            id = self.curfilestack[-1] + ':' + uri[1:]\n+            self.body.append(self.hyperlink(id))\n+            self.body.append(r'\\emph{')\n+            if self.config.latex_show_pagerefs and not \\\n+                    self.in_production_list:\n+                self.context.append('}}} (%s)' % self.hyperpageref(id))\n+            else:\n+                self.context.append('}}}')\n+        elif uri.startswith('%'):\n+            # references to documents or labels inside documents\n+            hashindex = uri.find('#')\n+            if hashindex == -1:\n+                # reference to the document\n+                id = uri[1:] + '::doc'\n+            else:\n+                # reference to a label\n+                id = uri[1:].replace('#', ':')\n+            self.body.append(self.hyperlink(id))\n+            if (len(node) and\n+                    isinstance(node[0], nodes.Element) and\n+                    'std-term' in node[0].get('classes', [])):\n+                # don't add a pageref for glossary terms\n+                self.context.append('}}}')\n+                # mark up as termreference\n+                self.body.append(r'\\sphinxtermref{')\n+            else:\n+                self.body.append(r'\\sphinxcrossref{')\n+                if self.config.latex_show_pagerefs and not self.in_production_list:\n+                    self.context.append('}}} (%s)' % self.hyperpageref(id))\n+                else:\n+                    self.context.append('}}}')\n+        else:\n+            if len(node) == 1 and uri == node[0]:\n+                if node.get('nolinkurl'):\n+                    self.body.append(r'\\sphinxnolinkurl{%s}' % self.encode_uri(uri))\n+                else:\n+                    self.body.append(r'\\sphinxurl{%s}' % self.encode_uri(uri))\n+                raise nodes.SkipNode\n+            else:\n+                self.body.append(r'\\sphinxhref{%s}{' % self.encode_uri(uri))\n+                self.context.append('}')\n+\n+    def depart_reference(self, node: Element) -> None:\n+        self.body.append(self.context.pop())\n+        if not self.is_inline(node):\n+            self.body.append(CR)\n+\n+    def visit_number_reference(self, node: Element) -> None:\n+        if node.get('refid'):\n+            id = self.curfilestack[-1] + ':' + node['refid']\n+        else:\n+            id = node.get('refuri', '')[1:].replace('#', ':')\n+\n+        title = self.escape(node.get('title', '%s')).replace(r'\\%s', '%s')\n+        if r'\\{name\\}' in title or r'\\{number\\}' in title:\n+            # new style format (cf. \"Fig.%{number}\")\n+            title = title.replace(r'\\{name\\}', '{name}').replace(r'\\{number\\}', '{number}')\n+            text = escape_abbr(title).format(name=r'\\nameref{%s}' % self.idescape(id),\n+                                             number=r'\\ref{%s}' % self.idescape(id))\n+        else:\n+            # old style format (cf. \"Fig.%{number}\")\n+            text = escape_abbr(title) % (r'\\ref{%s}' % self.idescape(id))\n+        hyperref = r'\\hyperref[%s]{%s}' % (self.idescape(id), text)\n+        self.body.append(hyperref)\n+\n+        raise nodes.SkipNode\n+\n+    def visit_download_reference(self, node: Element) -> None:\n+        pass\n+\n+    def depart_download_reference(self, node: Element) -> None:\n+        pass\n+\n+    def visit_pending_xref(self, node: Element) -> None:\n+        pass\n+\n+    def depart_pending_xref(self, node: Element) -> None:\n+        pass\n+\n+    def visit_emphasis(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxstyleemphasis{')\n+\n+    def depart_emphasis(self, node: Element) -> None:\n+        self.body.append('}')\n+\n+    def visit_literal_emphasis(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxstyleliteralemphasis{\\sphinxupquote{')\n+\n+    def depart_literal_emphasis(self, node: Element) -> None:\n+        self.body.append('}}')\n+\n+    def visit_strong(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxstylestrong{')\n+\n+    def depart_strong(self, node: Element) -> None:\n+        self.body.append('}')\n+\n+    def visit_literal_strong(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxstyleliteralstrong{\\sphinxupquote{')\n+\n+    def depart_literal_strong(self, node: Element) -> None:\n+        self.body.append('}}')\n+\n+    def visit_abbreviation(self, node: Element) -> None:\n+        abbr = node.astext()\n+        self.body.append(r'\\sphinxstyleabbreviation{')\n+        # spell out the explanation once\n+        if node.hasattr('explanation') and abbr not in self.handled_abbrs:\n+            self.context.append('} (%s)' % self.encode(node['explanation']))\n+            self.handled_abbrs.add(abbr)\n+        else:\n+            self.context.append('}')\n+\n+    def depart_abbreviation(self, node: Element) -> None:\n+        self.body.append(self.context.pop())\n+\n+    def visit_manpage(self, node: Element) -> None:\n+        return self.visit_literal_emphasis(node)\n+\n+    def depart_manpage(self, node: Element) -> None:\n+        return self.depart_literal_emphasis(node)\n+\n+    def visit_title_reference(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxtitleref{')\n+\n+    def depart_title_reference(self, node: Element) -> None:\n+        self.body.append('}')\n+\n+    def visit_thebibliography(self, node: Element) -> None:\n+        citations = cast(Iterable[nodes.citation], node)\n+        labels = (cast(nodes.label, citation[0]) for citation in citations)\n+        longest_label = max((label.astext() for label in labels), key=len)\n+        if len(longest_label) > MAX_CITATION_LABEL_LENGTH:\n+            # adjust max width of citation labels not to break the layout\n+            longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]\n+\n+        self.body.append(CR + r'\\begin{sphinxthebibliography}{%s}' %\n+                         self.encode(longest_label) + CR)\n+\n+    def depart_thebibliography(self, node: Element) -> None:\n+        self.body.append(r'\\end{sphinxthebibliography}' + CR)\n+\n+    def visit_citation(self, node: Element) -> None:\n+        label = cast(nodes.label, node[0])\n+        self.body.append(r'\\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),\n+                                                   node['docname'], node['ids'][0]))\n+\n+    def depart_citation(self, node: Element) -> None:\n+        pass\n+\n+    def visit_citation_reference(self, node: Element) -> None:\n+        if self.in_title:\n+            pass\n+        else:\n+            self.body.append(r'\\sphinxcite{%s:%s}' % (node['docname'], node['refname']))\n+            raise nodes.SkipNode\n+\n+    def depart_citation_reference(self, node: Element) -> None:\n+        pass\n+\n+    def visit_literal(self, node: Element) -> None:\n+        if self.in_title:\n+            self.body.append(r'\\sphinxstyleliteralintitle{\\sphinxupquote{')\n+            return\n+        elif 'kbd' in node['classes']:\n+            self.body.append(r'\\sphinxkeyboard{\\sphinxupquote{')\n+            return\n+        lang = node.get(\"language\", None)\n+        if 'code' not in node['classes'] or not lang:\n+            self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+            return\n+\n+        opts = self.config.highlight_options.get(lang, {})\n+        hlcode = self.highlighter.highlight_block(\n+            node.astext(), lang, opts=opts, location=node)\n+        # TODO: Use nowrap option once LaTeX formatter supports it\n+        # https://github.com/pygments/pygments/pull/1343\n+        hlcode = hlcode.replace(r'\\begin{Verbatim}[commandchars=\\\\\\{\\}]',\n+                                r'\\sphinxcode{\\sphinxupquote{')\n+        # get consistent trailer\n+        hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n+        self.body.append(hlcode)\n+        self.body.append('}}')\n+        raise nodes.SkipNode\n+\n+    def depart_literal(self, node: Element) -> None:\n+        self.body.append('}}')\n+\n+    def visit_footnote_reference(self, node: Element) -> None:\n+        raise nodes.SkipNode\n+\n+    def visit_footnotemark(self, node: Element) -> None:\n+        self.body.append(r'\\sphinxfootnotemark[')\n+\n+    def depart_footnotemark(self, node: Element) -> None:\n+        self.body.append(']')\n+\n+    def visit_footnotetext(self, node: Element) -> None:\n+        label = cast(nodes.label, node[0])\n+        self.body.append('%' + CR)\n+        self.body.append(r'\\begin{footnotetext}[%s]' % label.astext())\n+        self.body.append(r'\\sphinxAtStartFootnote' + CR)\n+\n+    def depart_footnotetext(self, node: Element) -> None:\n+        # the \\ignorespaces in particular for after table header use\n+        self.body.append('%' + CR)\n+        self.body.append(r'\\end{footnotetext}\\ignorespaces ')\n+\n+    def visit_captioned_literal_block(self, node: Element) -> None:\n+        pass\n+\n+    def depart_captioned_literal_block(self, node: Element) -> None:\n+        pass\n+\n+    def visit_literal_block(self, node: Element) -> None:\n+        if node.rawsource != node.astext():\n+            # most probably a parsed-literal block -- don't highlight\n+            self.in_parsed_literal += 1\n+            self.body.append(r'\\begin{sphinxalltt}' + CR)\n+        else:\n+            labels = self.hypertarget_to(node)\n+            if isinstance(node.parent, captioned_literal_block):\n+                labels += self.hypertarget_to(node.parent)\n+            if labels and not self.in_footnote:\n+                self.body.append(CR + r'\\def\\sphinxLiteralBlockLabel{' + labels + '}')\n+\n+            lang = node.get('language', 'default')\n+            linenos = node.get('linenos', False)\n+            highlight_args = node.get('highlight_args', {})\n+            highlight_args['force'] = node.get('force', False)\n+            opts = self.config.highlight_options.get(lang, {})\n+\n+            hlcode = self.highlighter.highlight_block(\n+                node.rawsource, lang, opts=opts, linenos=linenos,\n+                location=node, **highlight_args\n+            )\n+            if self.in_footnote:\n+                self.body.append(CR + r'\\sphinxSetupCodeBlockInFootnote')\n+                hlcode = hlcode.replace(r'\\begin{Verbatim}',\n+                                        r'\\begin{sphinxVerbatim}')\n+            # if in table raise verbatim flag to avoid \"tabulary\" environment\n+            # and opt for sphinxVerbatimintable to handle caption & long lines\n+            elif self.table:\n+                self.table.has_problematic = True\n+                self.table.has_verbatim = True\n+                hlcode = hlcode.replace(r'\\begin{Verbatim}',\n+                                        r'\\begin{sphinxVerbatimintable}')\n+            else:\n+                hlcode = hlcode.replace(r'\\begin{Verbatim}',\n+                                        r'\\begin{sphinxVerbatim}')\n+            # get consistent trailer\n+            hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n+            if self.table and not self.in_footnote:\n+                hlcode += r'\\end{sphinxVerbatimintable}'\n+            else:\n+                hlcode += r'\\end{sphinxVerbatim}'\n+\n+            hllines = str(highlight_args.get('hl_lines', []))[1:-1]\n+            if hllines:\n+                self.body.append(CR + r'\\fvset{hllines={, %s,}}%%' % hllines)\n+            self.body.append(CR + hlcode + CR)\n+            if hllines:\n+                self.body.append(r'\\sphinxresetverbatimhllines' + CR)\n+            raise nodes.SkipNode\n+\n+    def depart_literal_block(self, node: Element) -> None:\n+        self.body.append(CR + r'\\end{sphinxalltt}' + CR)\n+        self.in_parsed_literal -= 1\n+    visit_doctest_block = visit_literal_block\n+    depart_doctest_block = depart_literal_block\n+\n+    def visit_line(self, node: Element) -> None:\n+        self.body.append(r'\\item[] ')\n+\n+    def depart_line(self, node: Element) -> None:\n+        self.body.append(CR)\n+\n+    def visit_line_block(self, node: Element) -> None:\n+        if isinstance(node.parent, nodes.line_block):\n+            self.body.append(r'\\item[]' + CR)\n+            self.body.append(r'\\begin{DUlineblock}{\\DUlineblockindent}' + CR)\n+        else:\n+            self.body.append(CR + r'\\begin{DUlineblock}{0em}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_line_block(self, node: Element) -> None:\n+        self.body.append(r'\\end{DUlineblock}' + CR)\n+\n+    def visit_block_quote(self, node: Element) -> None:\n+        # If the block quote contains a single object and that object\n+        # is a list, then generate a list not a block quote.\n+        # This lets us indent lists.\n+        done = 0\n+        if len(node.children) == 1:\n+            child = node.children[0]\n+            if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):\n+                done = 1\n+        if not done:\n+            self.body.append(r'\\begin{quote}' + CR)\n+            if self.table:\n+                self.table.has_problematic = True\n+\n+    def depart_block_quote(self, node: Element) -> None:\n+        done = 0\n+        if len(node.children) == 1:\n+            child = node.children[0]\n+            if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):\n+                done = 1\n+        if not done:\n+            self.body.append(r'\\end{quote}' + CR)\n+\n+    # option node handling copied from docutils' latex writer\n+\n+    def visit_option(self, node: Element) -> None:\n+        if self.context[-1]:\n+            # this is not the first option\n+            self.body.append(', ')\n+\n+    def depart_option(self, node: Element) -> None:\n+        # flag that the first option is done.\n+        self.context[-1] += 1\n+\n+    def visit_option_argument(self, node: Element) -> None:\n+        \"\"\"The delimiter between an option and its argument.\"\"\"\n+        self.body.append(node.get('delimiter', ' '))\n+\n+    def depart_option_argument(self, node: Element) -> None:\n+        pass\n+\n+    def visit_option_group(self, node: Element) -> None:\n+        self.body.append(r'\\item [')\n+        # flag for first option\n+        self.context.append(0)\n+\n+    def depart_option_group(self, node: Element) -> None:\n+        self.context.pop()  # the flag\n+        self.body.append('] ')\n+\n+    def visit_option_list(self, node: Element) -> None:\n+        self.body.append(r'\\begin{optionlist}{3cm}' + CR)\n+        if self.table:\n+            self.table.has_problematic = True\n+\n+    def depart_option_list(self, node: Element) -> None:\n+        self.body.append(r'\\end{optionlist}' + CR)\n+\n+    def visit_option_list_item(self, node: Element) -> None:\n+        pass\n+\n+    def depart_option_list_item(self, node: Element) -> None:\n+        pass\n+\n+    def visit_option_string(self, node: Element) -> None:\n+        ostring = node.astext()\n+        self.body.append(self.encode(ostring))\n+        raise nodes.SkipNode\n+\n+    def visit_description(self, node: Element) -> None:\n+        self.body.append(' ')\n+\n+    def depart_description(self, node: Element) -> None:\n+        pass\n+\n+    def visit_superscript(self, node: Element) -> None:\n+        self.body.append(r'$^{\\text{')\n+\n+    def depart_superscript(self, node: Element) -> None:\n+        self.body.append('}}$')\n+\n+    def visit_subscript(self, node: Element) -> None:\n+        self.body.append(r'$_{\\text{')\n+\n+    def depart_subscript(self, node: Element) -> None:\n+        self.body.append('}}$')\n+\n+    def visit_inline(self, node: Element) -> None:\n+        classes = node.get('classes', [])\n+        if classes in [['menuselection']]:\n+            self.body.append(r'\\sphinxmenuselection{')\n+            self.context.append('}')\n+        elif classes in [['guilabel']]:\n+            self.body.append(r'\\sphinxguilabel{')\n+            self.context.append('}')\n+        elif classes in [['accelerator']]:\n+            self.body.append(r'\\sphinxaccelerator{')\n+            self.context.append('}')\n+        elif classes and not self.in_title:\n+            self.body.append(r'\\DUrole{%s}{' % ','.join(classes))\n+            self.context.append('}')\n+        else:\n+            self.context.append('')\n+\n+    def depart_inline(self, node: Element) -> None:\n+        self.body.append(self.context.pop())\n+\n+    def visit_generated(self, node: Element) -> None:\n+        pass\n+\n+    def depart_generated(self, node: Element) -> None:\n+        pass\n+\n+    def visit_compound(self, node: Element) -> None:\n+        pass\n+\n+    def depart_compound(self, node: Element) -> None:\n+        pass\n+\n+    def visit_container(self, node: Element) -> None:\n+        classes = node.get('classes', [])\n+        for c in classes:\n+            self.body.append('\\n\\\\begin{sphinxuseclass}{%s}' % c)\n+\n+    def depart_container(self, node: Element) -> None:\n+        classes = node.get('classes', [])\n+        for _c in classes:\n+            self.body.append('\\n\\\\end{sphinxuseclass}')\n+\n+    def visit_decoration(self, node: Element) -> None:\n+        pass\n+\n+    def depart_decoration(self, node: Element) -> None:\n+        pass\n+\n+    # docutils-generated elements that we don't support\n+\n+    def visit_header(self, node: Element) -> None:\n+        raise nodes.SkipNode\n+\n+    def visit_footer(self, node: Element) -> None:\n+        raise nodes.SkipNode\n+\n+    def visit_docinfo(self, node: Element) -> None:\n+        raise nodes.SkipNode\n+\n+    # text handling\n+\n+    def encode(self, text: str) -> str:\n+        text = self.escape(text)\n+        if self.literal_whitespace:\n+            # Insert a blank before the newline, to avoid\n+            # ! LaTeX Error: There's no line here to end.\n+            text = text.replace(CR, r'~\\\\' + CR).replace(' ', '~')\n+        return text\n+\n+    def encode_uri(self, text: str) -> str:\n+        # TODO: it is probably wrong that this uses texescape.escape()\n+        #       this must be checked against hyperref package exact dealings\n+        #       mainly, %, #, {, } and \\ need escaping via a \\ escape\n+        # in \\href, the tilde is allowed and must be represented literally\n+        return self.encode(text).replace(r'\\textasciitilde{}', '~').\\\n+            replace(r'\\sphinxhyphen{}', '-').\\\n+            replace(r'\\textquotesingle{}', \"'\")\n+\n+    def visit_Text(self, node: Text) -> None:\n+        text = self.encode(node.astext())\n+        self.body.append(text)\n+\n+    def depart_Text(self, node: Text) -> None:\n+        pass\n+\n+    def visit_comment(self, node: Element) -> None:\n+        raise nodes.SkipNode\n+\n+    def visit_meta(self, node: Element) -> None:\n+        # only valid for HTML\n+        raise nodes.SkipNode\n+\n+    def visit_system_message(self, node: Element) -> None:\n+        pass\n+\n+    def depart_system_message(self, node: Element) -> None:\n+        self.body.append(CR)\n+\n+    def visit_math(self, node: Element) -> None:\n+        if self.in_title:\n+            self.body.append(r'\\protect\\(%s\\protect\\)' % node.astext())\n+        else:\n+            self.body.append(r'\\(%s\\)' % node.astext())\n+        raise nodes.SkipNode\n+\n+    def visit_math_block(self, node: Element) -> None:\n+        if node.get('label'):\n+            label = \"equation:%s:%s\" % (node['docname'], node['label'])\n+        else:\n+            label = None\n+\n+        if node.get('nowrap'):\n+            if label:\n+                self.body.append(r'\\label{%s}' % label)\n+            self.body.append(node.astext())\n+        else:\n+            from sphinx.util.math import wrap_displaymath\n+            self.body.append(wrap_displaymath(node.astext(), label,\n+                                              self.config.math_number_all))\n+        raise nodes.SkipNode\n+\n+    def visit_math_reference(self, node: Element) -> None:\n+        label = \"equation:%s:%s\" % (node['docname'], node['target'])\n+        eqref_format = self.config.math_eqref_format\n+        if eqref_format:\n+            try:\n+                ref = r'\\ref{%s}' % label\n+                self.body.append(eqref_format.format(number=ref))\n+            except KeyError as exc:\n+                logger.warning(__('Invalid math_eqref_format: %r'), exc,\n+                               location=node)\n+                self.body.append(r'\\eqref{%s}' % label)\n+        else:\n+            self.body.append(r'\\eqref{%s}' % label)\n+\n+    def depart_math_reference(self, node: Element) -> None:\n+        pass\n+\n+    @property\n+    def docclasses(self) -> Tuple[str, str]:\n+        \"\"\"Prepends prefix to sphinx document classes\"\"\"\n+        warnings.warn('LaTeXWriter.docclasses() is deprecated.',\n+                      RemovedInSphinx70Warning, stacklevel=2)\n+        return ('howto', 'manual')\n+\n+\n+# FIXME: Workaround to avoid circular import\n+# refs: https://github.com/sphinx-doc/sphinx/issues/5433\n+from sphinx.builders.latex.nodes import ( # NOQA isort:skip\n+    HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,\n+)\n\n"
  },
  "sphinx-doc__sphinx-10466": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10466",
    "model_patch": "diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py\nindex e8bc547b7..7b368b9a7 100644\n--- a/sphinx/builders/gettext.py\n+++ b/sphinx/builders/gettext.py\n@@ -29,11 +29,21 @@ logger = logging.getLogger(__name__)\n \n \n class Message:\n-    \"\"\"An entry of translatable message.\"\"\"\n+    '''An entry of translatable message.'''\n     def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n         self.text = text\n-        self.locations = locations\n-        self.uuids = uuids\n+        seen = set()\n+        unique_locations = []\n+        unique_uuids = []\n+        for idx, (src, line) in enumerate(locations):\n+            key = (src, line)\n+            if key in seen:\n+                continue\n+            seen.add(key)\n+            unique_locations.append((src, line))\n+            unique_uuids.append(uuids[idx] if idx < len(uuids) else '')\n+        self.locations = unique_locations\n+        self.uuids = unique_uuids\n \n \n class Catalog:\n@@ -293,4 +303,20 @@ def setup(app: Sphinx) -> Dict[str, Any]:\n         'version': 'builtin',\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n-    }\n+class Message:\n+    '''An entry of translatable message.'''\n+    def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n+        self.text = text\n+        seen = set()\n+        unique_locations = []\n+        unique_uuids = []\n+        for idx, (src, line) in enumerate(locations):\n+            key = (src, line)\n+            if key in seen:\n+                continue\n+            seen.add(key)\n+            unique_locations.append((src, line))\n+            unique_uuids.append(uuids[idx] if idx < len(uuids) else '')\n+        self.locations = unique_locations\n+        self.uuids = unique_uuids\n+\n\n"
  },
  "sphinx-doc__sphinx-10673": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10673",
    "model_patch": "diff --git a/docs_index.rst b/docs_index.rst\nnew file mode 100644\nindex 000000000..a4f7c8394\n--- /dev/null\n+++ b/docs_index.rst\n@@ -0,0 +1,37 @@\n+    .. toctree::\n+       :maxdepth: 1\n+       :caption: Indices and tables\n+\n+       genindex\n+       modindex\n+       search\n+    EOF\n+    python - <<'PY'\n+import logging, sys\n+logging.basicConfig(stream=sys.stdout, level=logging.INFO)\n+from sphinx.environment.adapters.toctree import TocTree\n+from sphinx.environment import BuildEnvironment\n+from sphinx.builders.html import StandaloneHTMLBuilder\n+from types import SimpleNamespace\n+# build minimal fake env\n+srcdir='.'\n+env=BuildEnvironment(srcdir, {})\n+env.config=SimpleNamespace(include_patterns=['**'], exclude_patterns=[])\n+# create a fake toctreenode\n+from docutils import nodes\n+from sphinx.addnodes import toctree as toctree_node\n+tn=toctree_node()\n+tn['includefiles']=['genindex','modindex','search']\n+tn['glob']=False\n+tn['numbered']=False\n+tn['hidden']=False\n+tt=TocTree(env)\n+# call note to populate mappings\n+try:\n+    tt.note('index', tn)\n+    print('note ok')\n+except Exception as e:\n+    print('note failed', e)\n+print('Patched file head:')\n+print(open('sphinx/environment/adapters/toctree.py').read().splitlines()[150:180])\n+PY\ndiff --git a/sphinx/environment/adapters/toctree.py b/sphinx/environment/adapters/toctree.py\nindex 9678e3c7c..fc757dea1 100644\n--- a/sphinx/environment/adapters/toctree.py\n+++ b/sphinx/environment/adapters/toctree.py\n@@ -165,6 +165,8 @@ class TocTree:\n                                        ref, location=toctreenode)\n                 except KeyError:\n                     # this is raised if the included file does not exist\n+                    if ref in ('genindex', 'modindex', 'search'):\n+                        continue\n                     if excluded(self.env.doc2path(ref, False)):\n                         message = __('toctree contains reference to excluded document %r')\n                     elif not included(self.env.doc2path(ref, False)):\ndiff --git a/sphinx/environment/adapters/toctree.py.bak b/sphinx/environment/adapters/toctree.py.bak\nnew file mode 100644\nindex 000000000..9678e3c7c\n--- /dev/null\n+++ b/sphinx/environment/adapters/toctree.py.bak\n@@ -0,0 +1,331 @@\n+\"\"\"Toctree adapter for sphinx.environment.\"\"\"\n+\n+from typing import TYPE_CHECKING, Any, Iterable, List, Optional, cast\n+\n+from docutils import nodes\n+from docutils.nodes import Element, Node\n+\n+from sphinx import addnodes\n+from sphinx.locale import __\n+from sphinx.util import logging, url_re\n+from sphinx.util.matching import Matcher\n+from sphinx.util.nodes import clean_astext, process_only_nodes\n+\n+if TYPE_CHECKING:\n+    from sphinx.builders import Builder\n+    from sphinx.environment import BuildEnvironment\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class TocTree:\n+    def __init__(self, env: \"BuildEnvironment\") -> None:\n+        self.env = env\n+\n+    def note(self, docname: str, toctreenode: addnodes.toctree) -> None:\n+        \"\"\"Note a TOC tree directive in a document and gather information about\n+        file relations from it.\n+        \"\"\"\n+        if toctreenode['glob']:\n+            self.env.glob_toctrees.add(docname)\n+        if toctreenode.get('numbered'):\n+            self.env.numbered_toctrees.add(docname)\n+        includefiles = toctreenode['includefiles']\n+        for includefile in includefiles:\n+            # note that if the included file is rebuilt, this one must be\n+            # too (since the TOC of the included file could have changed)\n+            self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)\n+        self.env.toctree_includes.setdefault(docname, []).extend(includefiles)\n+\n+    def resolve(self, docname: str, builder: \"Builder\", toctree: addnodes.toctree,\n+                prune: bool = True, maxdepth: int = 0, titles_only: bool = False,\n+                collapse: bool = False, includehidden: bool = False) -> Optional[Element]:\n+        \"\"\"Resolve a *toctree* node into individual bullet lists with titles\n+        as items, returning None (if no containing titles are found) or\n+        a new node.\n+\n+        If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,\n+        to the value of the *maxdepth* option on the *toctree* node.\n+        If *titles_only* is True, only toplevel document titles will be in the\n+        resulting tree.\n+        If *collapse* is True, all branches not containing docname will\n+        be collapsed.\n+        \"\"\"\n+        if toctree.get('hidden', False) and not includehidden:\n+            return None\n+\n+        # For reading the following two helper function, it is useful to keep\n+        # in mind the node structure of a toctree (using HTML-like node names\n+        # for brevity):\n+        #\n+        # <ul>\n+        #   <li>\n+        #     <p><a></p>\n+        #     <p><a></p>\n+        #     ...\n+        #     <ul>\n+        #       ...\n+        #     </ul>\n+        #   </li>\n+        # </ul>\n+        #\n+        # The transformation is made in two passes in order to avoid\n+        # interactions between marking and pruning the tree (see bug #1046).\n+\n+        toctree_ancestors = self.get_toctree_ancestors(docname)\n+        included = Matcher(self.env.config.include_patterns)\n+        excluded = Matcher(self.env.config.exclude_patterns)\n+\n+        def _toctree_add_classes(node: Element, depth: int) -> None:\n+            \"\"\"Add 'toctree-l%d' and 'current' classes to the toctree.\"\"\"\n+            for subnode in node.children:\n+                if isinstance(subnode, (addnodes.compact_paragraph,\n+                                        nodes.list_item)):\n+                    # for <p> and <li>, indicate the depth level and recurse\n+                    subnode['classes'].append('toctree-l%d' % (depth - 1))\n+                    _toctree_add_classes(subnode, depth)\n+                elif isinstance(subnode, nodes.bullet_list):\n+                    # for <ul>, just recurse\n+                    _toctree_add_classes(subnode, depth + 1)\n+                elif isinstance(subnode, nodes.reference):\n+                    # for <a>, identify which entries point to the current\n+                    # document and therefore may not be collapsed\n+                    if subnode['refuri'] == docname:\n+                        if not subnode['anchorname']:\n+                            # give the whole branch a 'current' class\n+                            # (useful for styling it differently)\n+                            branchnode: Element = subnode\n+                            while branchnode:\n+                                branchnode['classes'].append('current')\n+                                branchnode = branchnode.parent\n+                        # mark the list_item as \"on current page\"\n+                        if subnode.parent.parent.get('iscurrent'):\n+                            # but only if it's not already done\n+                            return\n+                        while subnode:\n+                            subnode['iscurrent'] = True\n+                            subnode = subnode.parent\n+\n+        def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],\n+                                  separate: bool = False, subtree: bool = False\n+                                  ) -> List[Element]:\n+            \"\"\"Return TOC entries for a toctree node.\"\"\"\n+            refs = [(e[0], e[1]) for e in toctreenode['entries']]\n+            entries: List[Element] = []\n+            for (title, ref) in refs:\n+                try:\n+                    refdoc = None\n+                    if url_re.match(ref):\n+                        if title is None:\n+                            title = ref\n+                        reference = nodes.reference('', '', internal=False,\n+                                                    refuri=ref, anchorname='',\n+                                                    *[nodes.Text(title)])\n+                        para = addnodes.compact_paragraph('', '', reference)\n+                        item = nodes.list_item('', para)\n+                        toc = nodes.bullet_list('', item)\n+                    elif ref == 'self':\n+                        # 'self' refers to the document from which this\n+                        # toctree originates\n+                        ref = toctreenode['parent']\n+                        if not title:\n+                            title = clean_astext(self.env.titles[ref])\n+                        reference = nodes.reference('', '', internal=True,\n+                                                    refuri=ref,\n+                                                    anchorname='',\n+                                                    *[nodes.Text(title)])\n+                        para = addnodes.compact_paragraph('', '', reference)\n+                        item = nodes.list_item('', para)\n+                        # don't show subitems\n+                        toc = nodes.bullet_list('', item)\n+                    else:\n+                        if ref in parents:\n+                            logger.warning(__('circular toctree references '\n+                                              'detected, ignoring: %s <- %s'),\n+                                           ref, ' <- '.join(parents),\n+                                           location=ref, type='toc', subtype='circular')\n+                            continue\n+                        refdoc = ref\n+                        toc = self.env.tocs[ref].deepcopy()\n+                        maxdepth = self.env.metadata[ref].get('tocdepth', 0)\n+                        if ref not in toctree_ancestors or (prune and maxdepth > 0):\n+                            self._toctree_prune(toc, 2, maxdepth, collapse)\n+                        process_only_nodes(toc, builder.tags)\n+                        if title and toc.children and len(toc.children) == 1:\n+                            child = toc.children[0]\n+                            for refnode in child.findall(nodes.reference):\n+                                if refnode['refuri'] == ref and \\\n+                                   not refnode['anchorname']:\n+                                    refnode.children = [nodes.Text(title)]\n+                    if not toc.children:\n+                        # empty toc means: no titles will show up in the toctree\n+                        logger.warning(__('toctree contains reference to document %r that '\n+                                          'doesn\\'t have a title: no link will be generated'),\n+                                       ref, location=toctreenode)\n+                except KeyError:\n+                    # this is raised if the included file does not exist\n+                    if excluded(self.env.doc2path(ref, False)):\n+                        message = __('toctree contains reference to excluded document %r')\n+                    elif not included(self.env.doc2path(ref, False)):\n+                        message = __('toctree contains reference to non-included document %r')\n+                    else:\n+                        message = __('toctree contains reference to nonexisting document %r')\n+\n+                    logger.warning(message, ref, location=toctreenode)\n+                else:\n+                    # if titles_only is given, only keep the main title and\n+                    # sub-toctrees\n+                    if titles_only:\n+                        # children of toc are:\n+                        # - list_item + compact_paragraph + (reference and subtoc)\n+                        # - only + subtoc\n+                        # - toctree\n+                        children = cast(Iterable[nodes.Element], toc)\n+\n+                        # delete everything but the toplevel title(s)\n+                        # and toctrees\n+                        for toplevel in children:\n+                            # nodes with length 1 don't have any children anyway\n+                            if len(toplevel) > 1:\n+                                subtrees = list(toplevel.findall(addnodes.toctree))\n+                                if subtrees:\n+                                    toplevel[1][:] = subtrees  # type: ignore\n+                                else:\n+                                    toplevel.pop(1)\n+                    # resolve all sub-toctrees\n+                    for subtocnode in list(toc.findall(addnodes.toctree)):\n+                        if not (subtocnode.get('hidden', False) and\n+                                not includehidden):\n+                            i = subtocnode.parent.index(subtocnode) + 1\n+                            for entry in _entries_from_toctree(\n+                                    subtocnode, [refdoc] + parents,\n+                                    subtree=True):\n+                                subtocnode.parent.insert(i, entry)\n+                                i += 1\n+                            subtocnode.parent.remove(subtocnode)\n+                    if separate:\n+                        entries.append(toc)\n+                    else:\n+                        children = cast(Iterable[nodes.Element], toc)\n+                        entries.extend(children)\n+            if not subtree and not separate:\n+                ret = nodes.bullet_list()\n+                ret += entries\n+                return [ret]\n+            return entries\n+\n+        maxdepth = maxdepth or toctree.get('maxdepth', -1)\n+        if not titles_only and toctree.get('titlesonly', False):\n+            titles_only = True\n+        if not includehidden and toctree.get('includehidden', False):\n+            includehidden = True\n+\n+        # NOTE: previously, this was separate=True, but that leads to artificial\n+        # separation when two or more toctree entries form a logical unit, so\n+        # separating mode is no longer used -- it's kept here for history's sake\n+        tocentries = _entries_from_toctree(toctree, [], separate=False)\n+        if not tocentries:\n+            return None\n+\n+        newnode = addnodes.compact_paragraph('', '')\n+        caption = toctree.attributes.get('caption')\n+        if caption:\n+            caption_node = nodes.title(caption, '', *[nodes.Text(caption)])\n+            caption_node.line = toctree.line\n+            caption_node.source = toctree.source\n+            caption_node.rawsource = toctree['rawcaption']\n+            if hasattr(toctree, 'uid'):\n+                # move uid to caption_node to translate it\n+                caption_node.uid = toctree.uid  # type: ignore\n+                del toctree.uid  # type: ignore\n+            newnode += caption_node\n+        newnode.extend(tocentries)\n+        newnode['toctree'] = True\n+\n+        # prune the tree to maxdepth, also set toc depth and current classes\n+        _toctree_add_classes(newnode, 1)\n+        self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)\n+\n+        if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found\n+            return None\n+\n+        # set the target paths in the toctrees (they are not known at TOC\n+        # generation time)\n+        for refnode in newnode.findall(nodes.reference):\n+            if not url_re.match(refnode['refuri']):\n+                refnode['refuri'] = builder.get_relative_uri(\n+                    docname, refnode['refuri']) + refnode['anchorname']\n+        return newnode\n+\n+    def get_toctree_ancestors(self, docname: str) -> List[str]:\n+        parent = {}\n+        for p, children in self.env.toctree_includes.items():\n+            for child in children:\n+                parent[child] = p\n+        ancestors: List[str] = []\n+        d = docname\n+        while d in parent and d not in ancestors:\n+            ancestors.append(d)\n+            d = parent[d]\n+        return ancestors\n+\n+    def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False\n+                       ) -> None:\n+        \"\"\"Utility: Cut a TOC at a specified depth.\"\"\"\n+        for subnode in node.children[:]:\n+            if isinstance(subnode, (addnodes.compact_paragraph,\n+                                    nodes.list_item)):\n+                # for <p> and <li>, just recurse\n+                self._toctree_prune(subnode, depth, maxdepth, collapse)\n+            elif isinstance(subnode, nodes.bullet_list):\n+                # for <ul>, determine if the depth is too large or if the\n+                # entry is to be collapsed\n+                if maxdepth > 0 and depth > maxdepth:\n+                    subnode.parent.replace(subnode, [])\n+                else:\n+                    # cull sub-entries whose parents aren't 'current'\n+                    if (collapse and depth > 1 and\n+                            'iscurrent' not in subnode.parent):\n+                        subnode.parent.remove(subnode)\n+                    else:\n+                        # recurse on visible children\n+                        self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)\n+\n+    def get_toc_for(self, docname: str, builder: \"Builder\") -> Node:\n+        \"\"\"Return a TOC nodetree -- for use on the same page only!\"\"\"\n+        tocdepth = self.env.metadata[docname].get('tocdepth', 0)\n+        try:\n+            toc = self.env.tocs[docname].deepcopy()\n+            self._toctree_prune(toc, 2, tocdepth)\n+        except KeyError:\n+            # the document does not exist anymore: return a dummy node that\n+            # renders to nothing\n+            return nodes.paragraph()\n+        process_only_nodes(toc, builder.tags)\n+        for node in toc.findall(nodes.reference):\n+            node['refuri'] = node['anchorname'] or '#'\n+        return toc\n+\n+    def get_toctree_for(self, docname: str, builder: \"Builder\", collapse: bool,\n+                        **kwargs: Any) -> Optional[Element]:\n+        \"\"\"Return the global TOC nodetree.\"\"\"\n+        doctree = self.env.get_doctree(self.env.config.root_doc)\n+        toctrees: List[Element] = []\n+        if 'includehidden' not in kwargs:\n+            kwargs['includehidden'] = True\n+        if 'maxdepth' not in kwargs or not kwargs['maxdepth']:\n+            kwargs['maxdepth'] = 0\n+        else:\n+            kwargs['maxdepth'] = int(kwargs['maxdepth'])\n+        kwargs['collapse'] = collapse\n+        for toctreenode in doctree.findall(addnodes.toctree):\n+            toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)\n+            if toctree:\n+                toctrees.append(toctree)\n+        if not toctrees:\n+            return None\n+        result = toctrees[0]\n+        for toctree in toctrees[1:]:\n+            result.extend(toctree.children)\n+        return result\n\n"
  },
  "sphinx-doc__sphinx-11510": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-11510",
    "model_patch": "diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py\nindex 8de166137..53380079e 100644\n--- a/sphinx/directives/code.py\n+++ b/sphinx/directives/code.py\n@@ -236,6 +236,20 @@ class LiteralIncludeReader:\n                        self.prepend_filter,\n                        self.append_filter]\n             lines = self.read_file(self.filename, location=location)\n+            try:\n+                # allow extensions to transform included file contents via source-read\n+                env = getattr(self, 'env', None)\n+                if env is None and hasattr(self, 'config') and hasattr(self.config, 'sphinx_env'):\n+                    env = getattr(self.config, 'sphinx_env', None)\n+                if env is not None:\n+                    arg = [''.join(lines)]\n+                    try:\n+                        env.events.emit('source-read', getattr(env, 'docname', self.filename), arg)\n+                        lines = arg[0].splitlines(True)\n+                    except Exception:\n+                        pass\n+            except Exception:\n+                pass\n             for func in filters:\n                 lines = func(lines, location=location)\n \n\n"
  },
  "sphinx-doc__sphinx-7590": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7590",
    "model_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..589c60212 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -4602,6 +4602,13 @@ class Symbol:\n         return ''.join(res)\n \n \n+user_defined_literal_re = re.compile(r'[0-9]+(?:\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?[A-Za-z_][A-Za-z_0-9]*')\n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, text):\n+        self.text = text\n+    def __str__(self):\n+        return self.text\n+\n class DefinitionParser(BaseParser):\n     # those without signedness and size modifiers\n     # see https://en.cppreference.com/w/cpp/language/types\n@@ -4682,7 +4689,15 @@ class DefinitionParser(BaseParser):\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+                # user-defined literal (e.g. 1q_m, 3.14e3q_J)\n+        pos = self.pos\n+        if self.match(user_defined_literal_re):\n+            return ASTUserDefinedLiteral(self.definition[pos:self.pos])\n+        save = self.pos\n+        if self.match(char_literal_re):\n+            if self.match(re.compile(r'[A-Za-z_][A-Za-z_0-9]*')):\n+                return ASTUserDefinedLiteral(self.definition[pos:self.pos])\n+            self.pos = save\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n\n"
  },
  "sphinx-doc__sphinx-7748": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7748",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..b061859c0 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1064,9 +1064,13 @@ class DocstringSignatureMixin:\n                 continue\n             # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n+                j = 1\n+                while j < len(doclines) and py_ext_sig_re.match(doclines[j]):\n+                    j += 1\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j:]),\n+                                                            tabsize=tab_width)\n+\n+result = args, retann\n             # don't look any further\n             break\n         return result\n\nbash execution output:\n   1058\t            valid_names = [self.objpath[-1]]  # type: ignore\n  1059\t            if isinstance(self, ClassDocumenter):\n  1060\t                valid_names.append('__init__')\n  1061\t                if hasattr(self.object, '__mro__'):\n  1062\t                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n  1063\t            if base not in valid_names:\n  1064\t                continue\n  1065\t            # re-prepare docstring to ignore more leading indentation\n  1066\t            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n  1067\t                j = 1\n  1068\t                while j < len(doclines) and py_ext_sig_re.match(doclines[j]):\n  1069\t                    j += 1\n  1070\t                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j:]),\n  1071\t                                                            tabsize=tab_width)\n  1072\t\n  1073\tresult = args, retann\n  1074\t            # don't look any further\n  1075\t            break\n  1076\t        return result\n  1077\t\n  1078\t    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n\nDirectly response 'submit()' to finish, no other tokens.\nbash execution output:\n ERROR: found no collectors for /testbed/tests/test_ext_autodoc_configs.py::test_autodoc_docstring_signature\n\n\n==================================== ERRORS ====================================\n______________ ERROR collecting tests/test_ext_autodoc_configs.py ______________\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/python.py:493: in importtestmodule\n    mod = import_path(\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/pathlib.py:582: in import_path\n    importlib.import_module(module_name)\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1030: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1007: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:986: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:680: in _load_unlocked\n    ???\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/assertion/rewrite.py:184: in exec_module\n    exec(co, module.__dict__)\ntests/test_ext_autodoc_configs.py:16: in <module>\n    from test_ext_autodoc import do_autodoc\n<frozen importlib._bootstrap>:1007: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:986: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:680: in _load_unlocked\n    ???\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/assertion/rewrite.py:184: in exec_module\n    exec(co, module.__dict__)\ntests/test_ext_autodoc.py:20: in <module>\n    from sphinx.ext.autodoc import ModuleLevelDocumenter, ALL, Options\nE     File \"/testbed/sphinx/ext/autodoc/__init__.py\", line 1067\nE       j = 1\nE   IndentationError: unexpected indent\n=============================== warnings summary ===============================\nsphinx/util/docutils.py:45\n  /testbed/sphinx/util/docutils.py:45: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.\n    __version_info__ = tuple(LooseVersion(docutils.__version__).version)\n\nsphinx/registry.py:22\n  /testbed/sphinx/registry.py:22: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html\n    from pkg_resources import iter_entry_points\n\n../opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:3154\n../opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:3154\n../opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:3154\n../opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:3154\n  /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:3154: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('sphinxcontrib')`.\n  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n    declare_namespace(pkg)\n\nsphinx/directives/patches.py:15\n  /testbed/sphinx/directives/patches.py:15: DeprecationWarning: The `docutils.parsers.rst.directive.html` module will be removed in Docutils 2.0. Since Docutils 0.18, the \"Meta\" node is defined in `docutils.parsers.rst.directives.misc`.\n    from docutils.parsers.rst.directives import images, html, tables\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ============================\nERROR tests/test_ext_autodoc_configs.py\n\nCommand exited with non-zero status: 4\nDirectly response 'submit()' to finish, no other tokens.\n"
  },
  "sphinx-doc__sphinx-7757": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7757",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 15f0d66e2..838667669 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -71,6 +71,8 @@ def getargspec(func: Callable) -> Any:\n     sig = inspect.signature(func)\n \n     args = []\n+    _NO_DEFAULT = object()\n+    _pos_defaults = []\n     varargs = None\n     varkw = None\n     kwonlyargs = []\n@@ -88,10 +90,16 @@ def getargspec(func: Callable) -> Any:\n \n         if kind is Parameter.POSITIONAL_ONLY:\n             args.append(name)\n+            if param.default is not param.empty:\n+                _pos_defaults.append(param.default)\n+            else:\n+                _pos_defaults.append(_NO_DEFAULT)\n         elif kind is Parameter.POSITIONAL_OR_KEYWORD:\n             args.append(name)\n             if param.default is not param.empty:\n-                defaults += (param.default,)  # type: ignore\n+                _pos_defaults.append(param.default)\n+            else:\n+                _pos_defaults.append(_NO_DEFAULT)\n         elif kind is Parameter.VAR_POSITIONAL:\n             varargs = name\n         elif kind is Parameter.KEYWORD_ONLY:\n@@ -104,6 +112,17 @@ def getargspec(func: Callable) -> Any:\n         if param.annotation is not param.empty:\n             annotations[name] = param.annotation\n \n+    # build defaults tuple from trailing positional defaults only\n+    n = 0\n+    for val in reversed(_pos_defaults):\n+        if val is _NO_DEFAULT:\n+            break\n+        n += 1\n+    if n:\n+        defaults = tuple(_pos_defaults[len(_pos_defaults)-n:])\n+    else:\n+        defaults = None\n+\n     if not kwdefaults:\n         # compatibility with 'func.__kwdefaults__'\n         kwdefaults = None\ndiff --git a/sphinx/util/inspect.py.bak b/sphinx/util/inspect.py.bak\nnew file mode 100644\nindex 000000000..0a096d4a4\n--- /dev/null\n+++ b/sphinx/util/inspect.py.bak\n@@ -0,0 +1,740 @@\n+\"\"\"\n+    sphinx.util.inspect\n+    ~~~~~~~~~~~~~~~~~~~\n+\n+    Helpers for inspecting Python modules.\n+\n+    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import builtins\n+import enum\n+import inspect\n+import re\n+import sys\n+import typing\n+import warnings\n+from functools import partial, partialmethod\n+from inspect import (  # NOQA\n+    Parameter, isclass, ismethod, ismethoddescriptor\n+)\n+from io import StringIO\n+from typing import Any, Callable, Mapping, List, Optional, Tuple\n+from typing import cast\n+\n+from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n+from sphinx.pycode.ast import ast  # for py35-37\n+from sphinx.pycode.ast import unparse as ast_unparse\n+from sphinx.util import logging\n+from sphinx.util.typing import stringify as stringify_annotation\n+\n+if sys.version_info > (3, 7):\n+    from types import (\n+        ClassMethodDescriptorType,\n+        MethodDescriptorType,\n+        WrapperDescriptorType\n+    )\n+else:\n+    ClassMethodDescriptorType = type(object.__init__)\n+    MethodDescriptorType = type(str.join)\n+    WrapperDescriptorType = type(dict.__dict__['fromkeys'])\n+\n+logger = logging.getLogger(__name__)\n+\n+memory_address_re = re.compile(r' at 0x[0-9a-f]{8,16}(?=>)', re.IGNORECASE)\n+\n+\n+# Copied from the definition of inspect.getfullargspec from Python master,\n+# and modified to remove the use of special flags that break decorated\n+# callables and bound methods in the name of backwards compatibility. Used\n+# under the terms of PSF license v2, which requires the above statement\n+# and the following:\n+#\n+#   Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+#   2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017 Python Software\n+#   Foundation; All Rights Reserved\n+def getargspec(func: Callable) -> Any:\n+    \"\"\"Like inspect.getfullargspec but supports bound methods, and wrapped\n+    methods.\"\"\"\n+    warnings.warn('sphinx.ext.inspect.getargspec() is deprecated',\n+                  RemovedInSphinx50Warning, stacklevel=2)\n+    # On 3.5+, signature(int) or similar raises ValueError. On 3.4, it\n+    # succeeds with a bogus signature. We want a TypeError uniformly, to\n+    # match historical behavior.\n+    if (isinstance(func, type) and\n+            is_builtin_class_method(func, \"__new__\") and\n+            is_builtin_class_method(func, \"__init__\")):\n+        raise TypeError(\n+            \"can't compute signature for built-in type {}\".format(func))\n+\n+    sig = inspect.signature(func)\n+\n+    args = []\n+    varargs = None\n+    varkw = None\n+    kwonlyargs = []\n+    defaults = ()\n+    annotations = {}\n+    defaults = ()\n+    kwdefaults = {}\n+\n+    if sig.return_annotation is not sig.empty:\n+        annotations['return'] = sig.return_annotation\n+\n+    for param in sig.parameters.values():\n+        kind = param.kind\n+        name = param.name\n+\n+        if kind is Parameter.POSITIONAL_ONLY:\n+            args.append(name)\n+            if param.default is not param.empty:\n+                defaults += (param.default,)  # type: ignore\n+            if param.default is not param.empty:\n+                defaults += (param.default,)  # type: ignore\n+            if param.default is not param.empty:\n+                defaults += (param.default,)  # type: ignore\n+        elif kind is Parameter.POSITIONAL_OR_KEYWORD:\n+            args.append(name)\n+            if param.default is not param.empty:\n+                defaults += (param.default,)  # type: ignore\n+        elif kind is Parameter.VAR_POSITIONAL:\n+            varargs = name\n+        elif kind is Parameter.KEYWORD_ONLY:\n+            kwonlyargs.append(name)\n+            if param.default is not param.empty:\n+                kwdefaults[name] = param.default\n+        elif kind is Parameter.VAR_KEYWORD:\n+            varkw = name\n+\n+        if param.annotation is not param.empty:\n+            annotations[name] = param.annotation\n+\n+    if not kwdefaults:\n+        # compatibility with 'func.__kwdefaults__'\n+        kwdefaults = None\n+\n+    if not defaults:\n+        # compatibility with 'func.__defaults__'\n+        defaults = None\n+\n+    return inspect.FullArgSpec(args, varargs, varkw, defaults,\n+                               kwonlyargs, kwdefaults, annotations)\n+\n+\n+def unwrap(obj: Any) -> Any:\n+    \"\"\"Get an original object from wrapped object (wrapped functions).\"\"\"\n+    try:\n+        return inspect.unwrap(obj)\n+    except ValueError:\n+        # might be a mock object\n+        return obj\n+\n+\n+def unwrap_all(obj: Any, *, stop: Callable = None) -> Any:\n+    \"\"\"\n+    Get an original object from wrapped object (unwrapping partials, wrapped\n+    functions, and other decorators).\n+    \"\"\"\n+    while True:\n+        if stop and stop(obj):\n+            return obj\n+        elif ispartial(obj):\n+            obj = obj.func\n+        elif inspect.isroutine(obj) and hasattr(obj, '__wrapped__'):\n+            obj = obj.__wrapped__\n+        elif isclassmethod(obj):\n+            obj = obj.__func__\n+        elif isstaticmethod(obj):\n+            obj = obj.__func__\n+        else:\n+            return obj\n+\n+\n+def isenumclass(x: Any) -> bool:\n+    \"\"\"Check if the object is subclass of enum.\"\"\"\n+    return inspect.isclass(x) and issubclass(x, enum.Enum)\n+\n+\n+def isenumattribute(x: Any) -> bool:\n+    \"\"\"Check if the object is attribute of enum.\"\"\"\n+    return isinstance(x, enum.Enum)\n+\n+\n+def unpartial(obj: Any) -> Any:\n+    \"\"\"Get an original object from partial object.\n+\n+    This returns given object itself if not partial.\n+    \"\"\"\n+    while ispartial(obj):\n+        obj = obj.func\n+\n+    return obj\n+\n+\n+def ispartial(obj: Any) -> bool:\n+    \"\"\"Check if the object is partial.\"\"\"\n+    return isinstance(obj, (partial, partialmethod))\n+\n+\n+def isclassmethod(obj: Any) -> bool:\n+    \"\"\"Check if the object is classmethod.\"\"\"\n+    if isinstance(obj, classmethod):\n+        return True\n+    elif inspect.ismethod(obj) and obj.__self__ is not None and isclass(obj.__self__):\n+        return True\n+\n+    return False\n+\n+\n+def isstaticmethod(obj: Any, cls: Any = None, name: str = None) -> bool:\n+    \"\"\"Check if the object is staticmethod.\"\"\"\n+    if isinstance(obj, staticmethod):\n+        return True\n+    elif cls and name:\n+        # trace __mro__ if the method is defined in parent class\n+        #\n+        # .. note:: This only works well with new style classes.\n+        for basecls in getattr(cls, '__mro__', [cls]):\n+            meth = basecls.__dict__.get(name)\n+            if meth:\n+                if isinstance(meth, staticmethod):\n+                    return True\n+                else:\n+                    return False\n+\n+    return False\n+\n+\n+def isdescriptor(x: Any) -> bool:\n+    \"\"\"Check if the object is some kind of descriptor.\"\"\"\n+    for item in '__get__', '__set__', '__delete__':\n+        if hasattr(safe_getattr(x, item, None), '__call__'):\n+            return True\n+    return False\n+\n+\n+def isabstractmethod(obj: Any) -> bool:\n+    \"\"\"Check if the object is an abstractmethod.\"\"\"\n+    return safe_getattr(obj, '__isabstractmethod__', False) is True\n+\n+\n+def is_cython_function_or_method(obj: Any) -> bool:\n+    \"\"\"Check if the object is a function or method in cython.\"\"\"\n+    try:\n+        return obj.__class__.__name__ == 'cython_function_or_method'\n+    except AttributeError:\n+        return False\n+\n+\n+def isattributedescriptor(obj: Any) -> bool:\n+    \"\"\"Check if the object is an attribute like descriptor.\"\"\"\n+    if inspect.isdatadescriptor(obj):\n+        # data descriptor is kind of attribute\n+        return True\n+    elif isdescriptor(obj):\n+        # non data descriptor\n+        unwrapped = unwrap(obj)\n+        if isfunction(unwrapped) or isbuiltin(unwrapped) or inspect.ismethod(unwrapped):\n+            # attribute must not be either function, builtin and method\n+            return False\n+        elif is_cython_function_or_method(unwrapped):\n+            # attribute must not be either function and method (for cython)\n+            return False\n+        elif inspect.isclass(unwrapped):\n+            # attribute must not be a class\n+            return False\n+        elif isinstance(unwrapped, (ClassMethodDescriptorType,\n+                                    MethodDescriptorType,\n+                                    WrapperDescriptorType)):\n+            # attribute must not be a method descriptor\n+            return False\n+        elif type(unwrapped).__name__ == \"instancemethod\":\n+            # attribute must not be an instancemethod (C-API)\n+            return False\n+        else:\n+            return True\n+    else:\n+        return False\n+\n+\n+def is_singledispatch_function(obj: Any) -> bool:\n+    \"\"\"Check if the object is singledispatch function.\"\"\"\n+    if (inspect.isfunction(obj) and\n+            hasattr(obj, 'dispatch') and\n+            hasattr(obj, 'register') and\n+            obj.dispatch.__module__ == 'functools'):\n+        return True\n+    else:\n+        return False\n+\n+\n+def is_singledispatch_method(obj: Any) -> bool:\n+    \"\"\"Check if the object is singledispatch method.\"\"\"\n+    try:\n+        from functools import singledispatchmethod  # type: ignore\n+        return isinstance(obj, singledispatchmethod)\n+    except ImportError:  # py35-37\n+        return False\n+\n+\n+def isfunction(obj: Any) -> bool:\n+    \"\"\"Check if the object is function.\"\"\"\n+    return inspect.isfunction(unwrap_all(obj))\n+\n+\n+def isbuiltin(obj: Any) -> bool:\n+    \"\"\"Check if the object is builtin.\"\"\"\n+    return inspect.isbuiltin(unwrap_all(obj))\n+\n+\n+def isroutine(obj: Any) -> bool:\n+    \"\"\"Check is any kind of function or method.\"\"\"\n+    return inspect.isroutine(unwrap_all(obj))\n+\n+\n+def iscoroutinefunction(obj: Any) -> bool:\n+    \"\"\"Check if the object is coroutine-function.\"\"\"\n+    # unwrap staticmethod, classmethod and partial (except wrappers)\n+    obj = unwrap_all(obj, stop=lambda o: hasattr(o, '__wrapped__'))\n+    if hasattr(obj, '__code__') and inspect.iscoroutinefunction(obj):\n+        # check obj.__code__ because iscoroutinefunction() crashes for custom method-like\n+        # objects (see https://github.com/sphinx-doc/sphinx/issues/6605)\n+        return True\n+    else:\n+        return False\n+\n+\n+def isproperty(obj: Any) -> bool:\n+    \"\"\"Check if the object is property.\"\"\"\n+    return isinstance(obj, property)\n+\n+\n+def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n+    \"\"\"A getattr() that turns all exceptions into AttributeErrors.\"\"\"\n+    try:\n+        return getattr(obj, name, *defargs)\n+    except Exception:\n+        # sometimes accessing a property raises an exception (e.g.\n+        # NotImplementedError), so let's try to read the attribute directly\n+        try:\n+            # In case the object does weird things with attribute access\n+            # such that accessing `obj.__dict__` may raise an exception\n+            return obj.__dict__[name]\n+        except Exception:\n+            pass\n+\n+        # this is a catch-all for all the weird things that some modules do\n+        # with attribute access\n+        if defargs:\n+            return defargs[0]\n+\n+        raise AttributeError(name)\n+\n+\n+def safe_getmembers(object: Any, predicate: Callable[[str], bool] = None,\n+                    attr_getter: Callable = safe_getattr) -> List[Tuple[str, Any]]:\n+    \"\"\"A version of inspect.getmembers() that uses safe_getattr().\"\"\"\n+    warnings.warn('safe_getmembers() is deprecated', RemovedInSphinx40Warning, stacklevel=2)\n+\n+    results = []  # type: List[Tuple[str, Any]]\n+    for key in dir(object):\n+        try:\n+            value = attr_getter(object, key, None)\n+        except AttributeError:\n+            continue\n+        if not predicate or predicate(value):\n+            results.append((key, value))\n+    results.sort()\n+    return results\n+\n+\n+def object_description(object: Any) -> str:\n+    \"\"\"A repr() implementation that returns text safe to use in reST context.\"\"\"\n+    if isinstance(object, dict):\n+        try:\n+            sorted_keys = sorted(object)\n+        except Exception:\n+            pass  # Cannot sort dict keys, fall back to generic repr\n+        else:\n+            items = (\"%s: %s\" %\n+                     (object_description(key), object_description(object[key]))\n+                     for key in sorted_keys)\n+            return \"{%s}\" % \", \".join(items)\n+    if isinstance(object, set):\n+        try:\n+            sorted_values = sorted(object)\n+        except TypeError:\n+            pass  # Cannot sort set values, fall back to generic repr\n+        else:\n+            return \"{%s}\" % \", \".join(object_description(x) for x in sorted_values)\n+    if isinstance(object, frozenset):\n+        try:\n+            sorted_values = sorted(object)\n+        except TypeError:\n+            pass  # Cannot sort frozenset values, fall back to generic repr\n+        else:\n+            return \"frozenset({%s})\" % \", \".join(object_description(x)\n+                                                 for x in sorted_values)\n+    try:\n+        s = repr(object)\n+    except Exception:\n+        raise ValueError\n+    # Strip non-deterministic memory addresses such as\n+    # ``<__main__.A at 0x7f68cb685710>``\n+    s = memory_address_re.sub('', s)\n+    return s.replace('\\n', ' ')\n+\n+\n+def is_builtin_class_method(obj: Any, attr_name: str) -> bool:\n+    \"\"\"If attr_name is implemented at builtin class, return True.\n+\n+        >>> is_builtin_class_method(int, '__init__')\n+        True\n+\n+    Why this function needed? CPython implements int.__init__ by Descriptor\n+    but PyPy implements it by pure Python code.\n+    \"\"\"\n+    try:\n+        mro = inspect.getmro(obj)\n+    except AttributeError:\n+        # no __mro__, assume the object has no methods as we know them\n+        return False\n+\n+    try:\n+        cls = next(c for c in mro if attr_name in safe_getattr(c, '__dict__', {}))\n+    except StopIteration:\n+        return False\n+\n+    try:\n+        name = safe_getattr(cls, '__name__')\n+    except AttributeError:\n+        return False\n+\n+    return getattr(builtins, name, None) is cls\n+\n+\n+def signature(subject: Callable, bound_method: bool = False, follow_wrapped: bool = False\n+              ) -> inspect.Signature:\n+    \"\"\"Return a Signature object for the given *subject*.\n+\n+    :param bound_method: Specify *subject* is a bound method or not\n+    :param follow_wrapped: Same as ``inspect.signature()``.\n+                           Defaults to ``False`` (get a signature of *subject*).\n+    \"\"\"\n+    try:\n+        try:\n+            signature = inspect.signature(subject, follow_wrapped=follow_wrapped)\n+        except ValueError:\n+            # follow built-in wrappers up (ex. functools.lru_cache)\n+            signature = inspect.signature(subject)\n+        parameters = list(signature.parameters.values())\n+        return_annotation = signature.return_annotation\n+    except IndexError:\n+        # Until python 3.6.4, cpython has been crashed on inspection for\n+        # partialmethods not having any arguments.\n+        # https://bugs.python.org/issue33009\n+        if hasattr(subject, '_partialmethod'):\n+            parameters = []\n+            return_annotation = Parameter.empty\n+        else:\n+            raise\n+\n+    try:\n+        # Update unresolved annotations using ``get_type_hints()``.\n+        annotations = typing.get_type_hints(subject)\n+        for i, param in enumerate(parameters):\n+            if isinstance(param.annotation, str) and param.name in annotations:\n+                parameters[i] = param.replace(annotation=annotations[param.name])\n+        if 'return' in annotations:\n+            return_annotation = annotations['return']\n+    except Exception:\n+        # ``get_type_hints()`` does not support some kind of objects like partial,\n+        # ForwardRef and so on.\n+        pass\n+\n+    if bound_method:\n+        if inspect.ismethod(subject):\n+            # ``inspect.signature()`` considers the subject is a bound method and removes\n+            # first argument from signature.  Therefore no skips are needed here.\n+            pass\n+        else:\n+            if len(parameters) > 0:\n+                parameters.pop(0)\n+\n+    return inspect.Signature(parameters, return_annotation=return_annotation)\n+\n+\n+def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n+                        show_return_annotation: bool = True) -> str:\n+    \"\"\"Stringify a Signature object.\n+\n+    :param show_annotation: Show annotation in result\n+    \"\"\"\n+    args = []\n+    last_kind = None\n+    for param in sig.parameters.values():\n+        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n+            # PEP-570: Separator for Positional Only Parameter: /\n+            args.append('/')\n+        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n+                                                              param.POSITIONAL_ONLY,\n+                                                              None):\n+            # PEP-3102: Separator for Keyword Only Parameter: *\n+            args.append('*')\n+\n+        arg = StringIO()\n+        if param.kind == param.VAR_POSITIONAL:\n+            arg.write('*' + param.name)\n+        elif param.kind == param.VAR_KEYWORD:\n+            arg.write('**' + param.name)\n+        else:\n+            arg.write(param.name)\n+\n+        if show_annotation and param.annotation is not param.empty:\n+            arg.write(': ')\n+            arg.write(stringify_annotation(param.annotation))\n+        if param.default is not param.empty:\n+            if show_annotation and param.annotation is not param.empty:\n+                arg.write(' = ')\n+            else:\n+                arg.write('=')\n+            arg.write(object_description(param.default))\n+\n+        args.append(arg.getvalue())\n+        last_kind = param.kind\n+\n+    if last_kind == Parameter.POSITIONAL_ONLY:\n+        # PEP-570: Separator for Positional Only Parameter: /\n+        args.append('/')\n+\n+    if (sig.return_annotation is Parameter.empty or\n+            show_annotation is False or\n+            show_return_annotation is False):\n+        return '(%s)' % ', '.join(args)\n+    else:\n+        annotation = stringify_annotation(sig.return_annotation)\n+        return '(%s) -> %s' % (', '.join(args), annotation)\n+\n+\n+def signature_from_str(signature: str) -> inspect.Signature:\n+    \"\"\"Create a Signature object from string.\"\"\"\n+    module = ast.parse('def func' + signature + ': pass')\n+    definition = cast(ast.FunctionDef, module.body[0])  # type: ignore\n+\n+    # parameters\n+    args = definition.args\n+    params = []\n+\n+    if hasattr(args, \"posonlyargs\"):\n+        for arg in args.posonlyargs:  # type: ignore\n+            annotation = ast_unparse(arg.annotation) or Parameter.empty\n+            params.append(Parameter(arg.arg, Parameter.POSITIONAL_ONLY,\n+                                    annotation=annotation))\n+\n+    for i, arg in enumerate(args.args):\n+        if len(args.args) - i <= len(args.defaults):\n+            default = ast_unparse(args.defaults[-len(args.args) + i])\n+        else:\n+            default = Parameter.empty\n+\n+        annotation = ast_unparse(arg.annotation) or Parameter.empty\n+        params.append(Parameter(arg.arg, Parameter.POSITIONAL_OR_KEYWORD,\n+                                default=default, annotation=annotation))\n+\n+    if args.vararg:\n+        annotation = ast_unparse(args.vararg.annotation) or Parameter.empty\n+        params.append(Parameter(args.vararg.arg, Parameter.VAR_POSITIONAL,\n+                                annotation=annotation))\n+\n+    for i, arg in enumerate(args.kwonlyargs):\n+        default = ast_unparse(args.kw_defaults[i]) or Parameter.empty\n+        annotation = ast_unparse(arg.annotation) or Parameter.empty\n+        params.append(Parameter(arg.arg, Parameter.KEYWORD_ONLY, default=default,\n+                                annotation=annotation))\n+\n+    if args.kwarg:\n+        annotation = ast_unparse(args.kwarg.annotation) or Parameter.empty\n+        params.append(Parameter(args.kwarg.arg, Parameter.VAR_KEYWORD,\n+                                annotation=annotation))\n+\n+    return_annotation = ast_unparse(definition.returns) or Parameter.empty\n+\n+    return inspect.Signature(params, return_annotation=return_annotation)\n+\n+\n+class Signature:\n+    \"\"\"The Signature object represents the call signature of a callable object and\n+    its return annotation.\n+    \"\"\"\n+\n+    empty = inspect.Signature.empty\n+\n+    def __init__(self, subject: Callable, bound_method: bool = False,\n+                 has_retval: bool = True) -> None:\n+        warnings.warn('sphinx.util.inspect.Signature() is deprecated',\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+\n+        # check subject is not a built-in class (ex. int, str)\n+        if (isinstance(subject, type) and\n+                is_builtin_class_method(subject, \"__new__\") and\n+                is_builtin_class_method(subject, \"__init__\")):\n+            raise TypeError(\"can't compute signature for built-in type {}\".format(subject))\n+\n+        self.subject = subject\n+        self.has_retval = has_retval\n+        self.partialmethod_with_noargs = False\n+\n+        try:\n+            self.signature = inspect.signature(subject)  # type: Optional[inspect.Signature]\n+        except IndexError:\n+            # Until python 3.6.4, cpython has been crashed on inspection for\n+            # partialmethods not having any arguments.\n+            # https://bugs.python.org/issue33009\n+            if hasattr(subject, '_partialmethod'):\n+                self.signature = None\n+                self.partialmethod_with_noargs = True\n+            else:\n+                raise\n+\n+        try:\n+            self.annotations = typing.get_type_hints(subject)\n+        except Exception:\n+            # get_type_hints() does not support some kind of objects like partial,\n+            # ForwardRef and so on.  For them, it raises an exception. In that case,\n+            # we try to build annotations from argspec.\n+            self.annotations = {}\n+\n+        if bound_method:\n+            # client gives a hint that the subject is a bound method\n+\n+            if inspect.ismethod(subject):\n+                # inspect.signature already considers the subject is bound method.\n+                # So it is not need to skip first argument.\n+                self.skip_first_argument = False\n+            else:\n+                self.skip_first_argument = True\n+        else:\n+            # inspect.signature recognizes type of method properly without any hints\n+            self.skip_first_argument = False\n+\n+    @property\n+    def parameters(self) -> Mapping:\n+        if self.partialmethod_with_noargs:\n+            return {}\n+        else:\n+            return self.signature.parameters\n+\n+    @property\n+    def return_annotation(self) -> Any:\n+        if self.signature:\n+            if self.has_retval:\n+                return self.signature.return_annotation\n+            else:\n+                return Parameter.empty\n+        else:\n+            return None\n+\n+    def format_args(self, show_annotation: bool = True) -> str:\n+        def get_annotation(param: Parameter) -> Any:\n+            if isinstance(param.annotation, str) and param.name in self.annotations:\n+                return self.annotations[param.name]\n+            else:\n+                return param.annotation\n+\n+        args = []\n+        last_kind = None\n+        for i, param in enumerate(self.parameters.values()):\n+            # skip first argument if subject is bound method\n+            if self.skip_first_argument and i == 0:\n+                continue\n+\n+            arg = StringIO()\n+\n+            # insert '*' between POSITIONAL args and KEYWORD_ONLY args::\n+            #     func(a, b, *, c, d):\n+            if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n+                                                                  param.POSITIONAL_ONLY,\n+                                                                  None):\n+                args.append('*')\n+\n+            if param.kind in (param.POSITIONAL_ONLY,\n+                              param.POSITIONAL_OR_KEYWORD,\n+                              param.KEYWORD_ONLY):\n+                arg.write(param.name)\n+                if show_annotation and param.annotation is not param.empty:\n+                    arg.write(': ')\n+                    arg.write(stringify_annotation(get_annotation(param)))\n+                if param.default is not param.empty:\n+                    if param.annotation is param.empty or show_annotation is False:\n+                        arg.write('=')\n+                        arg.write(object_description(param.default))\n+                    else:\n+                        arg.write(' = ')\n+                        arg.write(object_description(param.default))\n+            elif param.kind == param.VAR_POSITIONAL:\n+                arg.write('*')\n+                arg.write(param.name)\n+                if show_annotation and param.annotation is not param.empty:\n+                    arg.write(': ')\n+                    arg.write(stringify_annotation(get_annotation(param)))\n+            elif param.kind == param.VAR_KEYWORD:\n+                arg.write('**')\n+                arg.write(param.name)\n+                if show_annotation and param.annotation is not param.empty:\n+                    arg.write(': ')\n+                    arg.write(stringify_annotation(get_annotation(param)))\n+\n+            args.append(arg.getvalue())\n+            last_kind = param.kind\n+\n+        if self.return_annotation is Parameter.empty or show_annotation is False:\n+            return '(%s)' % ', '.join(args)\n+        else:\n+            if 'return' in self.annotations:\n+                annotation = stringify_annotation(self.annotations['return'])\n+            else:\n+                annotation = stringify_annotation(self.return_annotation)\n+\n+            return '(%s) -> %s' % (', '.join(args), annotation)\n+\n+    def format_annotation(self, annotation: Any) -> str:\n+        \"\"\"Return formatted representation of a type annotation.\"\"\"\n+        return stringify_annotation(annotation)\n+\n+    def format_annotation_new(self, annotation: Any) -> str:\n+        \"\"\"format_annotation() for py37+\"\"\"\n+        return stringify_annotation(annotation)\n+\n+    def format_annotation_old(self, annotation: Any) -> str:\n+        \"\"\"format_annotation() for py36 or below\"\"\"\n+        return stringify_annotation(annotation)\n+\n+\n+def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n+           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n+    \"\"\"Get the docstring for the object.\n+\n+    This tries to obtain the docstring for some kind of objects additionally:\n+\n+    * partial functions\n+    * inherited docstring\n+    * inherited decorated methods\n+    \"\"\"\n+    doc = attrgetter(obj, '__doc__', None)\n+    if ispartial(obj) and doc == obj.__class__.__doc__:\n+        return getdoc(obj.func)\n+    elif doc is None and allow_inherited:\n+        doc = inspect.getdoc(obj)\n+\n+        if doc is None and cls:\n+            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n+            # This tries to obtain the docstring from super classes.\n+            for basecls in getattr(cls, '__mro__', []):\n+                meth = safe_getattr(basecls, name, None)\n+                if meth is not None:\n+                    doc = inspect.getdoc(meth)\n+                    if doc:\n+                        break\n+\n+    return doc\n\n"
  },
  "sphinx-doc__sphinx-7985": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7985",
    "model_patch": "diff --git a/repro/Makefile b/repro/Makefile\nnew file mode 100644\nindex 000000000..d4bb2cbb9\n--- /dev/null\n+++ b/repro/Makefile\n@@ -0,0 +1,20 @@\n+# Minimal makefile for Sphinx documentation\n+#\n+\n+# You can set these variables from the command line, and also\n+# from the environment for the first two.\n+SPHINXOPTS    ?=\n+SPHINXBUILD   ?= sphinx-build\n+SOURCEDIR     = .\n+BUILDDIR      = _build\n+\n+# Put it first so that \"make\" without argument is like \"make help\".\n+help:\n+\t@$(SPHINXBUILD) -M help \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O)\n+\n+.PHONY: help Makefile\n+\n+# Catch-all target: route all unknown targets to Sphinx using the new\n+# \"make mode\" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).\n+%: Makefile\n+\t@$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O)\ndiff --git a/repro/_build/doctrees/environment.pickle b/repro/_build/doctrees/environment.pickle\nnew file mode 100644\nindex 000000000..b6ace5477\nBinary files /dev/null and b/repro/_build/doctrees/environment.pickle differ\ndiff --git a/repro/_build/doctrees/index.doctree b/repro/_build/doctrees/index.doctree\nnew file mode 100644\nindex 000000000..f9cc63ed3\nBinary files /dev/null and b/repro/_build/doctrees/index.doctree differ\ndiff --git a/repro/_build/linkcheck/output.json b/repro/_build/linkcheck/output.json\nnew file mode 100644\nindex 000000000..2562f8589\n--- /dev/null\n+++ b/repro/_build/linkcheck/output.json\n@@ -0,0 +1,2 @@\n+{\"filename\": \"index.rst\", \"lineno\": 1, \"status\": \"broken\", \"code\": 0, \"uri\": \"doesntexist\", \"info\": \"local target not found: doesntexist\"}\n+{\"filename\": \"index.rst\", \"lineno\": 1, \"status\": \"broken\", \"code\": 0, \"uri\": \"https://lkfqhlkghflkhs\", \"info\": \"HTTPSConnectionPool(host='lkfqhlkghflkhs', port=443): Max retries exceeded with url: / (Caused by NameResolutionError(\\\"<urllib3.connection.HTTPSConnection object at 0x73441269d760>: Failed to resolve 'lkfqhlkghflkhs' ([Errno -2] Name or service not known)\\\"))\"}\ndiff --git a/repro/_build/linkcheck/output.txt b/repro/_build/linkcheck/output.txt\nnew file mode 100644\nindex 000000000..53d5eb9c0\n--- /dev/null\n+++ b/repro/_build/linkcheck/output.txt\n@@ -0,0 +1,2 @@\n+index.rst:1: [broken] doesntexist: local target not found: doesntexist\n+index.rst:1: [broken] https://lkfqhlkghflkhs: HTTPSConnectionPool(host='lkfqhlkghflkhs', port=443): Max retries exceeded with url: / (Caused by NameResolutionError(\"<urllib3.connection.HTTPSConnection object at 0x73441269d760>: Failed to resolve 'lkfqhlkghflkhs' ([Errno -2] Name or service not known)\"))\ndiff --git a/repro/conf.py b/repro/conf.py\nnew file mode 100644\nindex 000000000..e108d8f42\n--- /dev/null\n+++ b/repro/conf.py\n@@ -0,0 +1,58 @@\n+# Configuration file for the Sphinx documentation builder.\n+#\n+# This file only contains a selection of the most common options. For a full\n+# list see the documentation:\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html\n+\n+# -- Path setup --------------------------------------------------------------\n+\n+# If extensions (or modules to document with autodoc) are in another directory,\n+# add these directories to sys.path here. If the directory is relative to the\n+# documentation root, use os.path.abspath to make it absolute, like shown here.\n+#\n+# import os\n+# import sys\n+# sys.path.insert(0, os.path.abspath('.'))\n+\n+\n+# -- Project information -----------------------------------------------------\n+\n+project = 'Proj'\n+copyright = '2026, You'\n+author = 'You'\n+\n+# The short X.Y version\n+version = '0'\n+\n+# The full version, including alpha/beta/rc tags\n+release = '0'\n+\n+\n+# -- General configuration ---------------------------------------------------\n+\n+# Add any Sphinx extension module names here, as strings. They can be\n+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n+# ones.\n+extensions = [\n+]\n+\n+# Add any paths that contain templates here, relative to this directory.\n+templates_path = ['_templates']\n+\n+# List of patterns, relative to source directory, that match files and\n+# directories to ignore when looking for source files.\n+# This pattern also affects html_static_path and html_extra_path.\n+exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n+\n+\n+# -- Options for HTML output -------------------------------------------------\n+\n+# The theme to use for HTML and HTML Help pages.  See the documentation for\n+# a list of builtin themes.\n+#\n+html_theme = 'alabaster'\n+\n+# Add any paths that contain custom static files (such as style sheets) here,\n+# relative to this directory. They are copied after the builtin static files,\n+# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n+html_static_path = ['_static']\n\\ No newline at end of file\ndiff --git a/repro/index.rst b/repro/index.rst\nnew file mode 100644\nindex 000000000..774627841\n--- /dev/null\n+++ b/repro/index.rst\n@@ -0,0 +1,5 @@\n+broken external-link_\n+broken local-link_\n+\n+.. _external-link: https://lkfqhlkghflkhs\n+.. _local-link: doesntexist\ndiff --git a/repro/make.bat b/repro/make.bat\nnew file mode 100644\nindex 000000000..2119f5109\n--- /dev/null\n+++ b/repro/make.bat\n@@ -0,0 +1,35 @@\n+@ECHO OFF\n+\n+pushd %~dp0\n+\n+REM Command file for Sphinx documentation\n+\n+if \"%SPHINXBUILD%\" == \"\" (\n+\tset SPHINXBUILD=sphinx-build\n+)\n+set SOURCEDIR=.\n+set BUILDDIR=_build\n+\n+if \"%1\" == \"\" goto help\n+\n+%SPHINXBUILD% >NUL 2>NUL\n+if errorlevel 9009 (\n+\techo.\n+\techo.The 'sphinx-build' command was not found. Make sure you have Sphinx\n+\techo.installed, then set the SPHINXBUILD environment variable to point\n+\techo.to the full path of the 'sphinx-build' executable. Alternatively you\n+\techo.may add the Sphinx directory to PATH.\n+\techo.\n+\techo.If you don't have Sphinx installed, grab it from\n+\techo.http://sphinx-doc.org/\n+\texit /b 1\n+)\n+\n+%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%\n+goto end\n+\n+:help\n+%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%\n+\n+:end\n+popd\ndiff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..1e8967d84 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -213,7 +213,29 @@ class CheckExternalLinksBuilder(Builder):\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # treat local/internal links: try to resolve to docs or files\n+                target = uri\n+                anchor = None\n+                if '#' in uri:\n+                    target, anchor = uri.split('#', 1)\n+                # check for docname (strip .html)\n+                t_doc = target[:-5] if target.endswith('.html') else target\n+                try:\n+                    if t_doc in self.env.found_docs:\n+                        return 'working', '', 0\n+                except Exception:\n+                    pass\n+                # check filesystem relative to source dir\n+                try:\n+                    srcpath = path.join(self.env.srcdir, unquote(target))\n+                    if path.exists(srcpath):\n+                        return 'working', '', 0\n+                    for ext in ('.rst', '.md', '.txt', '.html'):\n+                        if path.exists(srcpath + ext):\n+                            return 'working', '', 0\n+                except Exception:\n+                    pass\n+                return 'broken', __('local target not found: %s') % uri, 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n\n"
  },
  "sphinx-doc__sphinx-8035": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8035",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 8c3509c3b..b984bd4ff 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -859,7 +859,7 @@ class ModuleDocumenter(Documenter):\n         'show-inheritance': bool_option, 'synopsis': identity,\n         'platform': identity, 'deprecated': bool_option,\n         'member-order': member_order_option, 'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n         'imported-members': bool_option, 'ignore-module-all': bool_option\n     }  # type: Dict[str, Callable]\n \n@@ -1279,7 +1279,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         'noindex': bool_option, 'inherited-members': inherited_members_option,\n         'show-inheritance': bool_option, 'member-order': member_order_option,\n         'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n     }  # type: Dict[str, Callable]\n \n     _signature_class = None  # type: Any\n\n"
  },
  "sphinx-doc__sphinx-8056": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8056",
    "model_patch": "\n"
  },
  "sphinx-doc__sphinx-8265": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8265",
    "model_patch": "diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex 9bafff11c..be032d0f5 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -173,9 +173,13 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n         if node.elts:\n-            return \", \".join(self.visit(e) for e in node.elts)\n+            if len(node.elts) == 1:\n+                return '(' + self.visit(node.elts[0]) + ',)'\n+            return '(' + ', '.join(self.visit(e) for e in node.elts) + ')'\n         else:\n-            return \"()\"\n+            return '()'\n+\n+\n \n     if sys.version_info >= (3, 6):\n         def visit_Constant(self, node: ast.Constant) -> str:\n\n"
  },
  "sphinx-doc__sphinx-8269": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8269",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 9b54afc7c..1083e82ec 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -166,6 +166,7 @@ class CheckExternalLinksBuilder(Builder):\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n+                    response.raise_for_status()\n                     found = check_anchor(response, unquote(anchor))\n \n                     if not found:\n\n"
  },
  "sphinx-doc__sphinx-8475": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8475",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 1dc0337c3..cc68f53b5 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -172,7 +172,7 @@ class CheckExternalLinksBuilder(Builder):\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\n-                    except HTTPError:\n+                    except (HTTPError, requests.exceptions.TooManyRedirects):\n                         # retry with GET request if that fails, some servers\n                         # don't like HEAD requests.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n\n"
  },
  "sphinx-doc__sphinx-8548": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8548",
    "model_patch": "\n"
  },
  "sphinx-doc__sphinx-8551": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8551",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 79d7e4f46..98ec57778 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -271,8 +271,9 @@ class PyXrefMixin:\n                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n         result = super().make_xref(rolename, domain, target,  # type: ignore\n                                    innernode, contnode, env)\n-        result['refspecific'] = True\n         if target.startswith(('.', '~')):\n+            result['refspecific'] = True\n+\n             prefix, result['reftarget'] = target[0], target[1:]\n             if prefix == '.':\n                 text = target[1:]\n\n"
  },
  "sphinx-doc__sphinx-8638": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8638",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 000e2e8d3..da2597490 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -270,9 +270,10 @@ class PyXrefMixin:\n                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n         result = super().make_xref(rolename, domain, target,  # type: ignore\n                                    innernode, contnode, env)\n-        result['refspecific'] = True\n         result['py:module'] = env.ref_context.get('py:module')\n         result['py:class'] = env.ref_context.get('py:class')\n+        if target.startswith('.'):\n+            result['refspecific'] = True\n         if target.startswith(('.', '~')):\n             prefix, result['reftarget'] = target[0], target[1:]\n             if prefix == '.':\n\n"
  },
  "sphinx-doc__sphinx-8721": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8721",
    "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..1b08f3758 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -10,6 +10,7 @@\n \n import posixpath\n import traceback\n+import re\n from os import path\n from typing import Any, Dict, Generator, Iterable, Optional, Set, Tuple, cast\n \n@@ -183,6 +184,8 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n+    if app.builder.name.startswith('epub') and not env.config.viewcode_enable_epub:\n+        return\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n@@ -206,6 +209,7 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         else:\n             lexer = 'python'\n         highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        highlighted = re.sub(r'<span class=\"w\">(\\s*?)</span>', r'\\1', highlighted)\n         # split the code into lines\n         lines = highlighted.splitlines()\n         # split off wrap markup from the first line of the actual code\n\n"
  },
  "sphinx-doc__sphinx-9229": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9229",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..042fd0e9c 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1725,7 +1725,8 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     ) -> None:\n         if self.doc_as_attr:\n             try:\n-                more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n+                if more_content is None or not getattr(more_content, 'data', None):\n+                    more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n             except AttributeError:\n                 pass  # Invalid class object is passed.\n \n@@ -1798,8 +1799,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n \n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            try:\n+                doc = self.get_doc()\n+            except Exception:\n+                doc = None\n+            has_more = bool(getattr(more_content, 'data', None))\n+            if not doc and not has_more:\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1816,9 +1823,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n \n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            try:\n+                doc = self.get_doc()\n+            except Exception:\n+                doc = None\n+            has_more = bool(getattr(more_content, 'data', None))\n+            if not doc and not has_more:\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1849,18 +1862,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n \n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            try:\n+                doc = self.get_doc()\n+            except Exception:\n+                doc = None\n+            has_more = bool(getattr(more_content, 'data', None))\n+            if not doc and not has_more:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n\n"
  },
  "sphinx-doc__sphinx-9230": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9230",
    "model_patch": "\n"
  },
  "sphinx-doc__sphinx-9281": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9281",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex a415a7074..0b277b39a 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -457,6 +457,12 @@ def object_description(object: Any) -> str:\n         else:\n             return \"frozenset({%s})\" % \", \".join(object_description(x)\n                                                  for x in sorted_values)\n+    if isenumattribute(object):\n+        try:\n+            return '%s.%s' % (object.__class__.__name__, object.name)\n+        except Exception:\n+            return str(object)\n+\n     try:\n         s = repr(object)\n     except Exception as exc:\n\n"
  },
  "sphinx-doc__sphinx-9320": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9320",
    "model_patch": "diff --git a/conf.py b/conf.py\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex a40a21073..e98292736 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,7 +223,7 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', allow_empty)\n         if not d['path']:\n             sys.exit(1)\n \n\n"
  },
  "sphinx-doc__sphinx-9367": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9367",
    "model_patch": "diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex f541ec0a9..5a6b7f165 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -214,6 +214,8 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n         if node.elts:\n+            if len(node.elts) == 1:\n+                return \"(\" + self.visit(node.elts[0]) + \",)\"\n             return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n         else:\n             return \"()\"\ndiff --git a/sphinx/pycode/ast.py.bak b/sphinx/pycode/ast.py.bak\nnew file mode 100644\nindex 000000000..f541ec0a9\n--- /dev/null\n+++ b/sphinx/pycode/ast.py.bak\n@@ -0,0 +1,239 @@\n+\"\"\"\n+    sphinx.pycode.ast\n+    ~~~~~~~~~~~~~~~~~\n+\n+    Helpers for AST (Abstract Syntax Tree).\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import sys\n+from typing import Dict, List, Optional, Type, overload\n+\n+if sys.version_info > (3, 8):\n+    import ast\n+else:\n+    try:\n+        # use typed_ast module if installed\n+        from typed_ast import ast3 as ast\n+    except ImportError:\n+        import ast  # type: ignore\n+\n+\n+OPERATORS: Dict[Type[ast.AST], str] = {\n+    ast.Add: \"+\",\n+    ast.And: \"and\",\n+    ast.BitAnd: \"&\",\n+    ast.BitOr: \"|\",\n+    ast.BitXor: \"^\",\n+    ast.Div: \"/\",\n+    ast.FloorDiv: \"//\",\n+    ast.Invert: \"~\",\n+    ast.LShift: \"<<\",\n+    ast.MatMult: \"@\",\n+    ast.Mult: \"*\",\n+    ast.Mod: \"%\",\n+    ast.Not: \"not\",\n+    ast.Pow: \"**\",\n+    ast.Or: \"or\",\n+    ast.RShift: \">>\",\n+    ast.Sub: \"-\",\n+    ast.UAdd: \"+\",\n+    ast.USub: \"-\",\n+}\n+\n+\n+def parse(code: str, mode: str = 'exec') -> \"ast.AST\":\n+    \"\"\"Parse the *code* using built-in ast or typed_ast.\n+\n+    This enables \"type_comments\" feature if possible.\n+    \"\"\"\n+    try:\n+        # type_comments parameter is available on py38+\n+        return ast.parse(code, mode=mode, type_comments=True)  # type: ignore\n+    except SyntaxError:\n+        # Some syntax error found. To ignore invalid type comments, retry parsing without\n+        # type_comments parameter (refs: https://github.com/sphinx-doc/sphinx/issues/8652).\n+        return ast.parse(code, mode=mode)\n+    except TypeError:\n+        # fallback to ast module.\n+        # typed_ast is used to parse type_comments if installed.\n+        return ast.parse(code, mode=mode)\n+\n+\n+@overload\n+def unparse(node: None, code: str = '') -> None:\n+    ...\n+\n+\n+@overload\n+def unparse(node: ast.AST, code: str = '') -> str:\n+    ...\n+\n+\n+def unparse(node: Optional[ast.AST], code: str = '') -> Optional[str]:\n+    \"\"\"Unparse an AST to string.\"\"\"\n+    if node is None:\n+        return None\n+    elif isinstance(node, str):\n+        return node\n+    return _UnparseVisitor(code).visit(node)\n+\n+\n+# a greatly cut-down version of `ast._Unparser`\n+class _UnparseVisitor(ast.NodeVisitor):\n+    def __init__(self, code: str = '') -> None:\n+        self.code = code\n+\n+    def _visit_op(self, node: ast.AST) -> str:\n+        return OPERATORS[node.__class__]\n+    for _op in OPERATORS:\n+        locals()['visit_{}'.format(_op.__name__)] = _visit_op\n+\n+    def visit_arg(self, node: ast.arg) -> str:\n+        if node.annotation:\n+            return \"%s: %s\" % (node.arg, self.visit(node.annotation))\n+        else:\n+            return node.arg\n+\n+    def _visit_arg_with_default(self, arg: ast.arg, default: Optional[ast.AST]) -> str:\n+        \"\"\"Unparse a single argument to a string.\"\"\"\n+        name = self.visit(arg)\n+        if default:\n+            if arg.annotation:\n+                name += \" = %s\" % self.visit(default)\n+            else:\n+                name += \"=%s\" % self.visit(default)\n+        return name\n+\n+    def visit_arguments(self, node: ast.arguments) -> str:\n+        defaults: List[Optional[ast.expr]] = list(node.defaults)\n+        positionals = len(node.args)\n+        posonlyargs = 0\n+        if hasattr(node, \"posonlyargs\"):  # for py38+\n+            posonlyargs += len(node.posonlyargs)  # type:ignore\n+            positionals += posonlyargs\n+        for _ in range(len(defaults), positionals):\n+            defaults.insert(0, None)\n+\n+        kw_defaults: List[Optional[ast.expr]] = list(node.kw_defaults)\n+        for _ in range(len(kw_defaults), len(node.kwonlyargs)):\n+            kw_defaults.insert(0, None)\n+\n+        args: List[str] = []\n+        if hasattr(node, \"posonlyargs\"):  # for py38+\n+            for i, arg in enumerate(node.posonlyargs):  # type: ignore\n+                args.append(self._visit_arg_with_default(arg, defaults[i]))\n+\n+            if node.posonlyargs:  # type: ignore\n+                args.append('/')\n+\n+        for i, arg in enumerate(node.args):\n+            args.append(self._visit_arg_with_default(arg, defaults[i + posonlyargs]))\n+\n+        if node.vararg:\n+            args.append(\"*\" + self.visit(node.vararg))\n+\n+        if node.kwonlyargs and not node.vararg:\n+            args.append('*')\n+        for i, arg in enumerate(node.kwonlyargs):\n+            args.append(self._visit_arg_with_default(arg, kw_defaults[i]))\n+\n+        if node.kwarg:\n+            args.append(\"**\" + self.visit(node.kwarg))\n+\n+        return \", \".join(args)\n+\n+    def visit_Attribute(self, node: ast.Attribute) -> str:\n+        return \"%s.%s\" % (self.visit(node.value), node.attr)\n+\n+    def visit_BinOp(self, node: ast.BinOp) -> str:\n+        return \" \".join(self.visit(e) for e in [node.left, node.op, node.right])\n+\n+    def visit_BoolOp(self, node: ast.BoolOp) -> str:\n+        op = \" %s \" % self.visit(node.op)\n+        return op.join(self.visit(e) for e in node.values)\n+\n+    def visit_Call(self, node: ast.Call) -> str:\n+        args = ([self.visit(e) for e in node.args] +\n+                [\"%s=%s\" % (k.arg, self.visit(k.value)) for k in node.keywords])\n+        return \"%s(%s)\" % (self.visit(node.func), \", \".join(args))\n+\n+    def visit_Constant(self, node: ast.Constant) -> str:  # type: ignore\n+        if node.value is Ellipsis:\n+            return \"...\"\n+        elif isinstance(node.value, (int, float, complex)):\n+            if self.code and sys.version_info > (3, 8):\n+                return ast.get_source_segment(self.code, node)  # type: ignore\n+            else:\n+                return repr(node.value)\n+        else:\n+            return repr(node.value)\n+\n+    def visit_Dict(self, node: ast.Dict) -> str:\n+        keys = (self.visit(k) for k in node.keys)\n+        values = (self.visit(v) for v in node.values)\n+        items = (k + \": \" + v for k, v in zip(keys, values))\n+        return \"{\" + \", \".join(items) + \"}\"\n+\n+    def visit_Index(self, node: ast.Index) -> str:\n+        return self.visit(node.value)\n+\n+    def visit_Lambda(self, node: ast.Lambda) -> str:\n+        return \"lambda %s: ...\" % self.visit(node.args)\n+\n+    def visit_List(self, node: ast.List) -> str:\n+        return \"[\" + \", \".join(self.visit(e) for e in node.elts) + \"]\"\n+\n+    def visit_Name(self, node: ast.Name) -> str:\n+        return node.id\n+\n+    def visit_Set(self, node: ast.Set) -> str:\n+        return \"{\" + \", \".join(self.visit(e) for e in node.elts) + \"}\"\n+\n+    def visit_Subscript(self, node: ast.Subscript) -> str:\n+        def is_simple_tuple(value: ast.AST) -> bool:\n+            return (\n+                isinstance(value, ast.Tuple) and\n+                bool(value.elts) and\n+                not any(isinstance(elt, ast.Starred) for elt in value.elts)\n+            )\n+\n+        if is_simple_tuple(node.slice):\n+            elts = \", \".join(self.visit(e) for e in node.slice.elts)  # type: ignore\n+            return \"%s[%s]\" % (self.visit(node.value), elts)\n+        elif isinstance(node.slice, ast.Index) and is_simple_tuple(node.slice.value):\n+            elts = \", \".join(self.visit(e) for e in node.slice.value.elts)  # type: ignore\n+            return \"%s[%s]\" % (self.visit(node.value), elts)\n+        else:\n+            return \"%s[%s]\" % (self.visit(node.value), self.visit(node.slice))\n+\n+    def visit_UnaryOp(self, node: ast.UnaryOp) -> str:\n+        return \"%s %s\" % (self.visit(node.op), self.visit(node.operand))\n+\n+    def visit_Tuple(self, node: ast.Tuple) -> str:\n+        if node.elts:\n+            return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n+        else:\n+            return \"()\"\n+\n+    if sys.version_info < (3, 8):\n+        # these ast nodes were deprecated in python 3.8\n+        def visit_Bytes(self, node: ast.Bytes) -> str:\n+            return repr(node.s)\n+\n+        def visit_Ellipsis(self, node: ast.Ellipsis) -> str:\n+            return \"...\"\n+\n+        def visit_NameConstant(self, node: ast.NameConstant) -> str:\n+            return repr(node.value)\n+\n+        def visit_Num(self, node: ast.Num) -> str:\n+            return repr(node.n)\n+\n+        def visit_Str(self, node: ast.Str) -> str:\n+            return repr(node.s)\n+\n+    def generic_visit(self, node):\n+        raise NotImplementedError('Unable to parse %s object' % type(node).__name__)\n\n"
  },
  "sphinx-doc__sphinx-9461": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9461",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 23dd9e930..e17ed1ff6 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -861,5 +861,16 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n \n         if doc is None:\n             doc = inspect.getdoc(obj)\n+            if doc is None:\n+                try:\n+                    # Handle classmethod(property): prefer the property's fget docstring.\n+                    if isinstance(obj, classmethod):\n+                        target = getattr(obj, '__func__', None)\n+                        if isinstance(target, property):\n+                            f = getattr(target, 'fget', None)\n+                            if f is not None:\n+                                doc = attrgetter(f, '__doc__', None) or inspect.getdoc(f)\n+                except Exception:\n+                    pass\n \n     return doc\n\n"
  },
  "sphinx-doc__sphinx-9698": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9698",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex cd02eaad5..8f3dd383f 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -788,6 +788,11 @@ class PyMethod(PyObject):\n             if modname and self.env.config.add_module_names:\n                 clsname = '.'.join([modname, clsname])\n         except ValueError:\n+            if 'property' in self.options:\n+                if modname:\n+                    return _('%s (in module %s)') % (name, modname)\n+                else:\n+                    return name\n             if modname:\n                 return _('%s() (in module %s)') % (name, modname)\n             else:\n@@ -796,7 +801,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n\n"
  }
}