{
  "django__django-11790": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11790",
    "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex a0cfed0995..459f9d6a41 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -191,7 +191,12 @@ class AuthenticationForm(forms.Form):\n \n         # Set the max length and label for the \"username\" field.\n         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n-        self.fields['username'].max_length = self.username_field.max_length or 254\n+        max_length = self.username_field.max_length or 254\n+        self.fields['username'].max_length = max_length\n+        # Ensure the widget gets the corresponding HTML maxlength attribute\n+        widget = self.fields['username'].widget\n+        if max_length is not None and not getattr(widget, 'is_hidden', False):\n+            widget.attrs.setdefault('maxlength', str(max_length))\n         if self.fields['username'].label is None:\n             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n \n"
  },
  "django__django-11815": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11815",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..1815235d5d 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,10 +120,11 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n-\n+        # Use the enum member name so migrations remain stable even if values are translated\n+        name_string, name_imports = serializer_factory(self.value.name).serialize()\n+        imports = {'import %s' % module, *name_imports}\n+        # Refer to the member by name: Module.EnumClass['NAME']\n+        return \"%s.%s[%s]\" % (module, enum_class.__name__, name_string), imports\n \n class FloatSerializer(BaseSimpleSerializer):\n     def serialize(self):\n"
  },
  "django__django-11848": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11848",
    "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..bc837a9985 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,16 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n-            else:\n-                year += 1900\n+            # Interpret two-digit years per RFC 7231:\n+            # choose the nearest year with the same last two digits such that\n+            # the resulting year is not more than 50 years in the future.\n+            now = datetime.datetime.utcnow().year\n+            base = (now // 100) * 100 + year\n+            if base - now > 50:\n+                base -= 100\n+            elif now - base > 50:\n+                base += 100\n+            year = base\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n"
  },
  "django__django-11880": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11880",
    "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 03cd8af8d7..0769e088f1 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -200,6 +200,10 @@ class Field:\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n         result.validators = self.validators[:]\n+        # Ensure error_messages is not shared between copies. Use deepcopy so that\n+        # nested structures (or lazy translations) are copied correctly and\n+        # modifications to one field's messages don't affect others.\n+        result.error_messages = copy.deepcopy(getattr(self, 'error_messages', {}), memo)\n         return result\n \n \n"
  },
  "django__django-11885": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11885",
    "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..7d02ddd22b 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -309,10 +309,34 @@ class Collector:\n                         sender=model, instance=obj, using=self.using\n                     )\n \n-            # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+            # fast deletes: combine queries by model to reduce DB roundtrips\n+            fast_deletes_by_model = {}\n+            for entry in self.fast_deletes:\n+                # QuerySet-like objects have _raw_delete and model attributes;\n+                # otherwise treat as single model instance.\n+                if hasattr(entry, '_raw_delete') and hasattr(entry, 'model'):\n+                    model = entry.model\n+                else:\n+                    model = entry.__class__\n+                fast_deletes_by_model.setdefault(model, []).append(entry)\n+            for model, entries in fast_deletes_by_model.items():\n+                # Collect primary keys for all entries for this model.\n+                pks = set()\n+                for e in entries:\n+                    if hasattr(e, 'values_list'):\n+                        # QuerySet: fetch matching pks\n+                        pks.update(list(e.values_list('pk', flat=True)))\n+                    else:\n+                        # Single instance\n+                        pk = getattr(e, 'pk', None)\n+                        if pk is not None:\n+                            pks.add(pk)\n+                if not pks:\n+                    continue\n+                # Delete all collected pks in batches via DeleteQuery\n+                query = sql.DeleteQuery(model)\n+                count = query.delete_batch(list(pks), self.using)\n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n"
  },
  "django__django-11951": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11951",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 794e0faae7..92349cd0c5 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1209,7 +1209,8 @@ class QuerySet:\n         if ignore_conflicts and not connections[self.db].features.supports_ignore_conflicts:\n             raise NotSupportedError('This database backend does not support ignoring conflicts.')\n         ops = connections[self.db].ops\n-        batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))\n+        max_batch_size = max(ops.bulk_batch_size(fields, objs), 1)\n+        batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n         inserted_rows = []\n         bulk_return = connections[self.db].features.can_return_rows_from_bulk_insert\n         for item in [objs[i:i + batch_size] for i in range(0, len(objs), batch_size)]:\n"
  },
  "django__django-11964": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11964",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..b28182be98 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -60,7 +60,15 @@ class ChoicesMeta(enum.EnumMeta):\n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated choices.\"\"\"\n-    pass\n+\n+    def __str__(self):\n+        \"\"\"Return the underlying value for stringification.\n+\n+        This ensures TextChoices/IntegerChoices members stringify to their\n+        .value (e.g. 'first') instead of the Enum member name\n+        (e.g. 'MyChoice.FIRST_CHOICE').\n+        \"\"\"\n+        return str(self.value)\n \n \n class IntegerChoices(int, Choices):\n"
  },
  "django__django-12039": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12039",
    "model_patch": "diff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex 44e49806f8..ff7cfa38bc 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -84,9 +84,12 @@ class Columns(TableColumns):\n     def __str__(self):\n         def col_str(column, idx):\n             try:\n-                return self.quote_name(column) + self.col_suffixes[idx]\n+                suffix = self.col_suffixes[idx]\n             except IndexError:\n-                return self.quote_name(column)\n+                suffix = ''\n+            if suffix:\n+                return '{} {}'.format(self.quote_name(column), suffix)\n+            return self.quote_name(column)\n \n         return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n \n@@ -114,9 +117,11 @@ class IndexColumns(Columns):\n             # length as self.columns.\n             col = '{} {}'.format(self.quote_name(column), self.opclasses[idx])\n             try:\n-                col = '{} {}'.format(col, self.col_suffixes[idx])\n+                suffix = self.col_suffixes[idx]\n             except IndexError:\n-                pass\n+                suffix = ''\n+            if suffix:\n+                col = '{} {}'.format(col, suffix)\n             return col\n \n         return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))\n"
  },
  "django__django-12050": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12050",
    "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ea51912e8b..90475d6fb9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,7 @@ class Query(BaseExpression):\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            value = type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
  },
  "django__django-12143": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12143",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 137e6faa0f..effc5e9296 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,7 @@ class ModelAdmin(BaseModelAdmin):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(self.model._meta.pk.name)))\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\n"
  },
  "django__django-12155": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12155",
    "model_patch": "diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 4c0e7e2a56..a5349aeab4 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,7 +34,13 @@ def trim_docstring(docstring):\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n+    # Determine indentation for all lines except the first (the first line\n+    # may be unindented). If there are no subsequent non-blank lines,\n+    # fall back to an indent of 0.\n+    if len(lines) > 1:\n+        indent = min((len(line) - len(line.lstrip())) for line in lines[1:] if line.lstrip())\n+    else:\n+        indent = 0\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \n"
  },
  "django__django-12209": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12209",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0..ac7dfb0e78 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -851,6 +851,7 @@ class Model(metaclass=ModelBase):\n         if (\n             not force_insert and\n             self._state.adding and\n+            not pk_set and\n             self._meta.pk.default and\n             self._meta.pk.default is not NOT_PROVIDED\n         ):\n"
  },
  "django__django-12262": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12262",
    "model_patch": "diff --git a/django/template/library.py b/django/template/library.py\nindex 20bc86dac8..f3d391b211 100644\n--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -261,16 +261,26 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n         if kwarg:\n             # The kwarg was successfully extracted\n             param, value = kwarg.popitem()\n-            if param not in params and param not in unhandled_kwargs and varkw is None:\n-                # An unexpected keyword argument was supplied\n-                raise TemplateSyntaxError(\n-                    \"'%s' received unexpected keyword argument '%s'\" %\n-                    (name, param))\n-            elif param in kwargs:\n+            if param in kwargs:\n+\n                 # The keyword argument has already been supplied once\n+\n                 raise TemplateSyntaxError(\n+\n                     \"'%s' received multiple values for keyword argument '%s'\" %\n+\n+                    (name, param))\n+\n+            if param not in params and param not in kwonly and varkw is None:\n+\n+                # An unexpected keyword argument was supplied\n+\n+                raise TemplateSyntaxError(\n+\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+\n                     (name, param))\n+\n             else:\n                 # All good, record the keyword argument\n                 kwargs[str(param)] = value\ndiff --git a/django/templatetags/test_tags.py b/django/templatetags/test_tags.py\nnew file mode 100644\nindex 0000000000..3915f2e269\n--- /dev/null\n+++ b/django/templatetags/test_tags.py\n@@ -0,0 +1,30 @@\n+from django.template import Library\n+register = Library()\n+\n+@register.simple_tag\n+def hello(*, greeting='hello'):\n+    return f'{greeting} world'\n+\n+@register.simple_tag\n+def hi(*, greeting):\n+    return f'{greeting} world'\n+\n+# Test rendering\n+import traceback\n+from django.template import Engine, Context\n+engine = Engine(libraries={'test_tags': 'django.templatetags.test_tags'})\n+\n+templates = [\n+    \"{% load test_tags %}{% hello greeting='hi' %}\",\n+    \"{% load test_tags %}{% hi greeting='hi' greeting='hello' %}\",\n+]\n+\n+for s in templates:\n+    try:\n+        t = engine.from_string(s)\n+        print(\"TEMPLATE:\", s)\n+        print(\"OUTPUT:\", t.render(Context({})))\n+    except Exception as e:\n+        print(\"TEMPLATE:\", s)\n+        print(\"EXCEPTION:\", type(e).__name__, str(e))\n+        traceback.print_exc()\n"
  },
  "django__django-12273": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12273",
    "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 6d7797d884..b2e54c8430 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -815,7 +815,7 @@ class Model(metaclass=ModelBase):\n                         setattr(self, field.attname, None)\n                     else:\n                         setattr(self, parent_pk_attname, getattr(self, field.attname))\n-parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n             updated = self._save_table(\n                 cls=parent, using=using, update_fields=update_fields,\n                 force_insert=parent_inserted,\ndiff --git a/myapp/__init__.py b/myapp/__init__.py\nnew file mode 100644\nindex 0000000000..1e5acb88d0\n--- /dev/null\n+++ b/myapp/__init__.py\n@@ -0,0 +1 @@\n+default_app_config = 'myapp.apps.MyAppConfig'\ndiff --git a/myapp/apps.py b/myapp/apps.py\nnew file mode 100644\nindex 0000000000..50c71224be\n--- /dev/null\n+++ b/myapp/apps.py\n@@ -0,0 +1,3 @@\n+from django.apps import AppConfig\n+class MyAppConfig(AppConfig):\n+    name = 'myapp'\ndiff --git a/myapp/models.py b/myapp/models.py\nnew file mode 100644\nindex 0000000000..466a48d7a8\n--- /dev/null\n+++ b/myapp/models.py\n@@ -0,0 +1,12 @@\n+from django.db import models\n+\n+class Item(models.Model):\n+    uid = models.AutoField(primary_key=True, editable=False)\n+    f = models.BooleanField(default=False)\n+\n+    def reset(self):\n+        self.uid = None\n+        self.f = False\n+\n+class Derived(Item):\n+    pass\ndiff --git a/myapp/tests.py b/myapp/tests.py\nnew file mode 100644\nindex 0000000000..3c82a247d4\n--- /dev/null\n+++ b/myapp/tests.py\n@@ -0,0 +1,14 @@\n+from django.test import TestCase\n+from .models import Item, Derived\n+\n+class SaveTestCase(TestCase):\n+    def setUp(self):\n+        self.derived = Derived.objects.create(f=True)  # create the first object\n+        item = Item.objects.get(pk=self.derived.pk)\n+        obj1 = item.derived\n+        obj1.reset()\n+        obj1.save()  # should create a new parent instead of overwriting the existing one\n+\n+    def test_f_true(self):\n+        obj = Item.objects.get(pk=self.derived.pk)\n+        self.assertTrue(obj.f)\ndiff --git a/test_settings.py b/test_settings.py\nnew file mode 100644\nindex 0000000000..c593c2c5c5\n--- /dev/null\n+++ b/test_settings.py\n@@ -0,0 +1,16 @@\n+SECRET_KEY = 'testsecret'\n+INSTALLED_APPS = [\n+    'django.contrib.auth',\n+    'django.contrib.contenttypes',\n+    'myapp',\n+]\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+MIDDLEWARE = []\n+ROOT_URLCONF = None\n+USE_TZ = False\n+DEFAULT_AUTO_FIELD = 'django.db.models.AutoField'\n"
  },
  "django__django-12276": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12276",
    "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 338d54d72f..d08ef8f48b 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -388,6 +388,9 @@ class FileInput(Input):\n         return name not in files\n \n \n+    def use_required_attribute(self, initial):\n+        return super().use_required_attribute(initial) and not initial\n+\n FILE_INPUT_CONTRADICTION = object()\n \n \n@@ -451,8 +454,6 @@ class ClearableFileInput(FileInput):\n             return False\n         return upload\n \n-    def use_required_attribute(self, initial):\n-        return super().use_required_attribute(initial) and not initial\n \n     def value_omitted_from_data(self, data, files, name):\n         return (\n"
  },
  "django__django-12325": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12325",
    "model_patch": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..81f29977da 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -240,21 +240,31 @@ class Options:\n \n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n-                # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n-                # created, use it instead of promoting the parent\n-                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n-                if already_created:\n-                    field = already_created[0]\n-                field.primary_key = True\n-                self.setup_pk(field)\n-                if not field.remote_field.parent_link:\n-                    raise ImproperlyConfigured(\n-                        'Add parent_link=True to %s.' % field,\n-                    )\n+                # Promote a parent link in lieu of adding yet another\n+                # field. Prefer an explicit parent_link=True if present among\n+                # parent links. Otherwise fall back to the first available\n+                # parent link. Filter out None entries (possible for proxied bases).\n+                parent_fields = [f for f in self.parents.values() if f is not None]\n+                field = None\n+                for f in parent_fields:\n+                    # Use the explicitly marked parent link if available.\n+                    if getattr(getattr(f, \"remote_field\", None), \"parent_link\", False):\n+                        field = f\n+                        break\n+                if field is None:\n+                    # Fallback to the first available parent link.\n+                    field = parent_fields[0] if parent_fields else None\n+                # Look for a local field with the same name as the chosen parent link.\n+                if field is not None:\n+                    already_created = [fld for fld in self.local_fields if fld.name == field.name]\n+                    if already_created:\n+                        field = already_created[0]\n+                    field.primary_key = True\n+                    self.setup_pk(field)\n+                    if not getattr(getattr(field, \"remote_field\", None), \"parent_link\", False):\n+                        raise ImproperlyConfigured(\n+                            'Add parent_link=True to %s.' % field,\n+                        )\n             else:\n                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                 model.add_to_class('id', auto)\n"
  },
  "django__django-12406": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12406",
    "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex dafc11f995..361cac3896 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -14,7 +14,9 @@ from django.forms.formsets import BaseFormSet, formset_factory\n from django.forms.utils import ErrorList\n from django.forms.widgets import (\n     HiddenInput, MultipleHiddenInput, SelectMultiple,\n-)\n+\n+        RadioSelect,\n+    )\n from django.utils.text import capfirst, get_text_list\n from django.utils.translation import gettext, gettext_lazy as _\n \n@@ -1185,7 +1187,21 @@ class ModelChoiceField(ChoiceField):\n                  required=True, widget=None, label=None, initial=None,\n                  help_text='', to_field_name=None, limit_choices_to=None,\n                  **kwargs):\n-        if required and (initial is not None):\n+        # RadioSelect widgets have an inherent unfilled state, so avoid adding\n+        # an extra blank choice for required foreign keys when using radios.\n+        widget_is_radio = False\n+        try:\n+            # widget may be a widget instance or a widget class\n+            widget_is_radio = isinstance(widget, RadioSelect) or (\n+                isinstance(widget, type) and issubclass(widget, RadioSelect)\n+            )\n+        except Exception:\n+            widget_is_radio = False\n+\n+        if widget_is_radio:\n+            # Force no empty label for RadioSelect to prevent a misleading blank option.\n+            self.empty_label = None\n+        elif required and (initial is not None):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n"
  },
  "django__django-12708": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12708",
    "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..3a5c3d49ae 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,9 +403,13 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        # Avoid matching UNIQUE constraints when looking for non-unique indexes:\n+        _kwargs = dict(constraint_kwargs)\n+        if _kwargs.get('index', False) and 'unique' not in _kwargs:\n+            _kwargs['unique'] = False\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n"
  },
  "django__django-12713": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12713",
    "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 69a5fbf389..b3c4020f39 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -250,15 +250,16 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n         db = kwargs.get('using')\n \n         autocomplete_fields = self.get_autocomplete_fields(request)\n-        if db_field.name in autocomplete_fields:\n-            kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in self.raw_id_fields:\n-            kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n-            kwargs['widget'] = widgets.FilteredSelectMultiple(\n-                db_field.verbose_name,\n-                db_field.name in self.filter_vertical\n-            )\n+        if 'widget' not in kwargs:\n+            if db_field.name in autocomplete_fields:\n+                kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in self.raw_id_fields:\n+                kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n+                kwargs['widget'] = widgets.FilteredSelectMultiple(\n+                    db_field.verbose_name,\n+                    db_field.name in self.filter_vertical\n+                )\n \n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n"
  },
  "django__django-9296": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-9296",
    "model_patch": "diff --git a/django/core/paginator.py b/django/core/paginator.py\nindex 1f92da5d4f..896535d89a 100644\n--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -106,6 +106,10 @@ class Paginator:\n         \"\"\"\n         return range(1, self.num_pages + 1)\n \n+    def __iter__(self):\n+        for page_num in self.page_range:\n+            yield self.page(page_num)\n+\n     def _check_object_list_is_ordered(self):\n         \"\"\"\n         Warn if self.object_list is unordered (typically a QuerySet).\n"
  },
  "sphinx-doc__sphinx-10323": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10323",
    "model_patch": "diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py\nindex dc44ed314..8a51fa8f3 100644\n--- a/sphinx/directives/code.py\n+++ b/sphinx/directives/code.py\n@@ -224,9 +224,9 @@ class LiteralIncludeReader:\n                        self.start_filter,\n                        self.end_filter,\n                        self.lines_filter,\n+                       self.dedent_filter,\n                        self.prepend_filter,\n-                       self.append_filter,\n-                       self.dedent_filter]\n+                       self.append_filter]\n             lines = self.read_file(self.filename, location=location)\n             for func in filters:\n                 lines = func(lines, location=location)\n@@ -258,6 +258,7 @@ class LiteralIncludeReader:\n \n         return lines\n \n+\n     def lines_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n         linespec = self.options.get('lines')\n         if linespec:\n@@ -338,6 +339,7 @@ class LiteralIncludeReader:\n             else:\n                 raise ValueError('end-before pattern not found: %s' % end)\n \n+\n         return lines\n \n     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\ndiff --git a/test_pom.xml b/test_pom.xml\nnew file mode 100644\nindex 000000000..f7ecc68de\n--- /dev/null\n+++ b/test_pom.xml\n@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project>\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>3.8.0</version>\n+        <configuration>\n+          <source>1.8</source>\n+          <target>1.8</target>\n+          <debug>true</debug>\n+          <encoding>UTF-8</encoding>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <groupId>com.github.ekryd.sortpom</groupId>\n+        <artifactId>sortpom-maven-plugin</artifactId>\n+        <version>2.15.0</version>\n+        <configuration>\n+          <verifyFailOn>strict</verifyFailOn>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n"
  },
  "sphinx-doc__sphinx-10435": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10435",
    "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex e0c7d56f8..90f8a697a 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -1621,7 +1621,7 @@ class LaTeXTranslator(SphinxTranslator):\n         self.body.append(r'\\sphinxstyleliteralemphasis{\\sphinxupquote{')\n \n     def depart_literal_emphasis(self, node: Element) -> None:\n-        self.body.append('}}')\n+        self.body.append('%}}')\n \n     def visit_strong(self, node: Element) -> None:\n         self.body.append(r'\\sphinxstylestrong{')\n@@ -1633,7 +1633,7 @@ class LaTeXTranslator(SphinxTranslator):\n         self.body.append(r'\\sphinxstyleliteralstrong{\\sphinxupquote{')\n \n     def depart_literal_strong(self, node: Element) -> None:\n-        self.body.append('}}')\n+        self.body.append('%}}')\n \n     def visit_abbreviation(self, node: Element) -> None:\n         abbr = node.astext()\n@@ -1718,7 +1718,7 @@ class LaTeXTranslator(SphinxTranslator):\n         raise nodes.SkipNode\n \n     def depart_literal(self, node: Element) -> None:\n-        self.body.append('}}')\n+        self.body.append('%}}')\n \n     def visit_footnote_reference(self, node: Element) -> None:\n         raise nodes.SkipNode\n"
  },
  "sphinx-doc__sphinx-10466": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10466",
    "model_patch": "diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py\nindex e8bc547b7..682be1397 100644\n--- a/sphinx/builders/gettext.py\n+++ b/sphinx/builders/gettext.py\n@@ -32,10 +32,17 @@ class Message:\n     \"\"\"An entry of translatable message.\"\"\"\n     def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n         self.text = text\n-        self.locations = locations\n-        self.uuids = uuids\n-\n-\n+        # remove duplicate locations while preserving order and keep corresponding uuids\n+        seen = set()\n+        unique_locations = []\n+        unique_uuids = []\n+        for loc, uid in zip(locations, uuids):\n+            if loc not in seen:\n+                seen.add(loc)\n+                unique_locations.append(loc)\n+                unique_uuids.append(uid)\n+        self.locations = unique_locations\n+        self.uuids = unique_uuids\n class Catalog:\n     \"\"\"Catalog of translatable messages.\"\"\"\n \n"
  },
  "sphinx-doc__sphinx-11510": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-11510",
    "model_patch": "diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py\nindex 19f7c0a8d..65c7c8ab2 100644\n--- a/sphinx/directives/other.py\n+++ b/sphinx/directives/other.py\n@@ -366,17 +366,41 @@ class Include(BaseInclude, SphinxDirective):\n     \"\"\"\n     Like the standard \"Include\" directive, but interprets absolute paths\n     \"correctly\", i.e. relative to source directory.\n+\n+    Also emit 'source-read' event for included files so extensions can\n+    modify included content.\n     \"\"\"\n \n     def run(self) -> list[Node]:\n-        if self.arguments[0].startswith('<') and \\\n-           self.arguments[0].endswith('>'):\n+        if self.arguments[0].startswith('<') and self.arguments[0].endswith('>'):\n             # docutils \"standard\" includes, do not do path processing\n             return super().run()\n         rel_filename, filename = self.env.relfn2path(self.arguments[0])\n         self.arguments[0] = filename\n         self.env.note_included(filename)\n-        return super().run()\n+        # Monkey-patch docutils.io.FileInput.read to emit source-read for included files\n+        import docutils.io as _dio\n+        _orig_read = _dio.FileInput.read\n+        def _read_wrapper(self_):\n+            content = _orig_read(self_)\n+            env = getattr(_dio, '_sphinx_current_env', None)\n+            if env is not None:\n+                arg = [content]\n+                try:\n+                    docname = env.path2doc(self_.source_path) or self_.source_path\n+                except Exception:\n+                    docname = self_.source_path\n+                env.events.emit('source-read', docname, arg)\n+                return arg[0]\n+            return content\n+        try:\n+            _dio._sphinx_current_env = self.env\n+            _dio.FileInput.read = _read_wrapper\n+            return super().run()\n+        finally:\n+            _dio.FileInput.read = _orig_read\n+            if hasattr(_dio, '_sphinx_current_env'):\n+                delattr(_dio, '_sphinx_current_env')\n \n \n def setup(app: Sphinx) -> dict[str, Any]:\ndiff --git a/tmp_sphinx_test/_build/.buildinfo b/tmp_sphinx_test/_build/.buildinfo\nnew file mode 100644\nindex 000000000..26d440e31\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/.buildinfo\n@@ -0,0 +1,4 @@\n+# Sphinx build info version 1\n+# This file hashes the configuration used when building these files. When it is not found, a full rebuild will be done.\n+config: 3b01a0cf90889428e2d173b99ba5bd77\n+tags: 645f666f9bcd5a90fca523b33c5a78b7\ndiff --git a/tmp_sphinx_test/_build/.doctrees/environment.pickle b/tmp_sphinx_test/_build/.doctrees/environment.pickle\nnew file mode 100644\nindex 000000000..741e2941b\nBinary files /dev/null and b/tmp_sphinx_test/_build/.doctrees/environment.pickle differ\ndiff --git a/tmp_sphinx_test/_build/.doctrees/index.doctree b/tmp_sphinx_test/_build/.doctrees/index.doctree\nnew file mode 100644\nindex 000000000..91e41867e\nBinary files /dev/null and b/tmp_sphinx_test/_build/.doctrees/index.doctree differ\ndiff --git a/tmp_sphinx_test/_build/.doctrees/something-to-include.doctree b/tmp_sphinx_test/_build/.doctrees/something-to-include.doctree\nnew file mode 100644\nindex 000000000..327721948\nBinary files /dev/null and b/tmp_sphinx_test/_build/.doctrees/something-to-include.doctree differ\ndiff --git a/tmp_sphinx_test/_build/_sources/index.rst.txt b/tmp_sphinx_test/_build/_sources/index.rst.txt\nnew file mode 100644\nindex 000000000..f2dec1395\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_sources/index.rst.txt\n@@ -0,0 +1,6 @@\n+This is a test\n+==============\n+\n+.. include:: something-to-include.rst\n+\n+&REPLACE_ME;\ndiff --git a/tmp_sphinx_test/_build/_sources/something-to-include.rst.txt b/tmp_sphinx_test/_build/_sources/something-to-include.rst.txt\nnew file mode 100644\nindex 000000000..e63253568\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_sources/something-to-include.rst.txt\n@@ -0,0 +1,4 @@\n+Testing\n+=======\n+\n+&REPLACE_ME;\ndiff --git a/tmp_sphinx_test/_build/_static/alabaster.css b/tmp_sphinx_test/_build/_static/alabaster.css\nnew file mode 100644\nindex 000000000..e3174bf93\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/alabaster.css\n@@ -0,0 +1,708 @@\n+@import url(\"basic.css\");\n+\n+/* -- page layout ----------------------------------------------------------- */\n+\n+body {\n+    font-family: Georgia, serif;\n+    font-size: 17px;\n+    background-color: #fff;\n+    color: #000;\n+    margin: 0;\n+    padding: 0;\n+}\n+\n+\n+div.document {\n+    width: 940px;\n+    margin: 30px auto 0 auto;\n+}\n+\n+div.documentwrapper {\n+    float: left;\n+    width: 100%;\n+}\n+\n+div.bodywrapper {\n+    margin: 0 0 0 220px;\n+}\n+\n+div.sphinxsidebar {\n+    width: 220px;\n+    font-size: 14px;\n+    line-height: 1.5;\n+}\n+\n+hr {\n+    border: 1px solid #B1B4B6;\n+}\n+\n+div.body {\n+    background-color: #fff;\n+    color: #3E4349;\n+    padding: 0 30px 0 30px;\n+}\n+\n+div.body > .section {\n+    text-align: left;\n+}\n+\n+div.footer {\n+    width: 940px;\n+    margin: 20px auto 30px auto;\n+    font-size: 14px;\n+    color: #888;\n+    text-align: right;\n+}\n+\n+div.footer a {\n+    color: #888;\n+}\n+\n+p.caption {\n+    font-family: inherit;\n+    font-size: inherit;\n+}\n+\n+\n+div.relations {\n+    display: none;\n+}\n+\n+\n+div.sphinxsidebar {\n+    max-height: 100%;\n+    overflow-y: auto;\n+}\n+\n+div.sphinxsidebar a {\n+    color: #444;\n+    text-decoration: none;\n+    border-bottom: 1px dotted #999;\n+}\n+\n+div.sphinxsidebar a:hover {\n+    border-bottom: 1px solid #999;\n+}\n+\n+div.sphinxsidebarwrapper {\n+    padding: 18px 10px;\n+}\n+\n+div.sphinxsidebarwrapper p.logo {\n+    padding: 0;\n+    margin: -10px 0 0 0px;\n+    text-align: center;\n+}\n+\n+div.sphinxsidebarwrapper h1.logo {\n+    margin-top: -10px;\n+    text-align: center;\n+    margin-bottom: 5px;\n+    text-align: left;\n+}\n+\n+div.sphinxsidebarwrapper h1.logo-name {\n+    margin-top: 0px;\n+}\n+\n+div.sphinxsidebarwrapper p.blurb {\n+    margin-top: 0;\n+    font-style: normal;\n+}\n+\n+div.sphinxsidebar h3,\n+div.sphinxsidebar h4 {\n+    font-family: Georgia, serif;\n+    color: #444;\n+    font-size: 24px;\n+    font-weight: normal;\n+    margin: 0 0 5px 0;\n+    padding: 0;\n+}\n+\n+div.sphinxsidebar h4 {\n+    font-size: 20px;\n+}\n+\n+div.sphinxsidebar h3 a {\n+    color: #444;\n+}\n+\n+div.sphinxsidebar p.logo a,\n+div.sphinxsidebar h3 a,\n+div.sphinxsidebar p.logo a:hover,\n+div.sphinxsidebar h3 a:hover {\n+    border: none;\n+}\n+\n+div.sphinxsidebar p {\n+    color: #555;\n+    margin: 10px 0;\n+}\n+\n+div.sphinxsidebar ul {\n+    margin: 10px 0;\n+    padding: 0;\n+    color: #000;\n+}\n+\n+div.sphinxsidebar ul li.toctree-l1 > a {\n+    font-size: 120%;\n+}\n+\n+div.sphinxsidebar ul li.toctree-l2 > a {\n+    font-size: 110%;\n+}\n+\n+div.sphinxsidebar input {\n+    border: 1px solid #CCC;\n+    font-family: Georgia, serif;\n+    font-size: 1em;\n+}\n+\n+div.sphinxsidebar #searchbox input[type=\"text\"] {\n+    width: 160px;\n+}\n+\n+div.sphinxsidebar .search > div {\n+    display: table-cell;\n+}\n+\n+div.sphinxsidebar hr {\n+    border: none;\n+    height: 1px;\n+    color: #AAA;\n+    background: #AAA;\n+\n+    text-align: left;\n+    margin-left: 0;\n+    width: 50%;\n+}\n+\n+div.sphinxsidebar .badge {\n+    border-bottom: none;\n+}\n+\n+div.sphinxsidebar .badge:hover {\n+    border-bottom: none;\n+}\n+\n+/* To address an issue with donation coming after search */\n+div.sphinxsidebar h3.donation {\n+    margin-top: 10px;\n+}\n+\n+/* -- body styles ----------------------------------------------------------- */\n+\n+a {\n+    color: #004B6B;\n+    text-decoration: underline;\n+}\n+\n+a:hover {\n+    color: #6D4100;\n+    text-decoration: underline;\n+}\n+\n+div.body h1,\n+div.body h2,\n+div.body h3,\n+div.body h4,\n+div.body h5,\n+div.body h6 {\n+    font-family: Georgia, serif;\n+    font-weight: normal;\n+    margin: 30px 0px 10px 0px;\n+    padding: 0;\n+}\n+\n+div.body h1 { margin-top: 0; padding-top: 0; font-size: 240%; }\n+div.body h2 { font-size: 180%; }\n+div.body h3 { font-size: 150%; }\n+div.body h4 { font-size: 130%; }\n+div.body h5 { font-size: 100%; }\n+div.body h6 { font-size: 100%; }\n+\n+a.headerlink {\n+    color: #DDD;\n+    padding: 0 4px;\n+    text-decoration: none;\n+}\n+\n+a.headerlink:hover {\n+    color: #444;\n+    background: #EAEAEA;\n+}\n+\n+div.body p, div.body dd, div.body li {\n+    line-height: 1.4em;\n+}\n+\n+div.admonition {\n+    margin: 20px 0px;\n+    padding: 10px 30px;\n+    background-color: #EEE;\n+    border: 1px solid #CCC;\n+}\n+\n+div.admonition tt.xref, div.admonition code.xref, div.admonition a tt {\n+    background-color: #FBFBFB;\n+    border-bottom: 1px solid #fafafa;\n+}\n+\n+div.admonition p.admonition-title {\n+    font-family: Georgia, serif;\n+    font-weight: normal;\n+    font-size: 24px;\n+    margin: 0 0 10px 0;\n+    padding: 0;\n+    line-height: 1;\n+}\n+\n+div.admonition p.last {\n+    margin-bottom: 0;\n+}\n+\n+div.highlight {\n+    background-color: #fff;\n+}\n+\n+dt:target, .highlight {\n+    background: #FAF3E8;\n+}\n+\n+div.warning {\n+    background-color: #FCC;\n+    border: 1px solid #FAA;\n+}\n+\n+div.danger {\n+    background-color: #FCC;\n+    border: 1px solid #FAA;\n+    -moz-box-shadow: 2px 2px 4px #D52C2C;\n+    -webkit-box-shadow: 2px 2px 4px #D52C2C;\n+    box-shadow: 2px 2px 4px #D52C2C;\n+}\n+\n+div.error {\n+    background-color: #FCC;\n+    border: 1px solid #FAA;\n+    -moz-box-shadow: 2px 2px 4px #D52C2C;\n+    -webkit-box-shadow: 2px 2px 4px #D52C2C;\n+    box-shadow: 2px 2px 4px #D52C2C;\n+}\n+\n+div.caution {\n+    background-color: #FCC;\n+    border: 1px solid #FAA;\n+}\n+\n+div.attention {\n+    background-color: #FCC;\n+    border: 1px solid #FAA;\n+}\n+\n+div.important {\n+    background-color: #EEE;\n+    border: 1px solid #CCC;\n+}\n+\n+div.note {\n+    background-color: #EEE;\n+    border: 1px solid #CCC;\n+}\n+\n+div.tip {\n+    background-color: #EEE;\n+    border: 1px solid #CCC;\n+}\n+\n+div.hint {\n+    background-color: #EEE;\n+    border: 1px solid #CCC;\n+}\n+\n+div.seealso {\n+    background-color: #EEE;\n+    border: 1px solid #CCC;\n+}\n+\n+div.topic {\n+    background-color: #EEE;\n+}\n+\n+p.admonition-title {\n+    display: inline;\n+}\n+\n+p.admonition-title:after {\n+    content: \":\";\n+}\n+\n+pre, tt, code {\n+    font-family: 'Consolas', 'Menlo', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', monospace;\n+    font-size: 0.9em;\n+}\n+\n+.hll {\n+    background-color: #FFC;\n+    margin: 0 -12px;\n+    padding: 0 12px;\n+    display: block;\n+}\n+\n+img.screenshot {\n+}\n+\n+tt.descname, tt.descclassname, code.descname, code.descclassname {\n+    font-size: 0.95em;\n+}\n+\n+tt.descname, code.descname {\n+    padding-right: 0.08em;\n+}\n+\n+img.screenshot {\n+    -moz-box-shadow: 2px 2px 4px #EEE;\n+    -webkit-box-shadow: 2px 2px 4px #EEE;\n+    box-shadow: 2px 2px 4px #EEE;\n+}\n+\n+table.docutils {\n+    border: 1px solid #888;\n+    -moz-box-shadow: 2px 2px 4px #EEE;\n+    -webkit-box-shadow: 2px 2px 4px #EEE;\n+    box-shadow: 2px 2px 4px #EEE;\n+}\n+\n+table.docutils td, table.docutils th {\n+    border: 1px solid #888;\n+    padding: 0.25em 0.7em;\n+}\n+\n+table.field-list, table.footnote {\n+    border: none;\n+    -moz-box-shadow: none;\n+    -webkit-box-shadow: none;\n+    box-shadow: none;\n+}\n+\n+table.footnote {\n+    margin: 15px 0;\n+    width: 100%;\n+    border: 1px solid #EEE;\n+    background: #FDFDFD;\n+    font-size: 0.9em;\n+}\n+\n+table.footnote + table.footnote {\n+    margin-top: -15px;\n+    border-top: none;\n+}\n+\n+table.field-list th {\n+    padding: 0 0.8em 0 0;\n+}\n+\n+table.field-list td {\n+    padding: 0;\n+}\n+\n+table.field-list p {\n+    margin-bottom: 0.8em;\n+}\n+\n+/* Cloned from\n+ * https://github.com/sphinx-doc/sphinx/commit/ef60dbfce09286b20b7385333d63a60321784e68\n+ */\n+.field-name {\n+    -moz-hyphens: manual;\n+    -ms-hyphens: manual;\n+    -webkit-hyphens: manual;\n+    hyphens: manual;\n+}\n+\n+table.footnote td.label {\n+    width: .1px;\n+    padding: 0.3em 0 0.3em 0.5em;\n+}\n+\n+table.footnote td {\n+    padding: 0.3em 0.5em;\n+}\n+\n+dl {\n+    margin-left: 0;\n+    margin-right: 0;\n+    margin-top: 0;\n+    padding: 0;\n+}\n+\n+dl dd {\n+    margin-left: 30px;\n+}\n+\n+blockquote {\n+    margin: 0 0 0 30px;\n+    padding: 0;\n+}\n+\n+ul, ol {\n+    /* Matches the 30px from the narrow-screen \"li > ul\" selector below */\n+    margin: 10px 0 10px 30px;\n+    padding: 0;\n+}\n+\n+pre {\n+    background: #EEE;\n+    padding: 7px 30px;\n+    margin: 15px 0px;\n+    line-height: 1.3em;\n+}\n+\n+div.viewcode-block:target {\n+    background: #ffd;\n+}\n+\n+dl pre, blockquote pre, li pre {\n+    margin-left: 0;\n+    padding-left: 30px;\n+}\n+\n+tt, code {\n+    background-color: #ecf0f3;\n+    color: #222;\n+    /* padding: 1px 2px; */\n+}\n+\n+tt.xref, code.xref, a tt {\n+    background-color: #FBFBFB;\n+    border-bottom: 1px solid #fff;\n+}\n+\n+a.reference {\n+    text-decoration: none;\n+    border-bottom: 1px dotted #004B6B;\n+}\n+\n+/* Don't put an underline on images */\n+a.image-reference, a.image-reference:hover {\n+    border-bottom: none;\n+}\n+\n+a.reference:hover {\n+    border-bottom: 1px solid #6D4100;\n+}\n+\n+a.footnote-reference {\n+    text-decoration: none;\n+    font-size: 0.7em;\n+    vertical-align: top;\n+    border-bottom: 1px dotted #004B6B;\n+}\n+\n+a.footnote-reference:hover {\n+    border-bottom: 1px solid #6D4100;\n+}\n+\n+a:hover tt, a:hover code {\n+    background: #EEE;\n+}\n+\n+\n+@media screen and (max-width: 870px) {\n+\n+    div.sphinxsidebar {\n+    \tdisplay: none;\n+    }\n+\n+    div.document {\n+       width: 100%;\n+\n+    }\n+\n+    div.documentwrapper {\n+    \tmargin-left: 0;\n+    \tmargin-top: 0;\n+    \tmargin-right: 0;\n+    \tmargin-bottom: 0;\n+    }\n+\n+    div.bodywrapper {\n+    \tmargin-top: 0;\n+    \tmargin-right: 0;\n+    \tmargin-bottom: 0;\n+    \tmargin-left: 0;\n+    }\n+\n+    ul {\n+    \tmargin-left: 0;\n+    }\n+\n+\tli > ul {\n+        /* Matches the 30px from the \"ul, ol\" selector above */\n+\t\tmargin-left: 30px;\n+\t}\n+\n+    .document {\n+    \twidth: auto;\n+    }\n+\n+    .footer {\n+    \twidth: auto;\n+    }\n+\n+    .bodywrapper {\n+    \tmargin: 0;\n+    }\n+\n+    .footer {\n+    \twidth: auto;\n+    }\n+\n+    .github {\n+        display: none;\n+    }\n+\n+\n+\n+}\n+\n+\n+\n+@media screen and (max-width: 875px) {\n+\n+    body {\n+        margin: 0;\n+        padding: 20px 30px;\n+    }\n+\n+    div.documentwrapper {\n+        float: none;\n+        background: #fff;\n+    }\n+\n+    div.sphinxsidebar {\n+        display: block;\n+        float: none;\n+        width: 102.5%;\n+        margin: 50px -30px -20px -30px;\n+        padding: 10px 20px;\n+        background: #333;\n+        color: #FFF;\n+    }\n+\n+    div.sphinxsidebar h3, div.sphinxsidebar h4, div.sphinxsidebar p,\n+    div.sphinxsidebar h3 a {\n+        color: #fff;\n+    }\n+\n+    div.sphinxsidebar a {\n+        color: #AAA;\n+    }\n+\n+    div.sphinxsidebar p.logo {\n+        display: none;\n+    }\n+\n+    div.document {\n+        width: 100%;\n+        margin: 0;\n+    }\n+\n+    div.footer {\n+        display: none;\n+    }\n+\n+    div.bodywrapper {\n+        margin: 0;\n+    }\n+\n+    div.body {\n+        min-height: 0;\n+        padding: 0;\n+    }\n+\n+    .rtd_doc_footer {\n+        display: none;\n+    }\n+\n+    .document {\n+        width: auto;\n+    }\n+\n+    .footer {\n+        width: auto;\n+    }\n+\n+    .footer {\n+        width: auto;\n+    }\n+\n+    .github {\n+        display: none;\n+    }\n+}\n+\n+\n+/* misc. */\n+\n+.revsys-inline {\n+    display: none!important;\n+}\n+\n+/* Hide ugly table cell borders in ..bibliography:: directive output */\n+table.docutils.citation, table.docutils.citation td, table.docutils.citation th {\n+  border: none;\n+  /* Below needed in some edge cases; if not applied, bottom shadows appear */\n+  -moz-box-shadow: none;\n+  -webkit-box-shadow: none;\n+  box-shadow: none;\n+}\n+\n+\n+/* relbar */\n+\n+.related {\n+    line-height: 30px;\n+    width: 100%;\n+    font-size: 0.9rem;\n+}\n+\n+.related.top {\n+    border-bottom: 1px solid #EEE;\n+    margin-bottom: 20px;\n+}\n+\n+.related.bottom {\n+    border-top: 1px solid #EEE;\n+}\n+\n+.related ul {\n+    padding: 0;\n+    margin: 0;\n+    list-style: none;\n+}\n+\n+.related li {\n+    display: inline;\n+}\n+\n+nav#rellinks {\n+    float: right;\n+}\n+\n+nav#rellinks li+li:before {\n+    content: \"|\";\n+}\n+\n+nav#breadcrumbs li+li:before {\n+    content: \"\\00BB\";\n+}\n+\n+/* Hide certain items when printing */\n+@media print {\n+    div.related {\n+        display: none;\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/_static/basic.css b/tmp_sphinx_test/_build/_static/basic.css\nnew file mode 100644\nindex 000000000..4157edf27\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/basic.css\n@@ -0,0 +1,925 @@\n+/*\n+ * basic.css\n+ * ~~~~~~~~~\n+ *\n+ * Sphinx stylesheet -- basic theme.\n+ *\n+ * :copyright: Copyright 2007-2023 by the Sphinx team, see AUTHORS.\n+ * :license: BSD, see LICENSE for details.\n+ *\n+ */\n+\n+/* -- main layout ----------------------------------------------------------- */\n+\n+div.clearer {\n+    clear: both;\n+}\n+\n+div.section::after {\n+    display: block;\n+    content: '';\n+    clear: left;\n+}\n+\n+/* -- relbar ---------------------------------------------------------------- */\n+\n+div.related {\n+    width: 100%;\n+    font-size: 90%;\n+}\n+\n+div.related h3 {\n+    display: none;\n+}\n+\n+div.related ul {\n+    margin: 0;\n+    padding: 0 0 0 10px;\n+    list-style: none;\n+}\n+\n+div.related li {\n+    display: inline;\n+}\n+\n+div.related li.right {\n+    float: right;\n+    margin-right: 5px;\n+}\n+\n+/* -- sidebar --------------------------------------------------------------- */\n+\n+div.sphinxsidebarwrapper {\n+    padding: 10px 5px 0 10px;\n+}\n+\n+div.sphinxsidebar {\n+    float: left;\n+    width: 230px;\n+    margin-left: -100%;\n+    font-size: 90%;\n+    word-wrap: break-word;\n+    overflow-wrap : break-word;\n+}\n+\n+div.sphinxsidebar ul {\n+    list-style: none;\n+}\n+\n+div.sphinxsidebar ul ul,\n+div.sphinxsidebar ul.want-points {\n+    margin-left: 20px;\n+    list-style: square;\n+}\n+\n+div.sphinxsidebar ul ul {\n+    margin-top: 0;\n+    margin-bottom: 0;\n+}\n+\n+div.sphinxsidebar form {\n+    margin-top: 10px;\n+}\n+\n+div.sphinxsidebar input {\n+    border: 1px solid #98dbcc;\n+    font-family: sans-serif;\n+    font-size: 1em;\n+}\n+\n+div.sphinxsidebar #searchbox form.search {\n+    overflow: hidden;\n+}\n+\n+div.sphinxsidebar #searchbox input[type=\"text\"] {\n+    float: left;\n+    width: 80%;\n+    padding: 0.25em;\n+    box-sizing: border-box;\n+}\n+\n+div.sphinxsidebar #searchbox input[type=\"submit\"] {\n+    float: left;\n+    width: 20%;\n+    border-left: none;\n+    padding: 0.25em;\n+    box-sizing: border-box;\n+}\n+\n+\n+img {\n+    border: 0;\n+    max-width: 100%;\n+}\n+\n+/* -- search page ----------------------------------------------------------- */\n+\n+ul.search {\n+    margin: 10px 0 0 20px;\n+    padding: 0;\n+}\n+\n+ul.search li {\n+    padding: 5px 0 5px 20px;\n+    background-image: url(file.png);\n+    background-repeat: no-repeat;\n+    background-position: 0 7px;\n+}\n+\n+ul.search li a {\n+    font-weight: bold;\n+}\n+\n+ul.search li p.context {\n+    color: #888;\n+    margin: 2px 0 0 30px;\n+    text-align: left;\n+}\n+\n+ul.keywordmatches li.goodmatch a {\n+    font-weight: bold;\n+}\n+\n+/* -- index page ------------------------------------------------------------ */\n+\n+table.contentstable {\n+    width: 90%;\n+    margin-left: auto;\n+    margin-right: auto;\n+}\n+\n+table.contentstable p.biglink {\n+    line-height: 150%;\n+}\n+\n+a.biglink {\n+    font-size: 1.3em;\n+}\n+\n+span.linkdescr {\n+    font-style: italic;\n+    padding-top: 5px;\n+    font-size: 90%;\n+}\n+\n+/* -- general index --------------------------------------------------------- */\n+\n+table.indextable {\n+    width: 100%;\n+}\n+\n+table.indextable td {\n+    text-align: left;\n+    vertical-align: top;\n+}\n+\n+table.indextable ul {\n+    margin-top: 0;\n+    margin-bottom: 0;\n+    list-style-type: none;\n+}\n+\n+table.indextable > tbody > tr > td > ul {\n+    padding-left: 0em;\n+}\n+\n+table.indextable tr.pcap {\n+    height: 10px;\n+}\n+\n+table.indextable tr.cap {\n+    margin-top: 10px;\n+    background-color: #f2f2f2;\n+}\n+\n+img.toggler {\n+    margin-right: 3px;\n+    margin-top: 3px;\n+    cursor: pointer;\n+}\n+\n+div.modindex-jumpbox {\n+    border-top: 1px solid #ddd;\n+    border-bottom: 1px solid #ddd;\n+    margin: 1em 0 1em 0;\n+    padding: 0.4em;\n+}\n+\n+div.genindex-jumpbox {\n+    border-top: 1px solid #ddd;\n+    border-bottom: 1px solid #ddd;\n+    margin: 1em 0 1em 0;\n+    padding: 0.4em;\n+}\n+\n+/* -- domain module index --------------------------------------------------- */\n+\n+table.modindextable td {\n+    padding: 2px;\n+    border-collapse: collapse;\n+}\n+\n+/* -- general body styles --------------------------------------------------- */\n+\n+div.body {\n+    min-width: inherit;\n+    max-width: 800px;\n+}\n+\n+div.body p, div.body dd, div.body li, div.body blockquote {\n+    -moz-hyphens: auto;\n+    -ms-hyphens: auto;\n+    -webkit-hyphens: auto;\n+    hyphens: auto;\n+}\n+\n+a.headerlink {\n+    visibility: hidden;\n+}\n+\n+a:visited {\n+    color: #551A8B;\n+}\n+\n+h1:hover > a.headerlink,\n+h2:hover > a.headerlink,\n+h3:hover > a.headerlink,\n+h4:hover > a.headerlink,\n+h5:hover > a.headerlink,\n+h6:hover > a.headerlink,\n+dt:hover > a.headerlink,\n+caption:hover > a.headerlink,\n+p.caption:hover > a.headerlink,\n+div.code-block-caption:hover > a.headerlink {\n+    visibility: visible;\n+}\n+\n+div.body p.caption {\n+    text-align: inherit;\n+}\n+\n+div.body td {\n+    text-align: left;\n+}\n+\n+.first {\n+    margin-top: 0 !important;\n+}\n+\n+p.rubric {\n+    margin-top: 30px;\n+    font-weight: bold;\n+}\n+\n+img.align-left, figure.align-left, .figure.align-left, object.align-left {\n+    clear: left;\n+    float: left;\n+    margin-right: 1em;\n+}\n+\n+img.align-right, figure.align-right, .figure.align-right, object.align-right {\n+    clear: right;\n+    float: right;\n+    margin-left: 1em;\n+}\n+\n+img.align-center, figure.align-center, .figure.align-center, object.align-center {\n+  display: block;\n+  margin-left: auto;\n+  margin-right: auto;\n+}\n+\n+img.align-default, figure.align-default, .figure.align-default {\n+  display: block;\n+  margin-left: auto;\n+  margin-right: auto;\n+}\n+\n+.align-left {\n+    text-align: left;\n+}\n+\n+.align-center {\n+    text-align: center;\n+}\n+\n+.align-default {\n+    text-align: center;\n+}\n+\n+.align-right {\n+    text-align: right;\n+}\n+\n+/* -- sidebars -------------------------------------------------------------- */\n+\n+div.sidebar,\n+aside.sidebar {\n+    margin: 0 0 0.5em 1em;\n+    border: 1px solid #ddb;\n+    padding: 7px;\n+    background-color: #ffe;\n+    width: 40%;\n+    float: right;\n+    clear: right;\n+    overflow-x: auto;\n+}\n+\n+p.sidebar-title {\n+    font-weight: bold;\n+}\n+\n+nav.contents,\n+aside.topic,\n+div.admonition, div.topic, blockquote {\n+    clear: left;\n+}\n+\n+/* -- topics ---------------------------------------------------------------- */\n+\n+nav.contents,\n+aside.topic,\n+div.topic {\n+    border: 1px solid #ccc;\n+    padding: 7px;\n+    margin: 10px 0 10px 0;\n+}\n+\n+p.topic-title {\n+    font-size: 1.1em;\n+    font-weight: bold;\n+    margin-top: 10px;\n+}\n+\n+/* -- admonitions ----------------------------------------------------------- */\n+\n+div.admonition {\n+    margin-top: 10px;\n+    margin-bottom: 10px;\n+    padding: 7px;\n+}\n+\n+div.admonition dt {\n+    font-weight: bold;\n+}\n+\n+p.admonition-title {\n+    margin: 0px 10px 5px 0px;\n+    font-weight: bold;\n+}\n+\n+div.body p.centered {\n+    text-align: center;\n+    margin-top: 25px;\n+}\n+\n+/* -- content of sidebars/topics/admonitions -------------------------------- */\n+\n+div.sidebar > :last-child,\n+aside.sidebar > :last-child,\n+nav.contents > :last-child,\n+aside.topic > :last-child,\n+div.topic > :last-child,\n+div.admonition > :last-child {\n+    margin-bottom: 0;\n+}\n+\n+div.sidebar::after,\n+aside.sidebar::after,\n+nav.contents::after,\n+aside.topic::after,\n+div.topic::after,\n+div.admonition::after,\n+blockquote::after {\n+    display: block;\n+    content: '';\n+    clear: both;\n+}\n+\n+/* -- tables ---------------------------------------------------------------- */\n+\n+table.docutils {\n+    margin-top: 10px;\n+    margin-bottom: 10px;\n+    border: 0;\n+    border-collapse: collapse;\n+}\n+\n+table.align-center {\n+    margin-left: auto;\n+    margin-right: auto;\n+}\n+\n+table.align-default {\n+    margin-left: auto;\n+    margin-right: auto;\n+}\n+\n+table caption span.caption-number {\n+    font-style: italic;\n+}\n+\n+table caption span.caption-text {\n+}\n+\n+table.docutils td, table.docutils th {\n+    padding: 1px 8px 1px 5px;\n+    border-top: 0;\n+    border-left: 0;\n+    border-right: 0;\n+    border-bottom: 1px solid #aaa;\n+}\n+\n+th {\n+    text-align: left;\n+    padding-right: 5px;\n+}\n+\n+table.citation {\n+    border-left: solid 1px gray;\n+    margin-left: 1px;\n+}\n+\n+table.citation td {\n+    border-bottom: none;\n+}\n+\n+th > :first-child,\n+td > :first-child {\n+    margin-top: 0px;\n+}\n+\n+th > :last-child,\n+td > :last-child {\n+    margin-bottom: 0px;\n+}\n+\n+/* -- figures --------------------------------------------------------------- */\n+\n+div.figure, figure {\n+    margin: 0.5em;\n+    padding: 0.5em;\n+}\n+\n+div.figure p.caption, figcaption {\n+    padding: 0.3em;\n+}\n+\n+div.figure p.caption span.caption-number,\n+figcaption span.caption-number {\n+    font-style: italic;\n+}\n+\n+div.figure p.caption span.caption-text,\n+figcaption span.caption-text {\n+}\n+\n+/* -- field list styles ----------------------------------------------------- */\n+\n+table.field-list td, table.field-list th {\n+    border: 0 !important;\n+}\n+\n+.field-list ul {\n+    margin: 0;\n+    padding-left: 1em;\n+}\n+\n+.field-list p {\n+    margin: 0;\n+}\n+\n+.field-name {\n+    -moz-hyphens: manual;\n+    -ms-hyphens: manual;\n+    -webkit-hyphens: manual;\n+    hyphens: manual;\n+}\n+\n+/* -- hlist styles ---------------------------------------------------------- */\n+\n+table.hlist {\n+    margin: 1em 0;\n+}\n+\n+table.hlist td {\n+    vertical-align: top;\n+}\n+\n+/* -- object description styles --------------------------------------------- */\n+\n+.sig {\n+\tfont-family: 'Consolas', 'Menlo', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', monospace;\n+}\n+\n+.sig-name, code.descname {\n+    background-color: transparent;\n+    font-weight: bold;\n+}\n+\n+.sig-name {\n+\tfont-size: 1.1em;\n+}\n+\n+code.descname {\n+    font-size: 1.2em;\n+}\n+\n+.sig-prename, code.descclassname {\n+    background-color: transparent;\n+}\n+\n+.optional {\n+    font-size: 1.3em;\n+}\n+\n+.sig-paren {\n+    font-size: larger;\n+}\n+\n+.sig-param.n {\n+\tfont-style: italic;\n+}\n+\n+/* C++ specific styling */\n+\n+.sig-inline.c-texpr,\n+.sig-inline.cpp-texpr {\n+\tfont-family: unset;\n+}\n+\n+.sig.c   .k, .sig.c   .kt,\n+.sig.cpp .k, .sig.cpp .kt {\n+\tcolor: #0033B3;\n+}\n+\n+.sig.c   .m,\n+.sig.cpp .m {\n+\tcolor: #1750EB;\n+}\n+\n+.sig.c   .s, .sig.c   .sc,\n+.sig.cpp .s, .sig.cpp .sc {\n+\tcolor: #067D17;\n+}\n+\n+\n+/* -- other body styles ----------------------------------------------------- */\n+\n+ol.arabic {\n+    list-style: decimal;\n+}\n+\n+ol.loweralpha {\n+    list-style: lower-alpha;\n+}\n+\n+ol.upperalpha {\n+    list-style: upper-alpha;\n+}\n+\n+ol.lowerroman {\n+    list-style: lower-roman;\n+}\n+\n+ol.upperroman {\n+    list-style: upper-roman;\n+}\n+\n+:not(li) > ol > li:first-child > :first-child,\n+:not(li) > ul > li:first-child > :first-child {\n+    margin-top: 0px;\n+}\n+\n+:not(li) > ol > li:last-child > :last-child,\n+:not(li) > ul > li:last-child > :last-child {\n+    margin-bottom: 0px;\n+}\n+\n+ol.simple ol p,\n+ol.simple ul p,\n+ul.simple ol p,\n+ul.simple ul p {\n+    margin-top: 0;\n+}\n+\n+ol.simple > li:not(:first-child) > p,\n+ul.simple > li:not(:first-child) > p {\n+    margin-top: 0;\n+}\n+\n+ol.simple p,\n+ul.simple p {\n+    margin-bottom: 0;\n+}\n+\n+aside.footnote > span,\n+div.citation > span {\n+    float: left;\n+}\n+aside.footnote > span:last-of-type,\n+div.citation > span:last-of-type {\n+  padding-right: 0.5em;\n+}\n+aside.footnote > p {\n+  margin-left: 2em;\n+}\n+div.citation > p {\n+  margin-left: 4em;\n+}\n+aside.footnote > p:last-of-type,\n+div.citation > p:last-of-type {\n+    margin-bottom: 0em;\n+}\n+aside.footnote > p:last-of-type:after,\n+div.citation > p:last-of-type:after {\n+    content: \"\";\n+    clear: both;\n+}\n+\n+dl.field-list {\n+    display: grid;\n+    grid-template-columns: fit-content(30%) auto;\n+}\n+\n+dl.field-list > dt {\n+    font-weight: bold;\n+    word-break: break-word;\n+    padding-left: 0.5em;\n+    padding-right: 5px;\n+}\n+\n+dl.field-list > dd {\n+    padding-left: 0.5em;\n+    margin-top: 0em;\n+    margin-left: 0em;\n+    margin-bottom: 0em;\n+}\n+\n+dl {\n+    margin-bottom: 15px;\n+}\n+\n+dd > :first-child {\n+    margin-top: 0px;\n+}\n+\n+dd ul, dd table {\n+    margin-bottom: 10px;\n+}\n+\n+dd {\n+    margin-top: 3px;\n+    margin-bottom: 10px;\n+    margin-left: 30px;\n+}\n+\n+.sig dd {\n+    margin-top: 0px;\n+    margin-bottom: 0px;\n+}\n+\n+.sig dl {\n+    margin-top: 0px;\n+    margin-bottom: 0px;\n+}\n+\n+dl > dd:last-child,\n+dl > dd:last-child > :last-child {\n+    margin-bottom: 0;\n+}\n+\n+dt:target, span.highlighted {\n+    background-color: #fbe54e;\n+}\n+\n+rect.highlighted {\n+    fill: #fbe54e;\n+}\n+\n+dl.glossary dt {\n+    font-weight: bold;\n+    font-size: 1.1em;\n+}\n+\n+.versionmodified {\n+    font-style: italic;\n+}\n+\n+.system-message {\n+    background-color: #fda;\n+    padding: 5px;\n+    border: 3px solid red;\n+}\n+\n+.footnote:target  {\n+    background-color: #ffa;\n+}\n+\n+.line-block {\n+    display: block;\n+    margin-top: 1em;\n+    margin-bottom: 1em;\n+}\n+\n+.line-block .line-block {\n+    margin-top: 0;\n+    margin-bottom: 0;\n+    margin-left: 1.5em;\n+}\n+\n+.guilabel, .menuselection {\n+    font-family: sans-serif;\n+}\n+\n+.accelerator {\n+    text-decoration: underline;\n+}\n+\n+.classifier {\n+    font-style: oblique;\n+}\n+\n+.classifier:before {\n+    font-style: normal;\n+    margin: 0 0.5em;\n+    content: \":\";\n+    display: inline-block;\n+}\n+\n+abbr, acronym {\n+    border-bottom: dotted 1px;\n+    cursor: help;\n+}\n+\n+.translated {\n+    background-color: rgba(207, 255, 207, 0.2)\n+}\n+\n+.untranslated {\n+    background-color: rgba(255, 207, 207, 0.2)\n+}\n+\n+/* -- code displays --------------------------------------------------------- */\n+\n+pre {\n+    overflow: auto;\n+    overflow-y: hidden;  /* fixes display issues on Chrome browsers */\n+}\n+\n+pre, div[class*=\"highlight-\"] {\n+    clear: both;\n+}\n+\n+span.pre {\n+    -moz-hyphens: none;\n+    -ms-hyphens: none;\n+    -webkit-hyphens: none;\n+    hyphens: none;\n+    white-space: nowrap;\n+}\n+\n+div[class*=\"highlight-\"] {\n+    margin: 1em 0;\n+}\n+\n+td.linenos pre {\n+    border: 0;\n+    background-color: transparent;\n+    color: #aaa;\n+}\n+\n+table.highlighttable {\n+    display: block;\n+}\n+\n+table.highlighttable tbody {\n+    display: block;\n+}\n+\n+table.highlighttable tr {\n+    display: flex;\n+}\n+\n+table.highlighttable td {\n+    margin: 0;\n+    padding: 0;\n+}\n+\n+table.highlighttable td.linenos {\n+    padding-right: 0.5em;\n+}\n+\n+table.highlighttable td.code {\n+    flex: 1;\n+    overflow: hidden;\n+}\n+\n+.highlight .hll {\n+    display: block;\n+}\n+\n+div.highlight pre,\n+table.highlighttable pre {\n+    margin: 0;\n+}\n+\n+div.code-block-caption + div {\n+    margin-top: 0;\n+}\n+\n+div.code-block-caption {\n+    margin-top: 1em;\n+    padding: 2px 5px;\n+    font-size: small;\n+}\n+\n+div.code-block-caption code {\n+    background-color: transparent;\n+}\n+\n+table.highlighttable td.linenos,\n+span.linenos,\n+div.highlight span.gp {  /* gp: Generic.Prompt */\n+  user-select: none;\n+  -webkit-user-select: text; /* Safari fallback only */\n+  -webkit-user-select: none; /* Chrome/Safari */\n+  -moz-user-select: none; /* Firefox */\n+  -ms-user-select: none; /* IE10+ */\n+}\n+\n+div.code-block-caption span.caption-number {\n+    padding: 0.1em 0.3em;\n+    font-style: italic;\n+}\n+\n+div.code-block-caption span.caption-text {\n+}\n+\n+div.literal-block-wrapper {\n+    margin: 1em 0;\n+}\n+\n+code.xref, a code {\n+    background-color: transparent;\n+    font-weight: bold;\n+}\n+\n+h1 code, h2 code, h3 code, h4 code, h5 code, h6 code {\n+    background-color: transparent;\n+}\n+\n+.viewcode-link {\n+    float: right;\n+}\n+\n+.viewcode-back {\n+    float: right;\n+    font-family: sans-serif;\n+}\n+\n+div.viewcode-block:target {\n+    margin: -1px -10px;\n+    padding: 0 10px;\n+}\n+\n+/* -- math display ---------------------------------------------------------- */\n+\n+img.math {\n+    vertical-align: middle;\n+}\n+\n+div.body div.math p {\n+    text-align: center;\n+}\n+\n+span.eqno {\n+    float: right;\n+}\n+\n+span.eqno a.headerlink {\n+    position: absolute;\n+    z-index: 1;\n+}\n+\n+div.math:hover a.headerlink {\n+    visibility: visible;\n+}\n+\n+/* -- printout stylesheet --------------------------------------------------- */\n+\n+@media print {\n+    div.document,\n+    div.documentwrapper,\n+    div.bodywrapper {\n+        margin: 0 !important;\n+        width: 100%;\n+    }\n+\n+    div.sphinxsidebar,\n+    div.related,\n+    div.footer,\n+    #top-link {\n+        display: none;\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/_static/custom.css b/tmp_sphinx_test/_build/_static/custom.css\nnew file mode 100644\nindex 000000000..2a924f1d6\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/custom.css\n@@ -0,0 +1 @@\n+/* This file intentionally left blank. */\ndiff --git a/tmp_sphinx_test/_build/_static/doctools.js b/tmp_sphinx_test/_build/_static/doctools.js\nnew file mode 100644\nindex 000000000..d06a71d75\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/doctools.js\n@@ -0,0 +1,156 @@\n+/*\n+ * doctools.js\n+ * ~~~~~~~~~~~\n+ *\n+ * Base JavaScript utilities for all Sphinx HTML documentation.\n+ *\n+ * :copyright: Copyright 2007-2023 by the Sphinx team, see AUTHORS.\n+ * :license: BSD, see LICENSE for details.\n+ *\n+ */\n+\"use strict\";\n+\n+const BLACKLISTED_KEY_CONTROL_ELEMENTS = new Set([\n+  \"TEXTAREA\",\n+  \"INPUT\",\n+  \"SELECT\",\n+  \"BUTTON\",\n+]);\n+\n+const _ready = (callback) => {\n+  if (document.readyState !== \"loading\") {\n+    callback();\n+  } else {\n+    document.addEventListener(\"DOMContentLoaded\", callback);\n+  }\n+};\n+\n+/**\n+ * Small JavaScript module for the documentation.\n+ */\n+const Documentation = {\n+  init: () => {\n+    Documentation.initDomainIndexTable();\n+    Documentation.initOnKeyListeners();\n+  },\n+\n+  /**\n+   * i18n support\n+   */\n+  TRANSLATIONS: {},\n+  PLURAL_EXPR: (n) => (n === 1 ? 0 : 1),\n+  LOCALE: \"unknown\",\n+\n+  // gettext and ngettext don't access this so that the functions\n+  // can safely bound to a different name (_ = Documentation.gettext)\n+  gettext: (string) => {\n+    const translated = Documentation.TRANSLATIONS[string];\n+    switch (typeof translated) {\n+      case \"undefined\":\n+        return string; // no translation\n+      case \"string\":\n+        return translated; // translation exists\n+      default:\n+        return translated[0]; // (singular, plural) translation tuple exists\n+    }\n+  },\n+\n+  ngettext: (singular, plural, n) => {\n+    const translated = Documentation.TRANSLATIONS[singular];\n+    if (typeof translated !== \"undefined\")\n+      return translated[Documentation.PLURAL_EXPR(n)];\n+    return n === 1 ? singular : plural;\n+  },\n+\n+  addTranslations: (catalog) => {\n+    Object.assign(Documentation.TRANSLATIONS, catalog.messages);\n+    Documentation.PLURAL_EXPR = new Function(\n+      \"n\",\n+      `return (${catalog.plural_expr})`\n+    );\n+    Documentation.LOCALE = catalog.locale;\n+  },\n+\n+  /**\n+   * helper function to focus on search bar\n+   */\n+  focusSearchBar: () => {\n+    document.querySelectorAll(\"input[name=q]\")[0]?.focus();\n+  },\n+\n+  /**\n+   * Initialise the domain index toggle buttons\n+   */\n+  initDomainIndexTable: () => {\n+    const toggler = (el) => {\n+      const idNumber = el.id.substr(7);\n+      const toggledRows = document.querySelectorAll(`tr.cg-${idNumber}`);\n+      if (el.src.substr(-9) === \"minus.png\") {\n+        el.src = `${el.src.substr(0, el.src.length - 9)}plus.png`;\n+        toggledRows.forEach((el) => (el.style.display = \"none\"));\n+      } else {\n+        el.src = `${el.src.substr(0, el.src.length - 8)}minus.png`;\n+        toggledRows.forEach((el) => (el.style.display = \"\"));\n+      }\n+    };\n+\n+    const togglerElements = document.querySelectorAll(\"img.toggler\");\n+    togglerElements.forEach((el) =>\n+      el.addEventListener(\"click\", (event) => toggler(event.currentTarget))\n+    );\n+    togglerElements.forEach((el) => (el.style.display = \"\"));\n+    if (DOCUMENTATION_OPTIONS.COLLAPSE_INDEX) togglerElements.forEach(toggler);\n+  },\n+\n+  initOnKeyListeners: () => {\n+    // only install a listener if it is really needed\n+    if (\n+      !DOCUMENTATION_OPTIONS.NAVIGATION_WITH_KEYS &&\n+      !DOCUMENTATION_OPTIONS.ENABLE_SEARCH_SHORTCUTS\n+    )\n+      return;\n+\n+    document.addEventListener(\"keydown\", (event) => {\n+      // bail for input elements\n+      if (BLACKLISTED_KEY_CONTROL_ELEMENTS.has(document.activeElement.tagName)) return;\n+      // bail with special keys\n+      if (event.altKey || event.ctrlKey || event.metaKey) return;\n+\n+      if (!event.shiftKey) {\n+        switch (event.key) {\n+          case \"ArrowLeft\":\n+            if (!DOCUMENTATION_OPTIONS.NAVIGATION_WITH_KEYS) break;\n+\n+            const prevLink = document.querySelector('link[rel=\"prev\"]');\n+            if (prevLink && prevLink.href) {\n+              window.location.href = prevLink.href;\n+              event.preventDefault();\n+            }\n+            break;\n+          case \"ArrowRight\":\n+            if (!DOCUMENTATION_OPTIONS.NAVIGATION_WITH_KEYS) break;\n+\n+            const nextLink = document.querySelector('link[rel=\"next\"]');\n+            if (nextLink && nextLink.href) {\n+              window.location.href = nextLink.href;\n+              event.preventDefault();\n+            }\n+            break;\n+        }\n+      }\n+\n+      // some keyboard layouts may need Shift to get /\n+      switch (event.key) {\n+        case \"/\":\n+          if (!DOCUMENTATION_OPTIONS.ENABLE_SEARCH_SHORTCUTS) break;\n+          Documentation.focusSearchBar();\n+          event.preventDefault();\n+      }\n+    });\n+  },\n+};\n+\n+// quick alias for translations\n+const _ = Documentation.gettext;\n+\n+_ready(Documentation.init);\ndiff --git a/tmp_sphinx_test/_build/_static/documentation_options.js b/tmp_sphinx_test/_build/_static/documentation_options.js\nnew file mode 100644\nindex 000000000..7e4c114f2\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/documentation_options.js\n@@ -0,0 +1,13 @@\n+const DOCUMENTATION_OPTIONS = {\n+    VERSION: '',\n+    LANGUAGE: 'en',\n+    COLLAPSE_INDEX: false,\n+    BUILDER: 'html',\n+    FILE_SUFFIX: '.html',\n+    LINK_SUFFIX: '.html',\n+    HAS_SOURCE: true,\n+    SOURCELINK_SUFFIX: '.txt',\n+    NAVIGATION_WITH_KEYS: false,\n+    SHOW_SEARCH_SUMMARY: true,\n+    ENABLE_SEARCH_SHORTCUTS: true,\n+};\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/_static/file.png b/tmp_sphinx_test/_build/_static/file.png\nnew file mode 100644\nindex 000000000..a858a410e\nBinary files /dev/null and b/tmp_sphinx_test/_build/_static/file.png differ\ndiff --git a/tmp_sphinx_test/_build/_static/language_data.js b/tmp_sphinx_test/_build/_static/language_data.js\nnew file mode 100644\nindex 000000000..250f5665f\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/language_data.js\n@@ -0,0 +1,199 @@\n+/*\n+ * language_data.js\n+ * ~~~~~~~~~~~~~~~~\n+ *\n+ * This script contains the language-specific data used by searchtools.js,\n+ * namely the list of stopwords, stemmer, scorer and splitter.\n+ *\n+ * :copyright: Copyright 2007-2023 by the Sphinx team, see AUTHORS.\n+ * :license: BSD, see LICENSE for details.\n+ *\n+ */\n+\n+var stopwords = [\"a\", \"and\", \"are\", \"as\", \"at\", \"be\", \"but\", \"by\", \"for\", \"if\", \"in\", \"into\", \"is\", \"it\", \"near\", \"no\", \"not\", \"of\", \"on\", \"or\", \"such\", \"that\", \"the\", \"their\", \"then\", \"there\", \"these\", \"they\", \"this\", \"to\", \"was\", \"will\", \"with\"];\n+\n+\n+/* Non-minified version is copied as a separate JS file, is available */\n+\n+/**\n+ * Porter Stemmer\n+ */\n+var Stemmer = function() {\n+\n+  var step2list = {\n+    ational: 'ate',\n+    tional: 'tion',\n+    enci: 'ence',\n+    anci: 'ance',\n+    izer: 'ize',\n+    bli: 'ble',\n+    alli: 'al',\n+    entli: 'ent',\n+    eli: 'e',\n+    ousli: 'ous',\n+    ization: 'ize',\n+    ation: 'ate',\n+    ator: 'ate',\n+    alism: 'al',\n+    iveness: 'ive',\n+    fulness: 'ful',\n+    ousness: 'ous',\n+    aliti: 'al',\n+    iviti: 'ive',\n+    biliti: 'ble',\n+    logi: 'log'\n+  };\n+\n+  var step3list = {\n+    icate: 'ic',\n+    ative: '',\n+    alize: 'al',\n+    iciti: 'ic',\n+    ical: 'ic',\n+    ful: '',\n+    ness: ''\n+  };\n+\n+  var c = \"[^aeiou]\";          // consonant\n+  var v = \"[aeiouy]\";          // vowel\n+  var C = c + \"[^aeiouy]*\";    // consonant sequence\n+  var V = v + \"[aeiou]*\";      // vowel sequence\n+\n+  var mgr0 = \"^(\" + C + \")?\" + V + C;                      // [C]VC... is m>0\n+  var meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\";    // [C]VC[V] is m=1\n+  var mgr1 = \"^(\" + C + \")?\" + V + C + V + C;              // [C]VCVC... is m>1\n+  var s_v   = \"^(\" + C + \")?\" + v;                         // vowel in stem\n+\n+  this.stemWord = function (w) {\n+    var stem;\n+    var suffix;\n+    var firstch;\n+    var origword = w;\n+\n+    if (w.length < 3)\n+      return w;\n+\n+    var re;\n+    var re2;\n+    var re3;\n+    var re4;\n+\n+    firstch = w.substr(0,1);\n+    if (firstch == \"y\")\n+      w = firstch.toUpperCase() + w.substr(1);\n+\n+    // Step 1a\n+    re = /^(.+?)(ss|i)es$/;\n+    re2 = /^(.+?)([^s])s$/;\n+\n+    if (re.test(w))\n+      w = w.replace(re,\"$1$2\");\n+    else if (re2.test(w))\n+      w = w.replace(re2,\"$1$2\");\n+\n+    // Step 1b\n+    re = /^(.+?)eed$/;\n+    re2 = /^(.+?)(ed|ing)$/;\n+    if (re.test(w)) {\n+      var fp = re.exec(w);\n+      re = new RegExp(mgr0);\n+      if (re.test(fp[1])) {\n+        re = /.$/;\n+        w = w.replace(re,\"\");\n+      }\n+    }\n+    else if (re2.test(w)) {\n+      var fp = re2.exec(w);\n+      stem = fp[1];\n+      re2 = new RegExp(s_v);\n+      if (re2.test(stem)) {\n+        w = stem;\n+        re2 = /(at|bl|iz)$/;\n+        re3 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n+        re4 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n+        if (re2.test(w))\n+          w = w + \"e\";\n+        else if (re3.test(w)) {\n+          re = /.$/;\n+          w = w.replace(re,\"\");\n+        }\n+        else if (re4.test(w))\n+          w = w + \"e\";\n+      }\n+    }\n+\n+    // Step 1c\n+    re = /^(.+?)y$/;\n+    if (re.test(w)) {\n+      var fp = re.exec(w);\n+      stem = fp[1];\n+      re = new RegExp(s_v);\n+      if (re.test(stem))\n+        w = stem + \"i\";\n+    }\n+\n+    // Step 2\n+    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n+    if (re.test(w)) {\n+      var fp = re.exec(w);\n+      stem = fp[1];\n+      suffix = fp[2];\n+      re = new RegExp(mgr0);\n+      if (re.test(stem))\n+        w = stem + step2list[suffix];\n+    }\n+\n+    // Step 3\n+    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n+    if (re.test(w)) {\n+      var fp = re.exec(w);\n+      stem = fp[1];\n+      suffix = fp[2];\n+      re = new RegExp(mgr0);\n+      if (re.test(stem))\n+        w = stem + step3list[suffix];\n+    }\n+\n+    // Step 4\n+    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n+    re2 = /^(.+?)(s|t)(ion)$/;\n+    if (re.test(w)) {\n+      var fp = re.exec(w);\n+      stem = fp[1];\n+      re = new RegExp(mgr1);\n+      if (re.test(stem))\n+        w = stem;\n+    }\n+    else if (re2.test(w)) {\n+      var fp = re2.exec(w);\n+      stem = fp[1] + fp[2];\n+      re2 = new RegExp(mgr1);\n+      if (re2.test(stem))\n+        w = stem;\n+    }\n+\n+    // Step 5\n+    re = /^(.+?)e$/;\n+    if (re.test(w)) {\n+      var fp = re.exec(w);\n+      stem = fp[1];\n+      re = new RegExp(mgr1);\n+      re2 = new RegExp(meq1);\n+      re3 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n+      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem))))\n+        w = stem;\n+    }\n+    re = /ll$/;\n+    re2 = new RegExp(mgr1);\n+    if (re.test(w) && re2.test(w)) {\n+      re = /.$/;\n+      w = w.replace(re,\"\");\n+    }\n+\n+    // and turn initial Y back to y\n+    if (firstch == \"y\")\n+      w = firstch.toLowerCase() + w.substr(1);\n+    return w;\n+  }\n+}\n+\ndiff --git a/tmp_sphinx_test/_build/_static/minus.png b/tmp_sphinx_test/_build/_static/minus.png\nnew file mode 100644\nindex 000000000..d96755fda\nBinary files /dev/null and b/tmp_sphinx_test/_build/_static/minus.png differ\ndiff --git a/tmp_sphinx_test/_build/_static/plus.png b/tmp_sphinx_test/_build/_static/plus.png\nnew file mode 100644\nindex 000000000..7107cec93\nBinary files /dev/null and b/tmp_sphinx_test/_build/_static/plus.png differ\ndiff --git a/tmp_sphinx_test/_build/_static/pygments.css b/tmp_sphinx_test/_build/_static/pygments.css\nnew file mode 100644\nindex 000000000..04a41742e\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/pygments.css\n@@ -0,0 +1,84 @@\n+pre { line-height: 125%; }\n+td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\n+span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\n+td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n+span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n+.highlight .hll { background-color: #ffffcc }\n+.highlight { background: #f8f8f8; }\n+.highlight .c { color: #8f5902; font-style: italic } /* Comment */\n+.highlight .err { color: #a40000; border: 1px solid #ef2929 } /* Error */\n+.highlight .g { color: #000000 } /* Generic */\n+.highlight .k { color: #004461; font-weight: bold } /* Keyword */\n+.highlight .l { color: #000000 } /* Literal */\n+.highlight .n { color: #000000 } /* Name */\n+.highlight .o { color: #582800 } /* Operator */\n+.highlight .x { color: #000000 } /* Other */\n+.highlight .p { color: #000000; font-weight: bold } /* Punctuation */\n+.highlight .ch { color: #8f5902; font-style: italic } /* Comment.Hashbang */\n+.highlight .cm { color: #8f5902; font-style: italic } /* Comment.Multiline */\n+.highlight .cp { color: #8f5902 } /* Comment.Preproc */\n+.highlight .cpf { color: #8f5902; font-style: italic } /* Comment.PreprocFile */\n+.highlight .c1 { color: #8f5902; font-style: italic } /* Comment.Single */\n+.highlight .cs { color: #8f5902; font-style: italic } /* Comment.Special */\n+.highlight .gd { color: #a40000 } /* Generic.Deleted */\n+.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */\n+.highlight .ges { color: #000000 } /* Generic.EmphStrong */\n+.highlight .gr { color: #ef2929 } /* Generic.Error */\n+.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n+.highlight .gi { color: #00A000 } /* Generic.Inserted */\n+.highlight .go { color: #888888 } /* Generic.Output */\n+.highlight .gp { color: #745334 } /* Generic.Prompt */\n+.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */\n+.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n+.highlight .gt { color: #a40000; font-weight: bold } /* Generic.Traceback */\n+.highlight .kc { color: #004461; font-weight: bold } /* Keyword.Constant */\n+.highlight .kd { color: #004461; font-weight: bold } /* Keyword.Declaration */\n+.highlight .kn { color: #004461; font-weight: bold } /* Keyword.Namespace */\n+.highlight .kp { color: #004461; font-weight: bold } /* Keyword.Pseudo */\n+.highlight .kr { color: #004461; font-weight: bold } /* Keyword.Reserved */\n+.highlight .kt { color: #004461; font-weight: bold } /* Keyword.Type */\n+.highlight .ld { color: #000000 } /* Literal.Date */\n+.highlight .m { color: #990000 } /* Literal.Number */\n+.highlight .s { color: #4e9a06 } /* Literal.String */\n+.highlight .na { color: #c4a000 } /* Name.Attribute */\n+.highlight .nb { color: #004461 } /* Name.Builtin */\n+.highlight .nc { color: #000000 } /* Name.Class */\n+.highlight .no { color: #000000 } /* Name.Constant */\n+.highlight .nd { color: #888888 } /* Name.Decorator */\n+.highlight .ni { color: #ce5c00 } /* Name.Entity */\n+.highlight .ne { color: #cc0000; font-weight: bold } /* Name.Exception */\n+.highlight .nf { color: #000000 } /* Name.Function */\n+.highlight .nl { color: #f57900 } /* Name.Label */\n+.highlight .nn { color: #000000 } /* Name.Namespace */\n+.highlight .nx { color: #000000 } /* Name.Other */\n+.highlight .py { color: #000000 } /* Name.Property */\n+.highlight .nt { color: #004461; font-weight: bold } /* Name.Tag */\n+.highlight .nv { color: #000000 } /* Name.Variable */\n+.highlight .ow { color: #004461; font-weight: bold } /* Operator.Word */\n+.highlight .pm { color: #000000; font-weight: bold } /* Punctuation.Marker */\n+.highlight .w { color: #f8f8f8 } /* Text.Whitespace */\n+.highlight .mb { color: #990000 } /* Literal.Number.Bin */\n+.highlight .mf { color: #990000 } /* Literal.Number.Float */\n+.highlight .mh { color: #990000 } /* Literal.Number.Hex */\n+.highlight .mi { color: #990000 } /* Literal.Number.Integer */\n+.highlight .mo { color: #990000 } /* Literal.Number.Oct */\n+.highlight .sa { color: #4e9a06 } /* Literal.String.Affix */\n+.highlight .sb { color: #4e9a06 } /* Literal.String.Backtick */\n+.highlight .sc { color: #4e9a06 } /* Literal.String.Char */\n+.highlight .dl { color: #4e9a06 } /* Literal.String.Delimiter */\n+.highlight .sd { color: #8f5902; font-style: italic } /* Literal.String.Doc */\n+.highlight .s2 { color: #4e9a06 } /* Literal.String.Double */\n+.highlight .se { color: #4e9a06 } /* Literal.String.Escape */\n+.highlight .sh { color: #4e9a06 } /* Literal.String.Heredoc */\n+.highlight .si { color: #4e9a06 } /* Literal.String.Interpol */\n+.highlight .sx { color: #4e9a06 } /* Literal.String.Other */\n+.highlight .sr { color: #4e9a06 } /* Literal.String.Regex */\n+.highlight .s1 { color: #4e9a06 } /* Literal.String.Single */\n+.highlight .ss { color: #4e9a06 } /* Literal.String.Symbol */\n+.highlight .bp { color: #3465a4 } /* Name.Builtin.Pseudo */\n+.highlight .fm { color: #000000 } /* Name.Function.Magic */\n+.highlight .vc { color: #000000 } /* Name.Variable.Class */\n+.highlight .vg { color: #000000 } /* Name.Variable.Global */\n+.highlight .vi { color: #000000 } /* Name.Variable.Instance */\n+.highlight .vm { color: #000000 } /* Name.Variable.Magic */\n+.highlight .il { color: #990000 } /* Literal.Number.Integer.Long */\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/_static/searchtools.js b/tmp_sphinx_test/_build/_static/searchtools.js\nnew file mode 100644\nindex 000000000..7918c3fab\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/searchtools.js\n@@ -0,0 +1,574 @@\n+/*\n+ * searchtools.js\n+ * ~~~~~~~~~~~~~~~~\n+ *\n+ * Sphinx JavaScript utilities for the full-text search.\n+ *\n+ * :copyright: Copyright 2007-2023 by the Sphinx team, see AUTHORS.\n+ * :license: BSD, see LICENSE for details.\n+ *\n+ */\n+\"use strict\";\n+\n+/**\n+ * Simple result scoring code.\n+ */\n+if (typeof Scorer === \"undefined\") {\n+  var Scorer = {\n+    // Implement the following function to further tweak the score for each result\n+    // The function takes a result array [docname, title, anchor, descr, score, filename]\n+    // and returns the new score.\n+    /*\n+    score: result => {\n+      const [docname, title, anchor, descr, score, filename] = result\n+      return score\n+    },\n+    */\n+\n+    // query matches the full name of an object\n+    objNameMatch: 11,\n+    // or matches in the last dotted part of the object name\n+    objPartialMatch: 6,\n+    // Additive scores depending on the priority of the object\n+    objPrio: {\n+      0: 15, // used to be importantResults\n+      1: 5, // used to be objectResults\n+      2: -5, // used to be unimportantResults\n+    },\n+    //  Used when the priority is not in the mapping.\n+    objPrioDefault: 0,\n+\n+    // query found in title\n+    title: 15,\n+    partialTitle: 7,\n+    // query found in terms\n+    term: 5,\n+    partialTerm: 2,\n+  };\n+}\n+\n+const _removeChildren = (element) => {\n+  while (element && element.lastChild) element.removeChild(element.lastChild);\n+};\n+\n+/**\n+ * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n+ */\n+const _escapeRegExp = (string) =>\n+  string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n+\n+const _displayItem = (item, searchTerms, highlightTerms) => {\n+  const docBuilder = DOCUMENTATION_OPTIONS.BUILDER;\n+  const docFileSuffix = DOCUMENTATION_OPTIONS.FILE_SUFFIX;\n+  const docLinkSuffix = DOCUMENTATION_OPTIONS.LINK_SUFFIX;\n+  const showSearchSummary = DOCUMENTATION_OPTIONS.SHOW_SEARCH_SUMMARY;\n+  const contentRoot = document.documentElement.dataset.content_root;\n+\n+  const [docName, title, anchor, descr, score, _filename] = item;\n+\n+  let listItem = document.createElement(\"li\");\n+  let requestUrl;\n+  let linkUrl;\n+  if (docBuilder === \"dirhtml\") {\n+    // dirhtml builder\n+    let dirname = docName + \"/\";\n+    if (dirname.match(/\\/index\\/$/))\n+      dirname = dirname.substring(0, dirname.length - 6);\n+    else if (dirname === \"index/\") dirname = \"\";\n+    requestUrl = contentRoot + dirname;\n+    linkUrl = requestUrl;\n+  } else {\n+    // normal html builders\n+    requestUrl = contentRoot + docName + docFileSuffix;\n+    linkUrl = docName + docLinkSuffix;\n+  }\n+  let linkEl = listItem.appendChild(document.createElement(\"a\"));\n+  linkEl.href = linkUrl + anchor;\n+  linkEl.dataset.score = score;\n+  linkEl.innerHTML = title;\n+  if (descr) {\n+    listItem.appendChild(document.createElement(\"span\")).innerHTML =\n+      \" (\" + descr + \")\";\n+    // highlight search terms in the description\n+    if (SPHINX_HIGHLIGHT_ENABLED)  // set in sphinx_highlight.js\n+      highlightTerms.forEach((term) => _highlightText(listItem, term, \"highlighted\"));\n+  }\n+  else if (showSearchSummary)\n+    fetch(requestUrl)\n+      .then((responseData) => responseData.text())\n+      .then((data) => {\n+        if (data)\n+          listItem.appendChild(\n+            Search.makeSearchSummary(data, searchTerms)\n+          );\n+        // highlight search terms in the summary\n+        if (SPHINX_HIGHLIGHT_ENABLED)  // set in sphinx_highlight.js\n+          highlightTerms.forEach((term) => _highlightText(listItem, term, \"highlighted\"));\n+      });\n+  Search.output.appendChild(listItem);\n+};\n+const _finishSearch = (resultCount) => {\n+  Search.stopPulse();\n+  Search.title.innerText = _(\"Search Results\");\n+  if (!resultCount)\n+    Search.status.innerText = Documentation.gettext(\n+      \"Your search did not match any documents. Please make sure that all words are spelled correctly and that you've selected enough categories.\"\n+    );\n+  else\n+    Search.status.innerText = _(\n+      `Search finished, found ${resultCount} page(s) matching the search query.`\n+    );\n+};\n+const _displayNextItem = (\n+  results,\n+  resultCount,\n+  searchTerms,\n+  highlightTerms,\n+) => {\n+  // results left, load the summary and display it\n+  // this is intended to be dynamic (don't sub resultsCount)\n+  if (results.length) {\n+    _displayItem(results.pop(), searchTerms, highlightTerms);\n+    setTimeout(\n+      () => _displayNextItem(results, resultCount, searchTerms, highlightTerms),\n+      5\n+    );\n+  }\n+  // search finished, update title and status message\n+  else _finishSearch(resultCount);\n+};\n+\n+/**\n+ * Default splitQuery function. Can be overridden in ``sphinx.search`` with a\n+ * custom function per language.\n+ *\n+ * The regular expression works by splitting the string on consecutive characters\n+ * that are not Unicode letters, numbers, underscores, or emoji characters.\n+ * This is the same as ``\\W+`` in Python, preserving the surrogate pair area.\n+ */\n+if (typeof splitQuery === \"undefined\") {\n+  var splitQuery = (query) => query\n+      .split(/[^\\p{Letter}\\p{Number}_\\p{Emoji_Presentation}]+/gu)\n+      .filter(term => term)  // remove remaining empty strings\n+}\n+\n+/**\n+ * Search Module\n+ */\n+const Search = {\n+  _index: null,\n+  _queued_query: null,\n+  _pulse_status: -1,\n+\n+  htmlToText: (htmlString) => {\n+    const htmlElement = new DOMParser().parseFromString(htmlString, 'text/html');\n+    htmlElement.querySelectorAll(\".headerlink\").forEach((el) => { el.remove() });\n+    const docContent = htmlElement.querySelector('[role=\"main\"]');\n+    if (docContent !== undefined) return docContent.textContent;\n+    console.warn(\n+      \"Content block not found. Sphinx search tries to obtain it via '[role=main]'. Could you check your theme or template.\"\n+    );\n+    return \"\";\n+  },\n+\n+  init: () => {\n+    const query = new URLSearchParams(window.location.search).get(\"q\");\n+    document\n+      .querySelectorAll('input[name=\"q\"]')\n+      .forEach((el) => (el.value = query));\n+    if (query) Search.performSearch(query);\n+  },\n+\n+  loadIndex: (url) =>\n+    (document.body.appendChild(document.createElement(\"script\")).src = url),\n+\n+  setIndex: (index) => {\n+    Search._index = index;\n+    if (Search._queued_query !== null) {\n+      const query = Search._queued_query;\n+      Search._queued_query = null;\n+      Search.query(query);\n+    }\n+  },\n+\n+  hasIndex: () => Search._index !== null,\n+\n+  deferQuery: (query) => (Search._queued_query = query),\n+\n+  stopPulse: () => (Search._pulse_status = -1),\n+\n+  startPulse: () => {\n+    if (Search._pulse_status >= 0) return;\n+\n+    const pulse = () => {\n+      Search._pulse_status = (Search._pulse_status + 1) % 4;\n+      Search.dots.innerText = \".\".repeat(Search._pulse_status);\n+      if (Search._pulse_status >= 0) window.setTimeout(pulse, 500);\n+    };\n+    pulse();\n+  },\n+\n+  /**\n+   * perform a search for something (or wait until index is loaded)\n+   */\n+  performSearch: (query) => {\n+    // create the required interface elements\n+    const searchText = document.createElement(\"h2\");\n+    searchText.textContent = _(\"Searching\");\n+    const searchSummary = document.createElement(\"p\");\n+    searchSummary.classList.add(\"search-summary\");\n+    searchSummary.innerText = \"\";\n+    const searchList = document.createElement(\"ul\");\n+    searchList.classList.add(\"search\");\n+\n+    const out = document.getElementById(\"search-results\");\n+    Search.title = out.appendChild(searchText);\n+    Search.dots = Search.title.appendChild(document.createElement(\"span\"));\n+    Search.status = out.appendChild(searchSummary);\n+    Search.output = out.appendChild(searchList);\n+\n+    const searchProgress = document.getElementById(\"search-progress\");\n+    // Some themes don't use the search progress node\n+    if (searchProgress) {\n+      searchProgress.innerText = _(\"Preparing search...\");\n+    }\n+    Search.startPulse();\n+\n+    // index already loaded, the browser was quick!\n+    if (Search.hasIndex()) Search.query(query);\n+    else Search.deferQuery(query);\n+  },\n+\n+  /**\n+   * execute search (requires search index to be loaded)\n+   */\n+  query: (query) => {\n+    const filenames = Search._index.filenames;\n+    const docNames = Search._index.docnames;\n+    const titles = Search._index.titles;\n+    const allTitles = Search._index.alltitles;\n+    const indexEntries = Search._index.indexentries;\n+\n+    // stem the search terms and add them to the correct list\n+    const stemmer = new Stemmer();\n+    const searchTerms = new Set();\n+    const excludedTerms = new Set();\n+    const highlightTerms = new Set();\n+    const objectTerms = new Set(splitQuery(query.toLowerCase().trim()));\n+    splitQuery(query.trim()).forEach((queryTerm) => {\n+      const queryTermLower = queryTerm.toLowerCase();\n+\n+      // maybe skip this \"word\"\n+      // stopwords array is from language_data.js\n+      if (\n+        stopwords.indexOf(queryTermLower) !== -1 ||\n+        queryTerm.match(/^\\d+$/)\n+      )\n+        return;\n+\n+      // stem the word\n+      let word = stemmer.stemWord(queryTermLower);\n+      // select the correct list\n+      if (word[0] === \"-\") excludedTerms.add(word.substr(1));\n+      else {\n+        searchTerms.add(word);\n+        highlightTerms.add(queryTermLower);\n+      }\n+    });\n+\n+    if (SPHINX_HIGHLIGHT_ENABLED) {  // set in sphinx_highlight.js\n+      localStorage.setItem(\"sphinx_highlight_terms\", [...highlightTerms].join(\" \"))\n+    }\n+\n+    // console.debug(\"SEARCH: searching for:\");\n+    // console.info(\"required: \", [...searchTerms]);\n+    // console.info(\"excluded: \", [...excludedTerms]);\n+\n+    // array of [docname, title, anchor, descr, score, filename]\n+    let results = [];\n+    _removeChildren(document.getElementById(\"search-progress\"));\n+\n+    const queryLower = query.toLowerCase();\n+    for (const [title, foundTitles] of Object.entries(allTitles)) {\n+      if (title.toLowerCase().includes(queryLower) && (queryLower.length >= title.length/2)) {\n+        for (const [file, id] of foundTitles) {\n+          let score = Math.round(100 * queryLower.length / title.length)\n+          results.push([\n+            docNames[file],\n+            titles[file] !== title ? `${titles[file]} > ${title}` : title,\n+            id !== null ? \"#\" + id : \"\",\n+            null,\n+            score,\n+            filenames[file],\n+          ]);\n+        }\n+      }\n+    }\n+\n+    // search for explicit entries in index directives\n+    for (const [entry, foundEntries] of Object.entries(indexEntries)) {\n+      if (entry.includes(queryLower) && (queryLower.length >= entry.length/2)) {\n+        for (const [file, id] of foundEntries) {\n+          let score = Math.round(100 * queryLower.length / entry.length)\n+          results.push([\n+            docNames[file],\n+            titles[file],\n+            id ? \"#\" + id : \"\",\n+            null,\n+            score,\n+            filenames[file],\n+          ]);\n+        }\n+      }\n+    }\n+\n+    // lookup as object\n+    objectTerms.forEach((term) =>\n+      results.push(...Search.performObjectSearch(term, objectTerms))\n+    );\n+\n+    // lookup as search terms in fulltext\n+    results.push(...Search.performTermsSearch(searchTerms, excludedTerms));\n+\n+    // let the scorer override scores with a custom scoring function\n+    if (Scorer.score) results.forEach((item) => (item[4] = Scorer.score(item)));\n+\n+    // now sort the results by score (in opposite order of appearance, since the\n+    // display function below uses pop() to retrieve items) and then\n+    // alphabetically\n+    results.sort((a, b) => {\n+      const leftScore = a[4];\n+      const rightScore = b[4];\n+      if (leftScore === rightScore) {\n+        // same score: sort alphabetically\n+        const leftTitle = a[1].toLowerCase();\n+        const rightTitle = b[1].toLowerCase();\n+        if (leftTitle === rightTitle) return 0;\n+        return leftTitle > rightTitle ? -1 : 1; // inverted is intentional\n+      }\n+      return leftScore > rightScore ? 1 : -1;\n+    });\n+\n+    // remove duplicate search results\n+    // note the reversing of results, so that in the case of duplicates, the highest-scoring entry is kept\n+    let seen = new Set();\n+    results = results.reverse().reduce((acc, result) => {\n+      let resultStr = result.slice(0, 4).concat([result[5]]).map(v => String(v)).join(',');\n+      if (!seen.has(resultStr)) {\n+        acc.push(result);\n+        seen.add(resultStr);\n+      }\n+      return acc;\n+    }, []);\n+\n+    results = results.reverse();\n+\n+    // for debugging\n+    //Search.lastresults = results.slice();  // a copy\n+    // console.info(\"search results:\", Search.lastresults);\n+\n+    // print the results\n+    _displayNextItem(results, results.length, searchTerms, highlightTerms);\n+  },\n+\n+  /**\n+   * search for object names\n+   */\n+  performObjectSearch: (object, objectTerms) => {\n+    const filenames = Search._index.filenames;\n+    const docNames = Search._index.docnames;\n+    const objects = Search._index.objects;\n+    const objNames = Search._index.objnames;\n+    const titles = Search._index.titles;\n+\n+    const results = [];\n+\n+    const objectSearchCallback = (prefix, match) => {\n+      const name = match[4]\n+      const fullname = (prefix ? prefix + \".\" : \"\") + name;\n+      const fullnameLower = fullname.toLowerCase();\n+      if (fullnameLower.indexOf(object) < 0) return;\n+\n+      let score = 0;\n+      const parts = fullnameLower.split(\".\");\n+\n+      // check for different match types: exact matches of full name or\n+      // \"last name\" (i.e. last dotted part)\n+      if (fullnameLower === object || parts.slice(-1)[0] === object)\n+        score += Scorer.objNameMatch;\n+      else if (parts.slice(-1)[0].indexOf(object) > -1)\n+        score += Scorer.objPartialMatch; // matches in last name\n+\n+      const objName = objNames[match[1]][2];\n+      const title = titles[match[0]];\n+\n+      // If more than one term searched for, we require other words to be\n+      // found in the name/title/description\n+      const otherTerms = new Set(objectTerms);\n+      otherTerms.delete(object);\n+      if (otherTerms.size > 0) {\n+        const haystack = `${prefix} ${name} ${objName} ${title}`.toLowerCase();\n+        if (\n+          [...otherTerms].some((otherTerm) => haystack.indexOf(otherTerm) < 0)\n+        )\n+          return;\n+      }\n+\n+      let anchor = match[3];\n+      if (anchor === \"\") anchor = fullname;\n+      else if (anchor === \"-\") anchor = objNames[match[1]][1] + \"-\" + fullname;\n+\n+      const descr = objName + _(\", in \") + title;\n+\n+      // add custom score for some objects according to scorer\n+      if (Scorer.objPrio.hasOwnProperty(match[2]))\n+        score += Scorer.objPrio[match[2]];\n+      else score += Scorer.objPrioDefault;\n+\n+      results.push([\n+        docNames[match[0]],\n+        fullname,\n+        \"#\" + anchor,\n+        descr,\n+        score,\n+        filenames[match[0]],\n+      ]);\n+    };\n+    Object.keys(objects).forEach((prefix) =>\n+      objects[prefix].forEach((array) =>\n+        objectSearchCallback(prefix, array)\n+      )\n+    );\n+    return results;\n+  },\n+\n+  /**\n+   * search for full-text terms in the index\n+   */\n+  performTermsSearch: (searchTerms, excludedTerms) => {\n+    // prepare search\n+    const terms = Search._index.terms;\n+    const titleTerms = Search._index.titleterms;\n+    const filenames = Search._index.filenames;\n+    const docNames = Search._index.docnames;\n+    const titles = Search._index.titles;\n+\n+    const scoreMap = new Map();\n+    const fileMap = new Map();\n+\n+    // perform the search on the required terms\n+    searchTerms.forEach((word) => {\n+      const files = [];\n+      const arr = [\n+        { files: terms[word], score: Scorer.term },\n+        { files: titleTerms[word], score: Scorer.title },\n+      ];\n+      // add support for partial matches\n+      if (word.length > 2) {\n+        const escapedWord = _escapeRegExp(word);\n+        Object.keys(terms).forEach((term) => {\n+          if (term.match(escapedWord) && !terms[word])\n+            arr.push({ files: terms[term], score: Scorer.partialTerm });\n+        });\n+        Object.keys(titleTerms).forEach((term) => {\n+          if (term.match(escapedWord) && !titleTerms[word])\n+            arr.push({ files: titleTerms[word], score: Scorer.partialTitle });\n+        });\n+      }\n+\n+      // no match but word was a required one\n+      if (arr.every((record) => record.files === undefined)) return;\n+\n+      // found search word in contents\n+      arr.forEach((record) => {\n+        if (record.files === undefined) return;\n+\n+        let recordFiles = record.files;\n+        if (recordFiles.length === undefined) recordFiles = [recordFiles];\n+        files.push(...recordFiles);\n+\n+        // set score for the word in each file\n+        recordFiles.forEach((file) => {\n+          if (!scoreMap.has(file)) scoreMap.set(file, {});\n+          scoreMap.get(file)[word] = record.score;\n+        });\n+      });\n+\n+      // create the mapping\n+      files.forEach((file) => {\n+        if (fileMap.has(file) && fileMap.get(file).indexOf(word) === -1)\n+          fileMap.get(file).push(word);\n+        else fileMap.set(file, [word]);\n+      });\n+    });\n+\n+    // now check if the files don't contain excluded terms\n+    const results = [];\n+    for (const [file, wordList] of fileMap) {\n+      // check if all requirements are matched\n+\n+      // as search terms with length < 3 are discarded\n+      const filteredTermCount = [...searchTerms].filter(\n+        (term) => term.length > 2\n+      ).length;\n+      if (\n+        wordList.length !== searchTerms.size &&\n+        wordList.length !== filteredTermCount\n+      )\n+        continue;\n+\n+      // ensure that none of the excluded terms is in the search result\n+      if (\n+        [...excludedTerms].some(\n+          (term) =>\n+            terms[term] === file ||\n+            titleTerms[term] === file ||\n+            (terms[term] || []).includes(file) ||\n+            (titleTerms[term] || []).includes(file)\n+        )\n+      )\n+        break;\n+\n+      // select one (max) score for the file.\n+      const score = Math.max(...wordList.map((w) => scoreMap.get(file)[w]));\n+      // add result to the result list\n+      results.push([\n+        docNames[file],\n+        titles[file],\n+        \"\",\n+        null,\n+        score,\n+        filenames[file],\n+      ]);\n+    }\n+    return results;\n+  },\n+\n+  /**\n+   * helper function to return a node containing the\n+   * search summary for a given text. keywords is a list\n+   * of stemmed words.\n+   */\n+  makeSearchSummary: (htmlText, keywords) => {\n+    const text = Search.htmlToText(htmlText);\n+    if (text === \"\") return null;\n+\n+    const textLower = text.toLowerCase();\n+    const actualStartPosition = [...keywords]\n+      .map((k) => textLower.indexOf(k.toLowerCase()))\n+      .filter((i) => i > -1)\n+      .slice(-1)[0];\n+    const startWithContext = Math.max(actualStartPosition - 120, 0);\n+\n+    const top = startWithContext === 0 ? \"\" : \"...\";\n+    const tail = startWithContext + 240 < text.length ? \"...\" : \"\";\n+\n+    let summary = document.createElement(\"p\");\n+    summary.classList.add(\"context\");\n+    summary.textContent = top + text.substr(startWithContext, 240).trim() + tail;\n+\n+    return summary;\n+  },\n+};\n+\n+_ready(Search.init);\ndiff --git a/tmp_sphinx_test/_build/_static/sphinx_highlight.js b/tmp_sphinx_test/_build/_static/sphinx_highlight.js\nnew file mode 100644\nindex 000000000..8a96c69a1\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/_static/sphinx_highlight.js\n@@ -0,0 +1,154 @@\n+/* Highlighting utilities for Sphinx HTML documentation. */\n+\"use strict\";\n+\n+const SPHINX_HIGHLIGHT_ENABLED = true\n+\n+/**\n+ * highlight a given string on a node by wrapping it in\n+ * span elements with the given class name.\n+ */\n+const _highlight = (node, addItems, text, className) => {\n+  if (node.nodeType === Node.TEXT_NODE) {\n+    const val = node.nodeValue;\n+    const parent = node.parentNode;\n+    const pos = val.toLowerCase().indexOf(text);\n+    if (\n+      pos >= 0 &&\n+      !parent.classList.contains(className) &&\n+      !parent.classList.contains(\"nohighlight\")\n+    ) {\n+      let span;\n+\n+      const closestNode = parent.closest(\"body, svg, foreignObject\");\n+      const isInSVG = closestNode && closestNode.matches(\"svg\");\n+      if (isInSVG) {\n+        span = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n+      } else {\n+        span = document.createElement(\"span\");\n+        span.classList.add(className);\n+      }\n+\n+      span.appendChild(document.createTextNode(val.substr(pos, text.length)));\n+      const rest = document.createTextNode(val.substr(pos + text.length));\n+      parent.insertBefore(\n+        span,\n+        parent.insertBefore(\n+          rest,\n+          node.nextSibling\n+        )\n+      );\n+      node.nodeValue = val.substr(0, pos);\n+      /* There may be more occurrences of search term in this node. So call this\n+       * function recursively on the remaining fragment.\n+       */\n+      _highlight(rest, addItems, text, className);\n+\n+      if (isInSVG) {\n+        const rect = document.createElementNS(\n+          \"http://www.w3.org/2000/svg\",\n+          \"rect\"\n+        );\n+        const bbox = parent.getBBox();\n+        rect.x.baseVal.value = bbox.x;\n+        rect.y.baseVal.value = bbox.y;\n+        rect.width.baseVal.value = bbox.width;\n+        rect.height.baseVal.value = bbox.height;\n+        rect.setAttribute(\"class\", className);\n+        addItems.push({ parent: parent, target: rect });\n+      }\n+    }\n+  } else if (node.matches && !node.matches(\"button, select, textarea\")) {\n+    node.childNodes.forEach((el) => _highlight(el, addItems, text, className));\n+  }\n+};\n+const _highlightText = (thisNode, text, className) => {\n+  let addItems = [];\n+  _highlight(thisNode, addItems, text, className);\n+  addItems.forEach((obj) =>\n+    obj.parent.insertAdjacentElement(\"beforebegin\", obj.target)\n+  );\n+};\n+\n+/**\n+ * Small JavaScript module for the documentation.\n+ */\n+const SphinxHighlight = {\n+\n+  /**\n+   * highlight the search words provided in localstorage in the text\n+   */\n+  highlightSearchWords: () => {\n+    if (!SPHINX_HIGHLIGHT_ENABLED) return;  // bail if no highlight\n+\n+    // get and clear terms from localstorage\n+    const url = new URL(window.location);\n+    const highlight =\n+        localStorage.getItem(\"sphinx_highlight_terms\")\n+        || url.searchParams.get(\"highlight\")\n+        || \"\";\n+    localStorage.removeItem(\"sphinx_highlight_terms\")\n+    url.searchParams.delete(\"highlight\");\n+    window.history.replaceState({}, \"\", url);\n+\n+    // get individual terms from highlight string\n+    const terms = highlight.toLowerCase().split(/\\s+/).filter(x => x);\n+    if (terms.length === 0) return; // nothing to do\n+\n+    // There should never be more than one element matching \"div.body\"\n+    const divBody = document.querySelectorAll(\"div.body\");\n+    const body = divBody.length ? divBody[0] : document.querySelector(\"body\");\n+    window.setTimeout(() => {\n+      terms.forEach((term) => _highlightText(body, term, \"highlighted\"));\n+    }, 10);\n+\n+    const searchBox = document.getElementById(\"searchbox\");\n+    if (searchBox === null) return;\n+    searchBox.appendChild(\n+      document\n+        .createRange()\n+        .createContextualFragment(\n+          '<p class=\"highlight-link\">' +\n+            '<a href=\"javascript:SphinxHighlight.hideSearchWords()\">' +\n+            _(\"Hide Search Matches\") +\n+            \"</a></p>\"\n+        )\n+    );\n+  },\n+\n+  /**\n+   * helper function to hide the search marks again\n+   */\n+  hideSearchWords: () => {\n+    document\n+      .querySelectorAll(\"#searchbox .highlight-link\")\n+      .forEach((el) => el.remove());\n+    document\n+      .querySelectorAll(\"span.highlighted\")\n+      .forEach((el) => el.classList.remove(\"highlighted\"));\n+    localStorage.removeItem(\"sphinx_highlight_terms\")\n+  },\n+\n+  initEscapeListener: () => {\n+    // only install a listener if it is really needed\n+    if (!DOCUMENTATION_OPTIONS.ENABLE_SEARCH_SHORTCUTS) return;\n+\n+    document.addEventListener(\"keydown\", (event) => {\n+      // bail for input elements\n+      if (BLACKLISTED_KEY_CONTROL_ELEMENTS.has(document.activeElement.tagName)) return;\n+      // bail with special keys\n+      if (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) return;\n+      if (DOCUMENTATION_OPTIONS.ENABLE_SEARCH_SHORTCUTS && (event.key === \"Escape\")) {\n+        SphinxHighlight.hideSearchWords();\n+        event.preventDefault();\n+      }\n+    });\n+  },\n+};\n+\n+_ready(() => {\n+  /* Do not call highlightSearchWords() when we are on the search page.\n+   * It will highlight words from the *previous* search query.\n+   */\n+  if (typeof Search === \"undefined\") SphinxHighlight.highlightSearchWords();\n+  SphinxHighlight.initEscapeListener();\n+});\ndiff --git a/tmp_sphinx_test/_build/genindex.html b/tmp_sphinx_test/_build/genindex.html\nnew file mode 100644\nindex 000000000..0a688fce5\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/genindex.html\n@@ -0,0 +1,99 @@\n+<!DOCTYPE html>\n+\n+<html lang=\"en\" data-content_root=\"./\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n+    <title>Index &#8212; tmp  documentation</title>\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/pygments.css?v=d1102ebc\" />\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/alabaster.css?v=12dfc556\" />\n+    <script src=\"_static/documentation_options.js?v=5929fcd5\"></script>\n+    <script src=\"_static/doctools.js?v=888ff710\"></script>\n+    <script src=\"_static/sphinx_highlight.js?v=dc90522c\"></script>\n+    <link rel=\"index\" title=\"Index\" href=\"#\" />\n+    <link rel=\"search\" title=\"Search\" href=\"search.html\" />\n+   \n+  <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n+  \n+\n+  \n+  \n+\n+  </head><body>\n+  \n+\n+    <div class=\"document\">\n+      <div class=\"documentwrapper\">\n+        <div class=\"bodywrapper\">\n+          \n+\n+          <div class=\"body\" role=\"main\">\n+            \n+\n+<h1 id=\"index\">Index</h1>\n+\n+<div class=\"genindex-jumpbox\">\n+ \n+</div>\n+\n+\n+          </div>\n+          \n+        </div>\n+      </div>\n+      <div class=\"sphinxsidebar\" role=\"navigation\" aria-label=\"main navigation\">\n+        <div class=\"sphinxsidebarwrapper\">\n+<h1 class=\"logo\"><a href=\"index.html\">tmp</a></h1>\n+\n+\n+\n+\n+\n+\n+\n+\n+<h3>Navigation</h3>\n+\n+<div class=\"relations\">\n+<h3>Related Topics</h3>\n+<ul>\n+  <li><a href=\"index.html\">Documentation overview</a><ul>\n+  </ul></li>\n+</ul>\n+</div>\n+<div id=\"searchbox\" style=\"display: none\" role=\"search\">\n+  <h3 id=\"searchlabel\">Quick search</h3>\n+    <div class=\"searchformwrapper\">\n+    <form class=\"search\" action=\"search.html\" method=\"get\">\n+      <input type=\"text\" name=\"q\" aria-labelledby=\"searchlabel\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"/>\n+      <input type=\"submit\" value=\"Go\" />\n+    </form>\n+    </div>\n+</div>\n+<script>document.getElementById('searchbox').style.display = \"block\"</script>\n+\n+\n+\n+\n+\n+\n+\n+\n+        </div>\n+      </div>\n+      <div class=\"clearer\"></div>\n+    </div>\n+    <div class=\"footer\">\n+      &#169;.\n+      \n+      |\n+      Powered by <a href=\"https://www.sphinx-doc.org/\">Sphinx 7.2.0+/7ebcb8ba3</a>\n+      &amp; <a href=\"https://alabaster.readthedocs.io\">Alabaster 0.7.16</a>\n+      \n+    </div>\n+\n+    \n+\n+    \n+  </body>\n+</html>\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/index.html b/tmp_sphinx_test/_build/index.html\nnew file mode 100644\nindex 000000000..649625484\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/index.html\n@@ -0,0 +1,105 @@\n+<!DOCTYPE html>\n+\n+<html lang=\"en\" data-content_root=\"./\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n+\n+    <title>This is a test &#8212; tmp  documentation</title>\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/pygments.css?v=d1102ebc\" />\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/alabaster.css?v=12dfc556\" />\n+    <script src=\"_static/documentation_options.js?v=5929fcd5\"></script>\n+    <script src=\"_static/doctools.js?v=888ff710\"></script>\n+    <script src=\"_static/sphinx_highlight.js?v=dc90522c\"></script>\n+    <link rel=\"index\" title=\"Index\" href=\"genindex.html\" />\n+    <link rel=\"search\" title=\"Search\" href=\"search.html\" />\n+   \n+  <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n+  \n+\n+  \n+  \n+\n+  </head><body>\n+  \n+\n+    <div class=\"document\">\n+      <div class=\"documentwrapper\">\n+        <div class=\"bodywrapper\">\n+          \n+\n+          <div class=\"body\" role=\"main\">\n+            \n+  <section id=\"this-is-a-test\">\n+<h1>This is a test<a class=\"headerlink\" href=\"#this-is-a-test\" title=\"Link to this heading\">\u00b6</a></h1>\n+</section>\n+<section id=\"testing\">\n+<h1>Testing<a class=\"headerlink\" href=\"#testing\" title=\"Link to this heading\">\u00b6</a></h1>\n+<p>REPLACED</p>\n+<p>REPLACED</p>\n+</section>\n+\n+\n+          </div>\n+          \n+        </div>\n+      </div>\n+      <div class=\"sphinxsidebar\" role=\"navigation\" aria-label=\"main navigation\">\n+        <div class=\"sphinxsidebarwrapper\">\n+<h1 class=\"logo\"><a href=\"#\">tmp</a></h1>\n+\n+\n+\n+\n+\n+\n+\n+\n+<h3>Navigation</h3>\n+\n+<div class=\"relations\">\n+<h3>Related Topics</h3>\n+<ul>\n+  <li><a href=\"#\">Documentation overview</a><ul>\n+  </ul></li>\n+</ul>\n+</div>\n+<div id=\"searchbox\" style=\"display: none\" role=\"search\">\n+  <h3 id=\"searchlabel\">Quick search</h3>\n+    <div class=\"searchformwrapper\">\n+    <form class=\"search\" action=\"search.html\" method=\"get\">\n+      <input type=\"text\" name=\"q\" aria-labelledby=\"searchlabel\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"/>\n+      <input type=\"submit\" value=\"Go\" />\n+    </form>\n+    </div>\n+</div>\n+<script>document.getElementById('searchbox').style.display = \"block\"</script>\n+\n+\n+\n+\n+\n+\n+\n+\n+        </div>\n+      </div>\n+      <div class=\"clearer\"></div>\n+    </div>\n+    <div class=\"footer\">\n+      &#169;.\n+      \n+      |\n+      Powered by <a href=\"https://www.sphinx-doc.org/\">Sphinx 7.2.0+/7ebcb8ba3</a>\n+      &amp; <a href=\"https://alabaster.readthedocs.io\">Alabaster 0.7.16</a>\n+      \n+      |\n+      <a href=\"_sources/index.rst.txt\"\n+          rel=\"nofollow\">Page source</a>\n+    </div>\n+\n+    \n+\n+    \n+  </body>\n+</html>\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/objects.inv b/tmp_sphinx_test/_build/objects.inv\nnew file mode 100644\nindex 000000000..24593f921\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/objects.inv\n@@ -0,0 +1,7 @@\n+# Sphinx inventory version 2\n+# Project: tmp\n+# Version: \n+# The remainder of this file is compressed using zlib.\n+x\u0685\ufffdQ\n+\u0003!\fD\ufffd=E.`\ufffd\ufffd\ufffdA?\u0016\u0016\ufffd\u000bX\u0013TPSj\u0016\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdP\ufffdG\ufffd\ufffd70\ufffdr\ufffdHo(\ufffd\ufffdh\u001e\u0014A\ufffd\ufffdu\ufffd\ufffd%E\ufffdn\ufffd\ufffd\u0150\ufffd\u0016\u001a\u0012w\u001f\n+\ufffd3 TD%\u0183\ufffd\u7abfF\ufffd&\ufffd%R\ufffd\u001f\ufffd?\u063c\ufffd\u7f27\u000b\ufffd\ufffd\ufffd{\ufffdi\ufffd\ufffd5\u007f6\ufffdT\ufffdD\ufffdCvZX\ufffdl\ufffd4\ufffd:\ufffd\ufffd\ufffd:\ufffd\ufffd\ufffd\u0003P*m\ufffd\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/search.html b/tmp_sphinx_test/_build/search.html\nnew file mode 100644\nindex 000000000..9831498d1\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/search.html\n@@ -0,0 +1,118 @@\n+<!DOCTYPE html>\n+\n+<html lang=\"en\" data-content_root=\"./\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n+    <title>Search &#8212; tmp  documentation</title>\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/pygments.css?v=d1102ebc\" />\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/alabaster.css?v=12dfc556\" />\n+    \n+    <script src=\"_static/documentation_options.js?v=5929fcd5\"></script>\n+    <script src=\"_static/doctools.js?v=888ff710\"></script>\n+    <script src=\"_static/sphinx_highlight.js?v=dc90522c\"></script>\n+    <script src=\"_static/searchtools.js\"></script>\n+    <script src=\"_static/language_data.js\"></script>\n+    <link rel=\"index\" title=\"Index\" href=\"genindex.html\" />\n+    <link rel=\"search\" title=\"Search\" href=\"#\" />\n+  <script src=\"searchindex.js\" defer></script>\n+  \n+   \n+  <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n+  \n+\n+  \n+  \n+\n+\n+  </head><body>\n+  \n+\n+    <div class=\"document\">\n+      <div class=\"documentwrapper\">\n+        <div class=\"bodywrapper\">\n+          \n+\n+          <div class=\"body\" role=\"main\">\n+            \n+  <h1 id=\"search-documentation\">Search</h1>\n+  \n+  <noscript>\n+  <div class=\"admonition warning\">\n+  <p>\n+    Please activate JavaScript to enable the search\n+    functionality.\n+  </p>\n+  </div>\n+  </noscript>\n+  \n+  \n+  <p>\n+    Searching for multiple words only shows matches that contain\n+    all words.\n+  </p>\n+  \n+  \n+  <form action=\"\" method=\"get\">\n+    <input type=\"text\" name=\"q\" aria-labelledby=\"search-documentation\" value=\"\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"/>\n+    <input type=\"submit\" value=\"search\" />\n+    <span id=\"search-progress\" style=\"padding-left: 10px\"></span>\n+  </form>\n+  \n+  \n+  \n+  <div id=\"search-results\">\n+  \n+  </div>\n+  \n+\n+          </div>\n+          \n+        </div>\n+      </div>\n+      <div class=\"sphinxsidebar\" role=\"navigation\" aria-label=\"main navigation\">\n+        <div class=\"sphinxsidebarwrapper\">\n+<h1 class=\"logo\"><a href=\"index.html\">tmp</a></h1>\n+\n+\n+\n+\n+\n+\n+\n+\n+<h3>Navigation</h3>\n+\n+<div class=\"relations\">\n+<h3>Related Topics</h3>\n+<ul>\n+  <li><a href=\"index.html\">Documentation overview</a><ul>\n+  </ul></li>\n+</ul>\n+</div>\n+\n+\n+\n+\n+\n+\n+\n+\n+        </div>\n+      </div>\n+      <div class=\"clearer\"></div>\n+    </div>\n+    <div class=\"footer\">\n+      &#169;.\n+      \n+      |\n+      Powered by <a href=\"https://www.sphinx-doc.org/\">Sphinx 7.2.0+/7ebcb8ba3</a>\n+      &amp; <a href=\"https://alabaster.readthedocs.io\">Alabaster 0.7.16</a>\n+      \n+    </div>\n+\n+    \n+\n+    \n+  </body>\n+</html>\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/searchindex.js b/tmp_sphinx_test/_build/searchindex.js\nnew file mode 100644\nindex 000000000..4c81b2f29\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/searchindex.js\n@@ -0,0 +1 @@\n+Search.setIndex({\"docnames\": [\"index\", \"something-to-include\"], \"filenames\": [\"index.rst\", \"something-to-include.rst\"], \"titles\": [\"This is a test\", \"Testing\"], \"terms\": {\"replac\": [0, 1]}, \"objects\": {}, \"objtypes\": {}, \"objnames\": {}, \"titleterms\": {\"thi\": 0, \"i\": 0, \"test\": [0, 1]}, \"envversion\": {\"sphinx.domains.c\": 3, \"sphinx.domains.changeset\": 1, \"sphinx.domains.citation\": 1, \"sphinx.domains.cpp\": 9, \"sphinx.domains.index\": 1, \"sphinx.domains.javascript\": 3, \"sphinx.domains.math\": 2, \"sphinx.domains.python\": 4, \"sphinx.domains.rst\": 2, \"sphinx.domains.std\": 2, \"sphinx\": 60}, \"alltitles\": {\"This is a test\": [[0, \"this-is-a-test\"]], \"Testing\": [[0, \"testing\"], [1, \"testing\"]]}, \"indexentries\": {}})\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/_build/something-to-include.html b/tmp_sphinx_test/_build/something-to-include.html\nnew file mode 100644\nindex 000000000..5c822c200\n--- /dev/null\n+++ b/tmp_sphinx_test/_build/something-to-include.html\n@@ -0,0 +1,101 @@\n+<!DOCTYPE html>\n+\n+<html lang=\"en\" data-content_root=\"./\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n+\n+    <title>Testing &#8212; tmp  documentation</title>\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/pygments.css?v=d1102ebc\" />\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"_static/alabaster.css?v=12dfc556\" />\n+    <script src=\"_static/documentation_options.js?v=5929fcd5\"></script>\n+    <script src=\"_static/doctools.js?v=888ff710\"></script>\n+    <script src=\"_static/sphinx_highlight.js?v=dc90522c\"></script>\n+    <link rel=\"index\" title=\"Index\" href=\"genindex.html\" />\n+    <link rel=\"search\" title=\"Search\" href=\"search.html\" />\n+   \n+  <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n+  \n+\n+  \n+  \n+\n+  </head><body>\n+  \n+\n+    <div class=\"document\">\n+      <div class=\"documentwrapper\">\n+        <div class=\"bodywrapper\">\n+          \n+\n+          <div class=\"body\" role=\"main\">\n+            \n+  <section id=\"testing\">\n+<h1>Testing<a class=\"headerlink\" href=\"#testing\" title=\"Link to this heading\">\u00b6</a></h1>\n+<p>REPLACED</p>\n+</section>\n+\n+\n+          </div>\n+          \n+        </div>\n+      </div>\n+      <div class=\"sphinxsidebar\" role=\"navigation\" aria-label=\"main navigation\">\n+        <div class=\"sphinxsidebarwrapper\">\n+<h1 class=\"logo\"><a href=\"index.html\">tmp</a></h1>\n+\n+\n+\n+\n+\n+\n+\n+\n+<h3>Navigation</h3>\n+\n+<div class=\"relations\">\n+<h3>Related Topics</h3>\n+<ul>\n+  <li><a href=\"index.html\">Documentation overview</a><ul>\n+  </ul></li>\n+</ul>\n+</div>\n+<div id=\"searchbox\" style=\"display: none\" role=\"search\">\n+  <h3 id=\"searchlabel\">Quick search</h3>\n+    <div class=\"searchformwrapper\">\n+    <form class=\"search\" action=\"search.html\" method=\"get\">\n+      <input type=\"text\" name=\"q\" aria-labelledby=\"searchlabel\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"/>\n+      <input type=\"submit\" value=\"Go\" />\n+    </form>\n+    </div>\n+</div>\n+<script>document.getElementById('searchbox').style.display = \"block\"</script>\n+\n+\n+\n+\n+\n+\n+\n+\n+        </div>\n+      </div>\n+      <div class=\"clearer\"></div>\n+    </div>\n+    <div class=\"footer\">\n+      &#169;.\n+      \n+      |\n+      Powered by <a href=\"https://www.sphinx-doc.org/\">Sphinx 7.2.0+/7ebcb8ba3</a>\n+      &amp; <a href=\"https://alabaster.readthedocs.io\">Alabaster 0.7.16</a>\n+      \n+      |\n+      <a href=\"_sources/something-to-include.rst.txt\"\n+          rel=\"nofollow\">Page source</a>\n+    </div>\n+\n+    \n+\n+    \n+  </body>\n+</html>\n\\ No newline at end of file\ndiff --git a/tmp_sphinx_test/conf.py b/tmp_sphinx_test/conf.py\nnew file mode 100644\nindex 000000000..314e293e2\n--- /dev/null\n+++ b/tmp_sphinx_test/conf.py\n@@ -0,0 +1,5 @@\n+import os, sys\n+sys.path.insert(0, os.path.abspath('.'))\n+extensions = ['my_extension']\n+project = 'tmp'\n+master_doc = 'index'\ndiff --git a/tmp_sphinx_test/index.rst b/tmp_sphinx_test/index.rst\nnew file mode 100644\nindex 000000000..f2dec1395\n--- /dev/null\n+++ b/tmp_sphinx_test/index.rst\n@@ -0,0 +1,6 @@\n+This is a test\n+==============\n+\n+.. include:: something-to-include.rst\n+\n+&REPLACE_ME;\ndiff --git a/tmp_sphinx_test/my_extension.py b/tmp_sphinx_test/my_extension.py\nnew file mode 100644\nindex 000000000..90f8cbf3d\n--- /dev/null\n+++ b/tmp_sphinx_test/my_extension.py\n@@ -0,0 +1,8 @@\n+from sphinx.application import Sphinx\n+def subst_vars_replace(app: Sphinx, docname, source):\n+    result = source[0]\n+    result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+    source[0] = result\n+def setup(app: Sphinx):\n+    app.connect('source-read', subst_vars_replace)\n+    return {\"version\":\"1.0\"}\ndiff --git a/tmp_sphinx_test/something-to-include.rst b/tmp_sphinx_test/something-to-include.rst\nnew file mode 100644\nindex 000000000..e63253568\n--- /dev/null\n+++ b/tmp_sphinx_test/something-to-include.rst\n@@ -0,0 +1,4 @@\n+Testing\n+=======\n+\n+&REPLACE_ME;\n"
  },
  "sphinx-doc__sphinx-7590": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7590",
    "model_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..0d2b123db 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -4664,16 +4664,32 @@ class DefinitionParser(BaseParser):\n             if self.match(regex):\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n+                # accept optional user-defined literal suffix (identifier) immediately\n+                # following the literal (no intervening whitespace)\n+                # If an identifier is present, match() advances self.pos and sets last_match\n+                if self.match(identifier_re):\n+                    pass\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n         string = self._parse_string()\n         if string is not None:\n+            # allow user-defined literal suffix immediately after string literal\n+            if self.match(identifier_re):\n+                string = string + self.matched_text\n             return ASTStringLiteral(string)\n \n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n+            # allow user-defined literal suffix immediately after char literal\n+            if self.match(identifier_re):\n+                # build a combined literal string including prefix (if any), quotes and suffix\n+                if prefix is None:\n+                    combined = \"'\" + data + \"'\" + self.matched_text\n+                else:\n+                    combined = prefix + \"'\" + data + \"'\" + self.matched_text\n+                return ASTStringLiteral(combined)\n             try:\n                 return ASTCharLiteral(prefix, data)\n             except UnicodeDecodeError as e:\n"
  },
  "sphinx-doc__sphinx-7748": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7748",
    "model_patch": "diff --git a/sphinx/addnodes.py b/sphinx/addnodes.py\nindex 5e191e989..949afe03d 100644\n--- a/sphinx/addnodes.py\n+++ b/sphinx/addnodes.py\n@@ -385,7 +385,7 @@ def setup(app: \"Sphinx\") -> Dict[str, Any]:\n     app.add_node(start_of_file)\n     app.add_node(highlightlang)\n     app.add_node(tabular_col_spec)\n-    app.add_node(meta)\n+    app.add_node(meta, override=True)\n     app.add_node(pending_xref)\n     app.add_node(number_reference)\n     app.add_node(download_reference)\ndiff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..2cb548801 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1049,24 +1049,31 @@ class DocstringSignatureMixin:\n             # no lines in docstring, no match\n             if not doclines:\n                 continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n+            # scan consecutive leading lines of docstring for signature RE matches\n+            j = 0\n+            signatures = []\n+            while j < len(doclines):\n+                match = py_ext_sig_re.match(doclines[j])\n+                if not match:\n+                    break\n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base not in valid_names:\n+                    break\n+                signatures.append((args, retann))\n+                j += 1\n+            if not signatures:\n                 continue\n             # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j:]), tabsize=tab_width)\n+            # use the first signature for formatting, but consume all found signature lines\n+            result = signatures[0]\n             # don't look any further\n             break\n         return result\n"
  },
  "sphinx-doc__sphinx-7757": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7757",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 15f0d66e2..0fcef04ef 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -88,6 +88,8 @@ def getargspec(func: Callable) -> Any:\n \n         if kind is Parameter.POSITIONAL_ONLY:\n             args.append(name)\n+            if param.default is not param.empty:\n+                defaults += (param.default,)\n         elif kind is Parameter.POSITIONAL_OR_KEYWORD:\n             args.append(name)\n             if param.default is not param.empty:\n"
  },
  "sphinx-doc__sphinx-7985": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-7985",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..2cd155476 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -213,7 +213,55 @@ class CheckExternalLinksBuilder(Builder):\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # local link: check existence in documentation sources or filesystem\n+                # split off anchor\n+                if '#' in uri:\n+                    req_url, anchor = uri.split('#', 1)\n+                    for rex in self.anchors_ignore:\n+                        if rex.match(anchor):\n+                            anchor = None\n+                            break\n+                else:\n+                    req_url = uri\n+                    anchor = None\n+\n+                # resolve relative filename to absolute path\n+                try:\n+                    rel_fn, abs_path = self.env.relfn2path(req_url, docname)\n+                except Exception:\n+                    # can't resolve path; treat as local\n+                    return 'local', '', 0\n+\n+                # check if the target is a documentation source\n+                doc = self.env.path2doc(abs_path)\n+                if doc:\n+                    # document exists\n+                    if anchor and self.app.config.linkcheck_anchors:\n+                        try:\n+                            doctree = self.env.get_doctree(doc)\n+                            if anchor in doctree.ids:\n+                                return 'working', '', 0\n+                            # also check named/anon labels in std domain\n+                            try:\n+                                std = self.env.get_domain('std')\n+                            except Exception:\n+                                std = None\n+                            if std:\n+                                if anchor in std.labels or anchor in std.anonlabels:\n+                                    return 'working', '', 0\n+                        except Exception:\n+                            pass\n+                        return 'broken', __(\"Anchor '%s' not found\") % anchor, 0\n+                    else:\n+                        return 'working', '', 0\n+                else:\n+                    # not a documentation source file; check filesystem\n+                    try:\n+                        if path.exists(abs_path):\n+                            return 'working', '', 0\n+                    except Exception:\n+                        pass\n+                    return 'broken', __(\"local file %r not found\") % req_url, 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n"
  },
  "sphinx-doc__sphinx-8035": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8035",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 8c3509c3b..b984bd4ff 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -859,7 +859,7 @@ class ModuleDocumenter(Documenter):\n         'show-inheritance': bool_option, 'synopsis': identity,\n         'platform': identity, 'deprecated': bool_option,\n         'member-order': member_order_option, 'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n         'imported-members': bool_option, 'ignore-module-all': bool_option\n     }  # type: Dict[str, Callable]\n \n@@ -1279,7 +1279,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         'noindex': bool_option, 'inherited-members': inherited_members_option,\n         'show-inheritance': bool_option, 'member-order': member_order_option,\n         'exclude-members': members_set_option,\n-        'private-members': bool_option, 'special-members': members_option,\n+        'private-members': members_option, 'special-members': members_option,\n     }  # type: Dict[str, Callable]\n \n     _signature_class = None  # type: Any\n"
  },
  "sphinx-doc__sphinx-8056": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8056",
    "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex b3daa06f1..5f5a1f1e5 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -391,16 +391,22 @@ class GoogleDocstring:\n                                 ) -> List[str]:\n         lines = []\n         for _name, _type, _desc in fields:\n+            # split multiple parameter names (e.g., \"x1, x2 : type\") so each\n+            # parameter gets its own :param and :type directive\n+            names = [n.strip() for n in _name.split(',')] if _name else ['']\n             _desc = self._strip_empty(_desc)\n             if any(_desc):\n                 _desc = self._fix_field_desc(_desc)\n-                field = ':%s %s: ' % (field_role, _name)\n-                lines.extend(self._format_block(field, _desc))\n+                for name in names:\n+                    field = ':%s %s: ' % (field_role, name)\n+                    lines.extend(self._format_block(field, _desc))\n+                    if _type:\n+                        lines.append(':%s %s: %s' % (type_role, name, _type))\n             else:\n-                lines.append(':%s %s:' % (field_role, _name))\n-\n-            if _type:\n-                lines.append(':%s %s: %s' % (type_role, _name, _type))\n+                for name in names:\n+                    lines.append(':%s %s:' % (field_role, name))\n+                    if _type:\n+                        lines.append(':%s %s: %s' % (type_role, name, _type))\n         return lines + ['']\n \n     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n"
  },
  "sphinx-doc__sphinx-8265": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8265",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex f4bc58b69..0698589ad 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -36,7 +36,7 @@ from sphinx.roles import XRefRole\n from sphinx.util import logging\n from sphinx.util.docfields import Field, GroupedField, TypedField\n from sphinx.util.docutils import SphinxDirective\n-from sphinx.util.inspect import signature_from_str\n+from sphinx.util.inspect import signature_from_str, object_description\n from sphinx.util.nodes import make_id, make_refnode\n from sphinx.util.typing import TextlikeNode\n \n@@ -202,8 +202,15 @@ def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_\n                 node += nodes.Text(' ')\n             else:\n                 node += addnodes.desc_sig_operator('', '=')\n-            node += nodes.inline('', param.default, classes=['default_value'],\n-                                 support_smartquotes=False)\n+            if isinstance(param.default, str):\n+                default_text = param.default\n+                # if the default looks like a comma-separated sequence (e.g. '1, 1, 1')\n+                # but is not already wrapped in (), [], {}, or quotes, add parentheses\n+                if ',' in default_text and not default_text.lstrip().startswith(('(', '[', '{', \"'\", '\"')):\n+                    default_text = '(' + default_text + ')'\n+            else:\n+                default_text = param.default\n+            node += nodes.inline('', default_text, classes=['default_value'], support_smartquotes=False)\n \n         params += node\n         last_kind = param.kind\n"
  },
  "sphinx-doc__sphinx-8475": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8475",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 1dc0337c3..4104fe658 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -20,7 +20,7 @@ from urllib.parse import unquote, urlparse\n \n from docutils import nodes\n from docutils.nodes import Node\n-from requests.exceptions import HTTPError\n+from requests.exceptions import HTTPError, TooManyRedirects\n \n from sphinx.application import Sphinx\n from sphinx.builders import Builder\n@@ -172,7 +172,7 @@ class CheckExternalLinksBuilder(Builder):\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\n-                    except HTTPError:\n+                    except (HTTPError, TooManyRedirects):\n                         # retry with GET request if that fails, some servers\n                         # don't like HEAD requests.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n"
  },
  "sphinx-doc__sphinx-8548": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8548",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex ddfd2b365..96cb820a9 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -606,6 +606,29 @@ class Documenter:\n \n                     for i, line in enumerate(self.process_doc(docstrings)):\n                         self.add_line(line, sourcename, i)\n+                else:\n+                    # try to find attribute comments in base classes' modules\n+                    try:\n+                        parent = self.parent\n+                        if parent and inspect.isclass(parent):\n+                            for cls in inspect.getmro(parent):\n+                                try:\n+                                    module = safe_getattr(cls, '__module__')\n+                                    qualname = safe_getattr(cls, '__qualname__')\n+                                    if module and qualname:\n+                                        analyzer2 = ModuleAnalyzer.for_module(module)\n+                                        analyzer2.analyze()\n+                                        key2 = (qualname, self.objpath[-1])\n+                                        if key2 in analyzer2.attr_docs:\n+                                            no_docstring = True\n+                                            docstrings = [list(analyzer2.attr_docs[key2])]\n+                                            for i, line in enumerate(self.process_doc(docstrings)):\n+                                                self.add_line(line, sourcename, i)\n+                                            break\n+                                except Exception:\n+                                    continue\n+                    except Exception:\n+                        pass\n \n         # add content from docstrings\n         if not no_docstring:\n@@ -756,7 +779,31 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n-            elif want_all and isprivate:\n+            else:\n+                # look for attribute documentation in base classes' modules\n+                try:\n+                    if inspect.isclass(self.object):\n+                        for cls in inspect.getmro(self.object)[1:]:\n+                            try:\n+                                module = safe_getattr(cls, '__module__')\n+                                qualname = safe_getattr(cls, '__qualname__')\n+                                if module and qualname:\n+                                    analyzer2 = ModuleAnalyzer.for_module(module)\n+                                    analyzer2.analyze()\n+                                    if (qualname, membername) in analyzer2.attr_docs:\n+                                        if want_all and isprivate:\n+                                            if self.options.private_members is None:\n+                                                keep = False\n+                                            else:\n+                                                keep = membername in self.options.private_members\n+                                        else:\n+                                            keep = True\n+                                        isattr = True\n+                                        break\n+                            except Exception:\n+                                continue\n+                except Exception:\n+                    pass\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n                         keep = False\n@@ -766,7 +813,6 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n-            else:\n                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n                     keep = False\n                 else:\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex d6e73d36a..99db99047 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -314,6 +314,24 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable,\n             if namespace == ns and name not in members:\n                 members[name] = ClassAttribute(subject, name, INSTANCEATTR,\n                                                '\\n'.join(docstring))\n+        # also check base classes' modules for attribute comments (inherited attributes)\n+        try:\n+            for cls in getattr(subject, '__mro__', [])[1:]:\n+                try:\n+                    module = safe_getattr(cls, '__module__')\n+                    qualname = safe_getattr(cls, '__qualname__')\n+                    if module and qualname:\n+                        analyzer2 = ModuleAnalyzer.for_module(module)\n+                        analyzer2.analyze()\n+                        for (ns2, name2), doc2 in analyzer2.attr_docs.items():\n+                            if ns2 == qualname and name2 not in members:\n+                                members[name2] = ClassAttribute(cls, name2, INSTANCEATTR,\n+                                                               '\\n'.join(doc2))\n+                except Exception:\n+                    # ignore problems loading/analyzing base class modules\n+                    continue\n+        except Exception:\n+            pass\n \n     return members\n \n"
  },
  "sphinx-doc__sphinx-8551": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8551",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 79d7e4f46..242f764b0 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1335,6 +1335,14 @@ class PythonDomain(Domain):\n                                              contnode, name)))\n         return results\n \n+    def process_field_xref(self, pnode: pending_xref) -> None:\n+        \"\"\"Process a pending xref created in a doc field.\n+        Attach information about the current Python scope (module/class) so\n+        that info-field references like :type: and :rtype: are resolved using\n+        the current ref_context (py:module, py:class).\n+        \"\"\"\n+        pnode.attributes.update(self.env.ref_context)\n+\n     def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,\n                              contnode: Node) -> Element:\n         # get additional info for modules\n"
  },
  "sphinx-doc__sphinx-8638": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8638",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 000e2e8d3..71d781fb8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1155,11 +1155,10 @@ class PythonDomain(Domain):\n                     elif name in self.objects and self.objects[name].objtype in objtypes:\n                         newname = name\n                     else:\n-                        # \"fuzzy\" searching mode\n-                        searchname = '.' + name\n-                        matches = [(oname, self.objects[oname]) for oname in self.objects\n-                                   if oname.endswith(searchname) and\n-                                   self.objects[oname].objtype in objtypes]\n+\n+                        # fuzzy searching disabled to avoid linking unrelated objects with the same name\n+\n+                        matches = []\n         else:\n             # NOTE: searching for exact match, object type is not considered\n             if name in self.objects:\ndiff --git a/sphinx/domains/python.py.bak b/sphinx/domains/python.py.bak\nnew file mode 100644\nindex 000000000..000e2e8d3\n--- /dev/null\n+++ b/sphinx/domains/python.py.bak\n@@ -0,0 +1,1299 @@\n+\"\"\"\n+    sphinx.domains.python\n+    ~~~~~~~~~~~~~~~~~~~~~\n+\n+    The Python domain.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import builtins\n+import inspect\n+import re\n+import sys\n+import typing\n+import warnings\n+from inspect import Parameter\n+from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Tuple, Type, cast\n+\n+from docutils import nodes\n+from docutils.nodes import Element, Node\n+from docutils.parsers.rst import directives\n+\n+from sphinx import addnodes\n+from sphinx.addnodes import desc_signature, pending_xref\n+from sphinx.application import Sphinx\n+from sphinx.builders import Builder\n+from sphinx.deprecation import RemovedInSphinx50Warning\n+from sphinx.directives import ObjectDescription\n+from sphinx.domains import Domain, Index, IndexEntry, ObjType\n+from sphinx.environment import BuildEnvironment\n+from sphinx.locale import _, __\n+from sphinx.pycode.ast import ast\n+from sphinx.pycode.ast import parse as ast_parse\n+from sphinx.roles import XRefRole\n+from sphinx.util import logging\n+from sphinx.util.docfields import Field, GroupedField, TypedField\n+from sphinx.util.docutils import SphinxDirective\n+from sphinx.util.inspect import signature_from_str\n+from sphinx.util.nodes import make_id, make_refnode\n+from sphinx.util.typing import TextlikeNode\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+# REs for Python signatures\n+py_sig_re = re.compile(\n+    r'''^ ([\\w.]*\\.)?            # class name(s)\n+          (\\w+)  \\s*             # thing name\n+          (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n+           (?:\\s* -> \\s* (.*))?  #           return annotation\n+          )? $                   # and nothing more\n+          ''', re.VERBOSE)\n+\n+\n+pairindextypes = {\n+    'module':    _('module'),\n+    'keyword':   _('keyword'),\n+    'operator':  _('operator'),\n+    'object':    _('object'),\n+    'exception': _('exception'),\n+    'statement': _('statement'),\n+    'builtin':   _('built-in function'),\n+}\n+\n+\n+class ObjectEntry(NamedTuple):\n+    docname: str\n+    node_id: str\n+    objtype: str\n+    canonical: bool\n+\n+\n+class ModuleEntry(NamedTuple):\n+    docname: str\n+    node_id: str\n+    synopsis: str\n+    platform: str\n+    deprecated: bool\n+\n+\n+def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n+    \"\"\"Convert a type string to a cross reference node.\"\"\"\n+    if text == 'None':\n+        reftype = 'obj'\n+    else:\n+        reftype = 'class'\n+\n+    if env:\n+        kwargs = {'py:module': env.ref_context.get('py:module'),\n+                  'py:class': env.ref_context.get('py:class')}\n+    else:\n+        kwargs = {}\n+\n+    return pending_xref('', nodes.Text(text),\n+                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+\n+\n+def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n+    \"\"\"Parse type annotation.\"\"\"\n+    def unparse(node: ast.AST) -> List[Node]:\n+        if isinstance(node, ast.Attribute):\n+            return [nodes.Text(\"%s.%s\" % (unparse(node.value)[0], node.attr))]\n+        elif isinstance(node, ast.Constant):  # type: ignore\n+            if node.value is Ellipsis:\n+                return [addnodes.desc_sig_punctuation('', \"...\")]\n+            else:\n+                return [nodes.Text(node.value)]\n+        elif isinstance(node, ast.Expr):\n+            return unparse(node.value)\n+        elif isinstance(node, ast.Index):\n+            return unparse(node.value)\n+        elif isinstance(node, ast.List):\n+            result = [addnodes.desc_sig_punctuation('', '[')]  # type: List[Node]\n+            for elem in node.elts:\n+                result.extend(unparse(elem))\n+                result.append(addnodes.desc_sig_punctuation('', ', '))\n+            result.pop()\n+            result.append(addnodes.desc_sig_punctuation('', ']'))\n+            return result\n+        elif isinstance(node, ast.Module):\n+            return sum((unparse(e) for e in node.body), [])\n+        elif isinstance(node, ast.Name):\n+            return [nodes.Text(node.id)]\n+        elif isinstance(node, ast.Subscript):\n+            result = unparse(node.value)\n+            result.append(addnodes.desc_sig_punctuation('', '['))\n+            result.extend(unparse(node.slice))\n+            result.append(addnodes.desc_sig_punctuation('', ']'))\n+            return result\n+        elif isinstance(node, ast.Tuple):\n+            if node.elts:\n+                result = []\n+                for elem in node.elts:\n+                    result.extend(unparse(elem))\n+                    result.append(addnodes.desc_sig_punctuation('', ', '))\n+                result.pop()\n+            else:\n+                result = [addnodes.desc_sig_punctuation('', '('),\n+                          addnodes.desc_sig_punctuation('', ')')]\n+\n+            return result\n+        else:\n+            if sys.version_info < (3, 8):\n+                if isinstance(node, ast.Ellipsis):\n+                    return [addnodes.desc_sig_punctuation('', \"...\")]\n+                elif isinstance(node, ast.NameConstant):\n+                    return [nodes.Text(node.value)]\n+\n+            raise SyntaxError  # unsupported syntax\n+\n+    if env is None:\n+        warnings.warn(\"The env parameter for _parse_annotation becomes required now.\",\n+                      RemovedInSphinx50Warning, stacklevel=2)\n+\n+    try:\n+        tree = ast_parse(annotation)\n+        result = unparse(tree)\n+        for i, node in enumerate(result):\n+            if isinstance(node, nodes.Text):\n+                result[i] = type_to_xref(str(node), env)\n+        return result\n+    except SyntaxError:\n+        return [type_to_xref(annotation, env)]\n+\n+\n+def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\n+    \"\"\"Parse a list of arguments using AST parser\"\"\"\n+    params = addnodes.desc_parameterlist(arglist)\n+    sig = signature_from_str('(%s)' % arglist)\n+    last_kind = None\n+    for param in sig.parameters.values():\n+        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n+            # PEP-570: Separator for Positional Only Parameter: /\n+            params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n+        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n+                                                              param.POSITIONAL_ONLY,\n+                                                              None):\n+            # PEP-3102: Separator for Keyword Only Parameter: *\n+            params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '*'))\n+\n+        node = addnodes.desc_parameter()\n+        if param.kind == param.VAR_POSITIONAL:\n+            node += addnodes.desc_sig_operator('', '*')\n+            node += addnodes.desc_sig_name('', param.name)\n+        elif param.kind == param.VAR_KEYWORD:\n+            node += addnodes.desc_sig_operator('', '**')\n+            node += addnodes.desc_sig_name('', param.name)\n+        else:\n+            node += addnodes.desc_sig_name('', param.name)\n+\n+        if param.annotation is not param.empty:\n+            children = _parse_annotation(param.annotation, env)\n+            node += addnodes.desc_sig_punctuation('', ':')\n+            node += nodes.Text(' ')\n+            node += addnodes.desc_sig_name('', '', *children)  # type: ignore\n+        if param.default is not param.empty:\n+            if param.annotation is not param.empty:\n+                node += nodes.Text(' ')\n+                node += addnodes.desc_sig_operator('', '=')\n+                node += nodes.Text(' ')\n+            else:\n+                node += addnodes.desc_sig_operator('', '=')\n+            node += nodes.inline('', param.default, classes=['default_value'],\n+                                 support_smartquotes=False)\n+\n+        params += node\n+        last_kind = param.kind\n+\n+    if last_kind == Parameter.POSITIONAL_ONLY:\n+        # PEP-570: Separator for Positional Only Parameter: /\n+        params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n+\n+    return params\n+\n+\n+def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\n+    \"\"\"\"Parse\" a list of arguments separated by commas.\n+\n+    Arguments can have \"optional\" annotations given by enclosing them in\n+    brackets.  Currently, this will split at any comma, even if it's inside a\n+    string literal (e.g. default argument value).\n+    \"\"\"\n+    paramlist = addnodes.desc_parameterlist()\n+    stack = [paramlist]  # type: List[Element]\n+    try:\n+        for argument in arglist.split(','):\n+            argument = argument.strip()\n+            ends_open = ends_close = 0\n+            while argument.startswith('['):\n+                stack.append(addnodes.desc_optional())\n+                stack[-2] += stack[-1]\n+                argument = argument[1:].strip()\n+            while argument.startswith(']'):\n+                stack.pop()\n+                argument = argument[1:].strip()\n+            while argument.endswith(']') and not argument.endswith('[]'):\n+                ends_close += 1\n+                argument = argument[:-1].strip()\n+            while argument.endswith('['):\n+                ends_open += 1\n+                argument = argument[:-1].strip()\n+            if argument:\n+                stack[-1] += addnodes.desc_parameter(argument, argument)\n+            while ends_open:\n+                stack.append(addnodes.desc_optional())\n+                stack[-2] += stack[-1]\n+                ends_open -= 1\n+            while ends_close:\n+                stack.pop()\n+                ends_close -= 1\n+        if len(stack) != 1:\n+            raise IndexError\n+    except IndexError:\n+        # if there are too few or too many elements on the stack, just give up\n+        # and treat the whole argument list as one argument, discarding the\n+        # already partially populated paramlist node\n+        paramlist = addnodes.desc_parameterlist()\n+        paramlist += addnodes.desc_parameter(arglist, arglist)\n+        signode += paramlist\n+    else:\n+        signode += paramlist\n+\n+\n+# This override allows our inline type specifiers to behave like :class: link\n+# when it comes to handling \".\" and \"~\" prefixes.\n+class PyXrefMixin:\n+    def make_xref(self, rolename: str, domain: str, target: str,\n+                  innernode: Type[TextlikeNode] = nodes.emphasis,\n+                  contnode: Node = None, env: BuildEnvironment = None) -> Node:\n+        result = super().make_xref(rolename, domain, target,  # type: ignore\n+                                   innernode, contnode, env)\n+        result['refspecific'] = True\n+        result['py:module'] = env.ref_context.get('py:module')\n+        result['py:class'] = env.ref_context.get('py:class')\n+        if target.startswith(('.', '~')):\n+            prefix, result['reftarget'] = target[0], target[1:]\n+            if prefix == '.':\n+                text = target[1:]\n+            elif prefix == '~':\n+                text = target.split('.')[-1]\n+            for node in result.traverse(nodes.Text):\n+                node.parent[node.parent.index(node)] = nodes.Text(text)\n+                break\n+        return result\n+\n+    def make_xrefs(self, rolename: str, domain: str, target: str,\n+                   innernode: Type[TextlikeNode] = nodes.emphasis,\n+                   contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n+        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+)'\n+        delims_re = re.compile(delims)\n+        sub_targets = re.split(delims, target)\n+\n+        split_contnode = bool(contnode and contnode.astext() == target)\n+\n+        results = []\n+        for sub_target in filter(None, sub_targets):\n+            if split_contnode:\n+                contnode = nodes.Text(sub_target)\n+\n+            if delims_re.match(sub_target):\n+                results.append(contnode or innernode(sub_target, sub_target))\n+            else:\n+                results.append(self.make_xref(rolename, domain, sub_target,\n+                                              innernode, contnode, env))\n+\n+        return results\n+\n+\n+class PyField(PyXrefMixin, Field):\n+    def make_xref(self, rolename: str, domain: str, target: str,\n+                  innernode: Type[TextlikeNode] = nodes.emphasis,\n+                  contnode: Node = None, env: BuildEnvironment = None) -> Node:\n+        if rolename == 'class' and target == 'None':\n+            # None is not a type, so use obj role instead.\n+            rolename = 'obj'\n+\n+        return super().make_xref(rolename, domain, target, innernode, contnode, env)\n+\n+\n+class PyGroupedField(PyXrefMixin, GroupedField):\n+    pass\n+\n+\n+class PyTypedField(PyXrefMixin, TypedField):\n+    def make_xref(self, rolename: str, domain: str, target: str,\n+                  innernode: Type[TextlikeNode] = nodes.emphasis,\n+                  contnode: Node = None, env: BuildEnvironment = None) -> Node:\n+        if rolename == 'class' and target == 'None':\n+            # None is not a type, so use obj role instead.\n+            rolename = 'obj'\n+\n+        return super().make_xref(rolename, domain, target, innernode, contnode, env)\n+\n+\n+class PyObject(ObjectDescription):\n+    \"\"\"\n+    Description of a general Python object.\n+\n+    :cvar allow_nesting: Class is an object that allows for nested namespaces\n+    :vartype allow_nesting: bool\n+    \"\"\"\n+    option_spec = {\n+        'noindex': directives.flag,\n+        'noindexentry': directives.flag,\n+        'module': directives.unchanged,\n+        'canonical': directives.unchanged,\n+        'annotation': directives.unchanged,\n+    }\n+\n+    doc_field_types = [\n+        PyTypedField('parameter', label=_('Parameters'),\n+                     names=('param', 'parameter', 'arg', 'argument',\n+                            'keyword', 'kwarg', 'kwparam'),\n+                     typerolename='class', typenames=('paramtype', 'type'),\n+                     can_collapse=True),\n+        PyTypedField('variable', label=_('Variables'), rolename='obj',\n+                     names=('var', 'ivar', 'cvar'),\n+                     typerolename='class', typenames=('vartype',),\n+                     can_collapse=True),\n+        PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n+                       names=('raises', 'raise', 'exception', 'except'),\n+                       can_collapse=True),\n+        Field('returnvalue', label=_('Returns'), has_arg=False,\n+              names=('returns', 'return')),\n+        PyField('returntype', label=_('Return type'), has_arg=False,\n+                names=('rtype',), bodyrolename='class'),\n+    ]\n+\n+    allow_nesting = False\n+\n+    def get_signature_prefix(self, sig: str) -> str:\n+        \"\"\"May return a prefix to put before the object name in the\n+        signature.\n+        \"\"\"\n+        return ''\n+\n+    def needs_arglist(self) -> bool:\n+        \"\"\"May return true if an empty argument list is to be generated even if\n+        the document contains none.\n+        \"\"\"\n+        return False\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n+        \"\"\"Transform a Python signature into RST nodes.\n+\n+        Return (fully qualified name of the thing, classname if any).\n+\n+        If inside a class, the current class name is handled intelligently:\n+        * it is stripped from the displayed name if present\n+        * it is added to the full name (return value) if not present\n+        \"\"\"\n+        m = py_sig_re.match(sig)\n+        if m is None:\n+            raise ValueError\n+        prefix, name, arglist, retann = m.groups()\n+\n+        # determine module and class name (if applicable), as well as full name\n+        modname = self.options.get('module', self.env.ref_context.get('py:module'))\n+        classname = self.env.ref_context.get('py:class')\n+        if classname:\n+            add_module = False\n+            if prefix and (prefix == classname or\n+                           prefix.startswith(classname + \".\")):\n+                fullname = prefix + name\n+                # class name is given again in the signature\n+                prefix = prefix[len(classname):].lstrip('.')\n+            elif prefix:\n+                # class name is given in the signature, but different\n+                # (shouldn't happen)\n+                fullname = classname + '.' + prefix + name\n+            else:\n+                # class name is not given in the signature\n+                fullname = classname + '.' + name\n+        else:\n+            add_module = True\n+            if prefix:\n+                classname = prefix.rstrip('.')\n+                fullname = prefix + name\n+            else:\n+                classname = ''\n+                fullname = name\n+\n+        signode['module'] = modname\n+        signode['class'] = classname\n+        signode['fullname'] = fullname\n+\n+        sig_prefix = self.get_signature_prefix(sig)\n+        if sig_prefix:\n+            signode += addnodes.desc_annotation(sig_prefix, sig_prefix)\n+\n+        if prefix:\n+            signode += addnodes.desc_addname(prefix, prefix)\n+        elif add_module and self.env.config.add_module_names:\n+            if modname and modname != 'exceptions':\n+                # exceptions are a special case, since they are documented in the\n+                # 'exceptions' module.\n+                nodetext = modname + '.'\n+                signode += addnodes.desc_addname(nodetext, nodetext)\n+\n+        signode += addnodes.desc_name(name, name)\n+        if arglist:\n+            try:\n+                signode += _parse_arglist(arglist, self.env)\n+            except SyntaxError:\n+                # fallback to parse arglist original parser.\n+                # it supports to represent optional arguments (ex. \"func(foo [, bar])\")\n+                _pseudo_parse_arglist(signode, arglist)\n+            except NotImplementedError as exc:\n+                logger.warning(\"could not parse arglist (%r): %s\", arglist, exc,\n+                               location=signode)\n+                _pseudo_parse_arglist(signode, arglist)\n+        else:\n+            if self.needs_arglist():\n+                # for callables, add an empty parameter list\n+                signode += addnodes.desc_parameterlist()\n+\n+        if retann:\n+            children = _parse_annotation(retann, self.env)\n+            signode += addnodes.desc_returns(retann, '', *children)\n+\n+        anno = self.options.get('annotation')\n+        if anno:\n+            signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)\n+\n+        return fullname, prefix\n+\n+    def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:\n+        \"\"\"Return the text for the index entry of the object.\"\"\"\n+        raise NotImplementedError('must be implemented in subclasses')\n+\n+    def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n+                             signode: desc_signature) -> None:\n+        modname = self.options.get('module', self.env.ref_context.get('py:module'))\n+        fullname = (modname + '.' if modname else '') + name_cls[0]\n+        node_id = make_id(self.env, self.state.document, '', fullname)\n+        signode['ids'].append(node_id)\n+\n+        # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)\n+        # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n+        if node_id != fullname and fullname not in self.state.document.ids:\n+            signode['ids'].append(fullname)\n+\n+        self.state.document.note_explicit_target(signode)\n+\n+        domain = cast(PythonDomain, self.env.get_domain('py'))\n+        domain.note_object(fullname, self.objtype, node_id, location=signode)\n+\n+        canonical_name = self.options.get('canonical')\n+        if canonical_name:\n+            domain.note_object(canonical_name, self.objtype, node_id, canonical=True,\n+                               location=signode)\n+\n+        if 'noindexentry' not in self.options:\n+            indextext = self.get_index_text(modname, name_cls)\n+            if indextext:\n+                self.indexnode['entries'].append(('single', indextext, node_id, '', None))\n+\n+    def before_content(self) -> None:\n+        \"\"\"Handle object nesting before content\n+\n+        :py:class:`PyObject` represents Python language constructs. For\n+        constructs that are nestable, such as a Python classes, this method will\n+        build up a stack of the nesting hierarchy so that it can be later\n+        de-nested correctly, in :py:meth:`after_content`.\n+\n+        For constructs that aren't nestable, the stack is bypassed, and instead\n+        only the most recent object is tracked. This object prefix name will be\n+        removed with :py:meth:`after_content`.\n+        \"\"\"\n+        prefix = None\n+        if self.names:\n+            # fullname and name_prefix come from the `handle_signature` method.\n+            # fullname represents the full object name that is constructed using\n+            # object nesting and explicit prefixes. `name_prefix` is the\n+            # explicit prefix given in a signature\n+            (fullname, name_prefix) = self.names[-1]\n+            if self.allow_nesting:\n+                prefix = fullname\n+            elif name_prefix:\n+                prefix = name_prefix.strip('.')\n+        if prefix:\n+            self.env.ref_context['py:class'] = prefix\n+            if self.allow_nesting:\n+                classes = self.env.ref_context.setdefault('py:classes', [])\n+                classes.append(prefix)\n+        if 'module' in self.options:\n+            modules = self.env.ref_context.setdefault('py:modules', [])\n+            modules.append(self.env.ref_context.get('py:module'))\n+            self.env.ref_context['py:module'] = self.options['module']\n+\n+    def after_content(self) -> None:\n+        \"\"\"Handle object de-nesting after content\n+\n+        If this class is a nestable object, removing the last nested class prefix\n+        ends further nesting in the object.\n+\n+        If this class is not a nestable object, the list of classes should not\n+        be altered as we didn't affect the nesting levels in\n+        :py:meth:`before_content`.\n+        \"\"\"\n+        classes = self.env.ref_context.setdefault('py:classes', [])\n+        if self.allow_nesting:\n+            try:\n+                classes.pop()\n+            except IndexError:\n+                pass\n+        self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0\n+                                            else None)\n+        if 'module' in self.options:\n+            modules = self.env.ref_context.setdefault('py:modules', [])\n+            if modules:\n+                self.env.ref_context['py:module'] = modules.pop()\n+            else:\n+                self.env.ref_context.pop('py:module')\n+\n+\n+class PyFunction(PyObject):\n+    \"\"\"Description of a function.\"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+    option_spec.update({\n+        'async': directives.flag,\n+    })\n+\n+    def get_signature_prefix(self, sig: str) -> str:\n+        if 'async' in self.options:\n+            return 'async '\n+        else:\n+            return ''\n+\n+    def needs_arglist(self) -> bool:\n+        return True\n+\n+    def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n+                             signode: desc_signature) -> None:\n+        super().add_target_and_index(name_cls, sig, signode)\n+        if 'noindexentry' not in self.options:\n+            modname = self.options.get('module', self.env.ref_context.get('py:module'))\n+            node_id = signode['ids'][0]\n+\n+            name, cls = name_cls\n+            if modname:\n+                text = _('%s() (in module %s)') % (name, modname)\n+                self.indexnode['entries'].append(('single', text, node_id, '', None))\n+            else:\n+                text = '%s; %s()' % (pairindextypes['builtin'], name)\n+                self.indexnode['entries'].append(('pair', text, node_id, '', None))\n+\n+    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n+        # add index in own add_target_and_index() instead.\n+        return None\n+\n+\n+class PyDecoratorFunction(PyFunction):\n+    \"\"\"Description of a decorator.\"\"\"\n+\n+    def run(self) -> List[Node]:\n+        # a decorator function is a function after all\n+        self.name = 'py:function'\n+        return super().run()\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n+        ret = super().handle_signature(sig, signode)\n+        signode.insert(0, addnodes.desc_addname('@', '@'))\n+        return ret\n+\n+    def needs_arglist(self) -> bool:\n+        return False\n+\n+\n+class PyVariable(PyObject):\n+    \"\"\"Description of a variable.\"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+    option_spec.update({\n+        'type': directives.unchanged,\n+        'value': directives.unchanged,\n+    })\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n+        fullname, prefix = super().handle_signature(sig, signode)\n+\n+        typ = self.options.get('type')\n+        if typ:\n+            annotations = _parse_annotation(typ, self.env)\n+            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *annotations)\n+\n+        value = self.options.get('value')\n+        if value:\n+            signode += addnodes.desc_annotation(value, ' = ' + value)\n+\n+        return fullname, prefix\n+\n+    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n+        name, cls = name_cls\n+        if modname:\n+            return _('%s (in module %s)') % (name, modname)\n+        else:\n+            return _('%s (built-in variable)') % name\n+\n+\n+class PyClasslike(PyObject):\n+    \"\"\"\n+    Description of a class-like object (classes, interfaces, exceptions).\n+    \"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+    option_spec.update({\n+        'final': directives.flag,\n+    })\n+\n+    allow_nesting = True\n+\n+    def get_signature_prefix(self, sig: str) -> str:\n+        if 'final' in self.options:\n+            return 'final %s ' % self.objtype\n+        else:\n+            return '%s ' % self.objtype\n+\n+    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n+        if self.objtype == 'class':\n+            if not modname:\n+                return _('%s (built-in class)') % name_cls[0]\n+            return _('%s (class in %s)') % (name_cls[0], modname)\n+        elif self.objtype == 'exception':\n+            return name_cls[0]\n+        else:\n+            return ''\n+\n+\n+class PyMethod(PyObject):\n+    \"\"\"Description of a method.\"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+    option_spec.update({\n+        'abstractmethod': directives.flag,\n+        'async': directives.flag,\n+        'classmethod': directives.flag,\n+        'final': directives.flag,\n+        'property': directives.flag,\n+        'staticmethod': directives.flag,\n+    })\n+\n+    def needs_arglist(self) -> bool:\n+        if 'property' in self.options:\n+            return False\n+        else:\n+            return True\n+\n+    def get_signature_prefix(self, sig: str) -> str:\n+        prefix = []\n+        if 'final' in self.options:\n+            prefix.append('final')\n+        if 'abstractmethod' in self.options:\n+            prefix.append('abstract')\n+        if 'async' in self.options:\n+            prefix.append('async')\n+        if 'classmethod' in self.options:\n+            prefix.append('classmethod')\n+        if 'property' in self.options:\n+            prefix.append('property')\n+        if 'staticmethod' in self.options:\n+            prefix.append('static')\n+\n+        if prefix:\n+            return ' '.join(prefix) + ' '\n+        else:\n+            return ''\n+\n+    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n+        name, cls = name_cls\n+        try:\n+            clsname, methname = name.rsplit('.', 1)\n+            if modname and self.env.config.add_module_names:\n+                clsname = '.'.join([modname, clsname])\n+        except ValueError:\n+            if modname:\n+                return _('%s() (in module %s)') % (name, modname)\n+            else:\n+                return '%s()' % name\n+\n+        if 'classmethod' in self.options:\n+            return _('%s() (%s class method)') % (methname, clsname)\n+        elif 'property' in self.options:\n+            return _('%s() (%s property)') % (methname, clsname)\n+        elif 'staticmethod' in self.options:\n+            return _('%s() (%s static method)') % (methname, clsname)\n+        else:\n+            return _('%s() (%s method)') % (methname, clsname)\n+\n+\n+class PyClassMethod(PyMethod):\n+    \"\"\"Description of a classmethod.\"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+\n+    def run(self) -> List[Node]:\n+        self.name = 'py:method'\n+        self.options['classmethod'] = True\n+\n+        return super().run()\n+\n+\n+class PyStaticMethod(PyMethod):\n+    \"\"\"Description of a staticmethod.\"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+\n+    def run(self) -> List[Node]:\n+        self.name = 'py:method'\n+        self.options['staticmethod'] = True\n+\n+        return super().run()\n+\n+\n+class PyDecoratorMethod(PyMethod):\n+    \"\"\"Description of a decoratormethod.\"\"\"\n+\n+    def run(self) -> List[Node]:\n+        self.name = 'py:method'\n+        return super().run()\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n+        ret = super().handle_signature(sig, signode)\n+        signode.insert(0, addnodes.desc_addname('@', '@'))\n+        return ret\n+\n+    def needs_arglist(self) -> bool:\n+        return False\n+\n+\n+class PyAttribute(PyObject):\n+    \"\"\"Description of an attribute.\"\"\"\n+\n+    option_spec = PyObject.option_spec.copy()\n+    option_spec.update({\n+        'type': directives.unchanged,\n+        'value': directives.unchanged,\n+    })\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n+        fullname, prefix = super().handle_signature(sig, signode)\n+\n+        typ = self.options.get('type')\n+        if typ:\n+            annotations = _parse_annotation(typ, self.env)\n+            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *annotations)\n+\n+        value = self.options.get('value')\n+        if value:\n+            signode += addnodes.desc_annotation(value, ' = ' + value)\n+\n+        return fullname, prefix\n+\n+    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n+        name, cls = name_cls\n+        try:\n+            clsname, attrname = name.rsplit('.', 1)\n+            if modname and self.env.config.add_module_names:\n+                clsname = '.'.join([modname, clsname])\n+        except ValueError:\n+            if modname:\n+                return _('%s (in module %s)') % (name, modname)\n+            else:\n+                return name\n+\n+        return _('%s (%s attribute)') % (attrname, clsname)\n+\n+\n+class PyDecoratorMixin:\n+    \"\"\"\n+    Mixin for decorator directives.\n+    \"\"\"\n+    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n+        for cls in self.__class__.__mro__:\n+            if cls.__name__ != 'DirectiveAdapter':\n+                warnings.warn('PyDecoratorMixin is deprecated. '\n+                              'Please check the implementation of %s' % cls,\n+                              RemovedInSphinx50Warning, stacklevel=2)\n+                break\n+        else:\n+            warnings.warn('PyDecoratorMixin is deprecated',\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+        ret = super().handle_signature(sig, signode)  # type: ignore\n+        signode.insert(0, addnodes.desc_addname('@', '@'))\n+        return ret\n+\n+    def needs_arglist(self) -> bool:\n+        return False\n+\n+\n+class PyModule(SphinxDirective):\n+    \"\"\"\n+    Directive to mark description of a new module.\n+    \"\"\"\n+\n+    has_content = False\n+    required_arguments = 1\n+    optional_arguments = 0\n+    final_argument_whitespace = False\n+    option_spec = {\n+        'platform': lambda x: x,\n+        'synopsis': lambda x: x,\n+        'noindex': directives.flag,\n+        'deprecated': directives.flag,\n+    }\n+\n+    def run(self) -> List[Node]:\n+        domain = cast(PythonDomain, self.env.get_domain('py'))\n+\n+        modname = self.arguments[0].strip()\n+        noindex = 'noindex' in self.options\n+        self.env.ref_context['py:module'] = modname\n+        ret = []  # type: List[Node]\n+        if not noindex:\n+            # note module to the domain\n+            node_id = make_id(self.env, self.state.document, 'module', modname)\n+            target = nodes.target('', '', ids=[node_id], ismod=True)\n+            self.set_source_info(target)\n+\n+            # Assign old styled node_id not to break old hyperlinks (if possible)\n+            # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n+            old_node_id = self.make_old_id(modname)\n+            if node_id != old_node_id and old_node_id not in self.state.document.ids:\n+                target['ids'].append(old_node_id)\n+\n+            self.state.document.note_explicit_target(target)\n+\n+            domain.note_module(modname,\n+                               node_id,\n+                               self.options.get('synopsis', ''),\n+                               self.options.get('platform', ''),\n+                               'deprecated' in self.options)\n+            domain.note_object(modname, 'module', node_id, location=target)\n+\n+            # the platform and synopsis aren't printed; in fact, they are only\n+            # used in the modindex currently\n+            ret.append(target)\n+            indextext = '%s; %s' % (pairindextypes['module'], modname)\n+            inode = addnodes.index(entries=[('pair', indextext, node_id, '', None)])\n+            ret.append(inode)\n+        return ret\n+\n+    def make_old_id(self, name: str) -> str:\n+        \"\"\"Generate old styled node_id.\n+\n+        Old styled node_id is incompatible with docutils' node_id.\n+        It can contain dots and hyphens.\n+\n+        .. note:: Old styled node_id was mainly used until Sphinx-3.0.\n+        \"\"\"\n+        return 'module-%s' % name\n+\n+\n+class PyCurrentModule(SphinxDirective):\n+    \"\"\"\n+    This directive is just to tell Sphinx that we're documenting\n+    stuff in module foo, but links to module foo won't lead here.\n+    \"\"\"\n+\n+    has_content = False\n+    required_arguments = 1\n+    optional_arguments = 0\n+    final_argument_whitespace = False\n+    option_spec = {}  # type: Dict\n+\n+    def run(self) -> List[Node]:\n+        modname = self.arguments[0].strip()\n+        if modname == 'None':\n+            self.env.ref_context.pop('py:module', None)\n+        else:\n+            self.env.ref_context['py:module'] = modname\n+        return []\n+\n+\n+class PyXRefRole(XRefRole):\n+    def process_link(self, env: BuildEnvironment, refnode: Element,\n+                     has_explicit_title: bool, title: str, target: str) -> Tuple[str, str]:\n+        refnode['py:module'] = env.ref_context.get('py:module')\n+        refnode['py:class'] = env.ref_context.get('py:class')\n+        if not has_explicit_title:\n+            title = title.lstrip('.')    # only has a meaning for the target\n+            target = target.lstrip('~')  # only has a meaning for the title\n+            # if the first character is a tilde, don't display the module/class\n+            # parts of the contents\n+            if title[0:1] == '~':\n+                title = title[1:]\n+                dot = title.rfind('.')\n+                if dot != -1:\n+                    title = title[dot + 1:]\n+        # if the first character is a dot, search more specific namespaces first\n+        # else search builtins first\n+        if target[0:1] == '.':\n+            target = target[1:]\n+            refnode['refspecific'] = True\n+        return title, target\n+\n+\n+def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\n+    \"\"\"Filter ``:meta:`` field from its docstring.\"\"\"\n+    if domain != 'py':\n+        return\n+\n+    for node in content:\n+        if isinstance(node, nodes.field_list):\n+            fields = cast(List[nodes.field], node)\n+            for field in fields:\n+                field_name = cast(nodes.field_body, field[0]).astext().strip()\n+                if field_name == 'meta' or field_name.startswith('meta '):\n+                    node.remove(field)\n+                    break\n+\n+\n+class PythonModuleIndex(Index):\n+    \"\"\"\n+    Index subclass to provide the Python module index.\n+    \"\"\"\n+\n+    name = 'modindex'\n+    localname = _('Python Module Index')\n+    shortname = _('modules')\n+\n+    def generate(self, docnames: Iterable[str] = None\n+                 ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:\n+        content = {}  # type: Dict[str, List[IndexEntry]]\n+        # list of prefixes to ignore\n+        ignores = None  # type: List[str]\n+        ignores = self.domain.env.config['modindex_common_prefix']  # type: ignore\n+        ignores = sorted(ignores, key=len, reverse=True)\n+        # list of all modules, sorted by module name\n+        modules = sorted(self.domain.data['modules'].items(),\n+                         key=lambda x: x[0].lower())\n+        # sort out collapsable modules\n+        prev_modname = ''\n+        num_toplevels = 0\n+        for modname, (docname, node_id, synopsis, platforms, deprecated) in modules:\n+            if docnames and docname not in docnames:\n+                continue\n+\n+            for ignore in ignores:\n+                if modname.startswith(ignore):\n+                    modname = modname[len(ignore):]\n+                    stripped = ignore\n+                    break\n+            else:\n+                stripped = ''\n+\n+            # we stripped the whole module name?\n+            if not modname:\n+                modname, stripped = stripped, ''\n+\n+            entries = content.setdefault(modname[0].lower(), [])\n+\n+            package = modname.split('.')[0]\n+            if package != modname:\n+                # it's a submodule\n+                if prev_modname == package:\n+                    # first submodule - make parent a group head\n+                    if entries:\n+                        last = entries[-1]\n+                        entries[-1] = IndexEntry(last[0], 1, last[2], last[3],\n+                                                 last[4], last[5], last[6])\n+                elif not prev_modname.startswith(package):\n+                    # submodule without parent in list, add dummy entry\n+                    entries.append(IndexEntry(stripped + package, 1, '', '', '', '', ''))\n+                subtype = 2\n+            else:\n+                num_toplevels += 1\n+                subtype = 0\n+\n+            qualifier = _('Deprecated') if deprecated else ''\n+            entries.append(IndexEntry(stripped + modname, subtype, docname,\n+                                      node_id, platforms, qualifier, synopsis))\n+            prev_modname = modname\n+\n+        # apply heuristics when to collapse modindex at page load:\n+        # only collapse if number of toplevel modules is larger than\n+        # number of submodules\n+        collapse = len(modules) - num_toplevels < num_toplevels\n+\n+        # sort by first letter\n+        sorted_content = sorted(content.items())\n+\n+        return sorted_content, collapse\n+\n+\n+class PythonDomain(Domain):\n+    \"\"\"Python language domain.\"\"\"\n+    name = 'py'\n+    label = 'Python'\n+    object_types = {\n+        'function':     ObjType(_('function'),      'func', 'obj'),\n+        'data':         ObjType(_('data'),          'data', 'obj'),\n+        'class':        ObjType(_('class'),         'class', 'exc', 'obj'),\n+        'exception':    ObjType(_('exception'),     'exc', 'class', 'obj'),\n+        'method':       ObjType(_('method'),        'meth', 'obj'),\n+        'classmethod':  ObjType(_('class method'),  'meth', 'obj'),\n+        'staticmethod': ObjType(_('static method'), 'meth', 'obj'),\n+        'attribute':    ObjType(_('attribute'),     'attr', 'obj'),\n+        'module':       ObjType(_('module'),        'mod', 'obj'),\n+    }  # type: Dict[str, ObjType]\n+\n+    directives = {\n+        'function':        PyFunction,\n+        'data':            PyVariable,\n+        'class':           PyClasslike,\n+        'exception':       PyClasslike,\n+        'method':          PyMethod,\n+        'classmethod':     PyClassMethod,\n+        'staticmethod':    PyStaticMethod,\n+        'attribute':       PyAttribute,\n+        'module':          PyModule,\n+        'currentmodule':   PyCurrentModule,\n+        'decorator':       PyDecoratorFunction,\n+        'decoratormethod': PyDecoratorMethod,\n+    }\n+    roles = {\n+        'data':  PyXRefRole(),\n+        'exc':   PyXRefRole(),\n+        'func':  PyXRefRole(fix_parens=True),\n+        'class': PyXRefRole(),\n+        'const': PyXRefRole(),\n+        'attr':  PyXRefRole(),\n+        'meth':  PyXRefRole(fix_parens=True),\n+        'mod':   PyXRefRole(),\n+        'obj':   PyXRefRole(),\n+    }\n+    initial_data = {\n+        'objects': {},  # fullname -> docname, objtype\n+        'modules': {},  # modname -> docname, synopsis, platform, deprecated\n+    }  # type: Dict[str, Dict[str, Tuple[Any]]]\n+    indices = [\n+        PythonModuleIndex,\n+    ]\n+\n+    @property\n+    def objects(self) -> Dict[str, ObjectEntry]:\n+        return self.data.setdefault('objects', {})  # fullname -> ObjectEntry\n+\n+    def note_object(self, name: str, objtype: str, node_id: str,\n+                    canonical: bool = False, location: Any = None) -> None:\n+        \"\"\"Note a python object for cross reference.\n+\n+        .. versionadded:: 2.1\n+        \"\"\"\n+        if name in self.objects:\n+            other = self.objects[name]\n+            logger.warning(__('duplicate object description of %s, '\n+                              'other instance in %s, use :noindex: for one of them'),\n+                           name, other.docname, location=location)\n+        self.objects[name] = ObjectEntry(self.env.docname, node_id, objtype, canonical)\n+\n+    @property\n+    def modules(self) -> Dict[str, ModuleEntry]:\n+        return self.data.setdefault('modules', {})  # modname -> ModuleEntry\n+\n+    def note_module(self, name: str, node_id: str, synopsis: str,\n+                    platform: str, deprecated: bool) -> None:\n+        \"\"\"Note a python module for cross reference.\n+\n+        .. versionadded:: 2.1\n+        \"\"\"\n+        self.modules[name] = ModuleEntry(self.env.docname, node_id,\n+                                         synopsis, platform, deprecated)\n+\n+    def clear_doc(self, docname: str) -> None:\n+        for fullname, obj in list(self.objects.items()):\n+            if obj.docname == docname:\n+                del self.objects[fullname]\n+        for modname, mod in list(self.modules.items()):\n+            if mod.docname == docname:\n+                del self.modules[modname]\n+\n+    def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n+        # XXX check duplicates?\n+        for fullname, obj in otherdata['objects'].items():\n+            if obj.docname in docnames:\n+                self.objects[fullname] = obj\n+        for modname, mod in otherdata['modules'].items():\n+            if mod.docname in docnames:\n+                self.modules[modname] = mod\n+\n+    def find_obj(self, env: BuildEnvironment, modname: str, classname: str,\n+                 name: str, type: str, searchmode: int = 0\n+                 ) -> List[Tuple[str, ObjectEntry]]:\n+        \"\"\"Find a Python object for \"name\", perhaps using the given module\n+        and/or classname.  Returns a list of (name, object entry) tuples.\n+        \"\"\"\n+        # skip parens\n+        if name[-2:] == '()':\n+            name = name[:-2]\n+\n+        if not name:\n+            return []\n+\n+        matches = []  # type: List[Tuple[str, ObjectEntry]]\n+\n+        newname = None\n+        if searchmode == 1:\n+            if type is None:\n+                objtypes = list(self.object_types)\n+            else:\n+                objtypes = self.objtypes_for_role(type)\n+            if objtypes is not None:\n+                if modname and classname:\n+                    fullname = modname + '.' + classname + '.' + name\n+                    if fullname in self.objects and self.objects[fullname].objtype in objtypes:\n+                        newname = fullname\n+                if not newname:\n+                    if modname and modname + '.' + name in self.objects and \\\n+                       self.objects[modname + '.' + name].objtype in objtypes:\n+                        newname = modname + '.' + name\n+                    elif name in self.objects and self.objects[name].objtype in objtypes:\n+                        newname = name\n+                    else:\n+                        # \"fuzzy\" searching mode\n+                        searchname = '.' + name\n+                        matches = [(oname, self.objects[oname]) for oname in self.objects\n+                                   if oname.endswith(searchname) and\n+                                   self.objects[oname].objtype in objtypes]\n+        else:\n+            # NOTE: searching for exact match, object type is not considered\n+            if name in self.objects:\n+                newname = name\n+            elif type == 'mod':\n+                # only exact matches allowed for modules\n+                return []\n+            elif classname and classname + '.' + name in self.objects:\n+                newname = classname + '.' + name\n+            elif modname and modname + '.' + name in self.objects:\n+                newname = modname + '.' + name\n+            elif modname and classname and \\\n+                    modname + '.' + classname + '.' + name in self.objects:\n+                newname = modname + '.' + classname + '.' + name\n+        if newname is not None:\n+            matches.append((newname, self.objects[newname]))\n+        return matches\n+\n+    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n+                     type: str, target: str, node: pending_xref, contnode: Element\n+                     ) -> Element:\n+        modname = node.get('py:module')\n+        clsname = node.get('py:class')\n+        searchmode = 1 if node.hasattr('refspecific') else 0\n+        matches = self.find_obj(env, modname, clsname, target,\n+                                type, searchmode)\n+\n+        if not matches and type == 'attr':\n+            # fallback to meth (for property)\n+            matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)\n+\n+        if not matches:\n+            return None\n+        elif len(matches) > 1:\n+            logger.warning(__('more than one target found for cross-reference %r: %s'),\n+                           target, ', '.join(match[0] for match in matches),\n+                           type='ref', subtype='python', location=node)\n+        name, obj = matches[0]\n+\n+        if obj[2] == 'module':\n+            return self._make_module_refnode(builder, fromdocname, name, contnode)\n+        else:\n+            return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)\n+\n+    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n+                         target: str, node: pending_xref, contnode: Element\n+                         ) -> List[Tuple[str, Element]]:\n+        modname = node.get('py:module')\n+        clsname = node.get('py:class')\n+        results = []  # type: List[Tuple[str, Element]]\n+\n+        # always search in \"refspecific\" mode with the :any: role\n+        matches = self.find_obj(env, modname, clsname, target, None, 1)\n+        for name, obj in matches:\n+            if obj[2] == 'module':\n+                results.append(('py:mod',\n+                                self._make_module_refnode(builder, fromdocname,\n+                                                          name, contnode)))\n+            else:\n+                results.append(('py:' + self.role_for_objtype(obj[2]),\n+                                make_refnode(builder, fromdocname, obj[0], obj[1],\n+                                             contnode, name)))\n+        return results\n+\n+    def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,\n+                             contnode: Node) -> Element:\n+        # get additional info for modules\n+        module = self.modules[name]\n+        title = name\n+        if module.synopsis:\n+            title += ': ' + module.synopsis\n+        if module.deprecated:\n+            title += _(' (deprecated)')\n+        if module.platform:\n+            title += ' (' + module.platform + ')'\n+        return make_refnode(builder, fromdocname, module.docname, module.node_id,\n+                            contnode, title)\n+\n+    def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:\n+        for modname, mod in self.modules.items():\n+            yield (modname, modname, 'module', mod.docname, mod.node_id, 0)\n+        for refname, obj in self.objects.items():\n+            if obj.objtype != 'module':  # modules are already handled\n+                if obj.canonical:\n+                    # canonical names are not full-text searchable.\n+                    yield (refname, refname, obj.objtype, obj.docname, obj.node_id, -1)\n+                else:\n+                    yield (refname, refname, obj.objtype, obj.docname, obj.node_id, 1)\n+\n+    def get_full_qualified_name(self, node: Element) -> str:\n+        modname = node.get('py:module')\n+        clsname = node.get('py:class')\n+        target = node.get('reftarget')\n+        if target is None:\n+            return None\n+        else:\n+            return '.'.join(filter(None, [modname, clsname, target]))\n+\n+\n+def builtin_resolver(app: Sphinx, env: BuildEnvironment,\n+                     node: pending_xref, contnode: Element) -> Element:\n+    \"\"\"Do not emit nitpicky warnings for built-in types.\"\"\"\n+    def istyping(s: str) -> bool:\n+        if s.startswith('typing.'):\n+            s = s.split('.', 1)[1]\n+\n+        return s in typing.__all__  # type: ignore\n+\n+    if node.get('refdomain') != 'py':\n+        return None\n+    elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':\n+        return contnode\n+    elif node.get('reftype') in ('class', 'exc'):\n+        reftarget = node.get('reftarget')\n+        if inspect.isclass(getattr(builtins, reftarget, None)):\n+            # built-in class\n+            return contnode\n+        elif istyping(reftarget):\n+            # typing class\n+            return contnode\n+\n+    return None\n+\n+\n+def setup(app: Sphinx) -> Dict[str, Any]:\n+    app.setup_extension('sphinx.directives')\n+\n+    app.add_domain(PythonDomain)\n+    app.connect('object-description-transform', filter_meta_fields)\n+    app.connect('missing-reference', builtin_resolver, priority=900)\n+\n+    return {\n+        'version': 'builtin',\n+        'env_version': 3,\n+        'parallel_read_safe': True,\n+        'parallel_write_safe': True,\n+    }\n"
  },
  "sphinx-doc__sphinx-9229": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9229",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..3bb5f6931 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1725,7 +1725,14 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     ) -> None:\n         if self.doc_as_attr:\n             try:\n-                more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n+                alias_lines = StringList([_('alias of %s') % restify(self.object)], source='')\n+                # If there is already additional content (for example, a docstring),\n+                # do not overwrite it \u2014 prepend the alias information so the original\n+                # docstring is preserved.\n+                if more_content:\n+                    more_content = alias_lines + more_content\n+                else:\n+                    more_content = alias_lines\n             except AttributeError:\n                 pass  # Invalid class object is passed.\n \ndiff --git a/sphinx/ext/autodoc/__init__.py.bak b/sphinx/ext/autodoc/__init__.py.bak\nnew file mode 100644\nindex 000000000..1f4c98284\n--- /dev/null\n+++ b/sphinx/ext/autodoc/__init__.py.bak\n@@ -0,0 +1,2734 @@\n+\"\"\"\n+    sphinx.ext.autodoc\n+    ~~~~~~~~~~~~~~~~~~\n+\n+    Automatically insert docstrings for functions, classes or whole modules into\n+    the doctree, thus avoiding duplication between docstrings and documentation\n+    for those who like elaborate docstrings.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import re\n+import warnings\n+from inspect import Parameter, Signature\n+from types import ModuleType\n+from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Sequence,\n+                    Set, Tuple, Type, TypeVar, Union)\n+\n+from docutils.statemachine import StringList\n+\n+import sphinx\n+from sphinx.application import Sphinx\n+from sphinx.config import ENUM, Config\n+from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning\n+from sphinx.environment import BuildEnvironment\n+from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,\n+                                         import_object)\n+from sphinx.ext.autodoc.mock import ismock, mock, undecorate\n+from sphinx.locale import _, __\n+from sphinx.pycode import ModuleAnalyzer, PycodeError\n+from sphinx.util import inspect, logging\n+from sphinx.util.docstrings import prepare_docstring, separate_metadata\n+from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n+                                 stringify_signature)\n+from sphinx.util.typing import OptionSpec, get_type_hints, restify\n+from sphinx.util.typing import stringify as stringify_typehint\n+\n+if TYPE_CHECKING:\n+    from sphinx.ext.autodoc.directive import DocumenterBridge\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+# This type isn't exposed directly in any modules, but can be found\n+# here in most Python versions\n+MethodDescriptorType = type(type.__subclasses__)\n+\n+\n+#: extended signature RE: with explicit module name separated by ::\n+py_ext_sig_re = re.compile(\n+    r'''^ ([\\w.]+::)?            # explicit module name\n+          ([\\w.]+\\.)?            # module and/or class name(s)\n+          (\\w+)  \\s*             # thing name\n+          (?: \\((.*)\\)           # optional: arguments\n+           (?:\\s* -> \\s* (.*))?  #           return annotation\n+          )? $                   # and nothing more\n+          ''', re.VERBOSE)\n+special_member_re = re.compile(r'^__\\S+__$')\n+\n+\n+def identity(x: Any) -> Any:\n+    return x\n+\n+\n+class _All:\n+    \"\"\"A special value for :*-members: that matches to any member.\"\"\"\n+\n+    def __contains__(self, item: Any) -> bool:\n+        return True\n+\n+    def append(self, item: Any) -> None:\n+        pass  # nothing\n+\n+\n+class _Empty:\n+    \"\"\"A special value for :exclude-members: that never matches to any member.\"\"\"\n+\n+    def __contains__(self, item: Any) -> bool:\n+        return False\n+\n+\n+ALL = _All()\n+EMPTY = _Empty()\n+UNINITIALIZED_ATTR = object()\n+INSTANCEATTR = object()\n+SLOTSATTR = object()\n+\n+\n+def members_option(arg: Any) -> Union[object, List[str]]:\n+    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return ALL\n+    elif arg is False:\n+        return None\n+    else:\n+        return [x.strip() for x in arg.split(',') if x.strip()]\n+\n+\n+def members_set_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    warnings.warn(\"members_set_option() is deprecated.\",\n+                  RemovedInSphinx50Warning, stacklevel=2)\n+    if arg is None:\n+        return ALL\n+    return {x.strip() for x in arg.split(',') if x.strip()}\n+\n+\n+def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :exclude-members: option.\"\"\"\n+    if arg in (None, True):\n+        return EMPTY\n+    return {x.strip() for x in arg.split(',') if x.strip()}\n+\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return 'object'\n+    else:\n+        return arg\n+\n+\n+def member_order_option(arg: Any) -> Optional[str]:\n+    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return None\n+    elif arg in ('alphabetical', 'bysource', 'groupwise'):\n+        return arg\n+    else:\n+        raise ValueError(__('invalid value for member-order option: %s') % arg)\n+\n+\n+def class_doc_from_option(arg: Any) -> Optional[str]:\n+    \"\"\"Used to convert the :class-doc-from: option to autoclass directives.\"\"\"\n+    if arg in ('both', 'class', 'init'):\n+        return arg\n+    else:\n+        raise ValueError(__('invalid value for class-doc-from option: %s') % arg)\n+\n+\n+SUPPRESS = object()\n+\n+\n+def annotation_option(arg: Any) -> Any:\n+    if arg in (None, True):\n+        # suppress showing the representation of the object\n+        return SUPPRESS\n+    else:\n+        return arg\n+\n+\n+def bool_option(arg: Any) -> bool:\n+    \"\"\"Used to convert flag options to auto directives.  (Instead of\n+    directives.flag(), which returns None).\n+    \"\"\"\n+    return True\n+\n+\n+def merge_special_members_option(options: Dict) -> None:\n+    \"\"\"Merge :special-members: option to :members: option.\"\"\"\n+    warnings.warn(\"merge_special_members_option() is deprecated.\",\n+                  RemovedInSphinx50Warning, stacklevel=2)\n+    if 'special-members' in options and options['special-members'] is not ALL:\n+        if options.get('members') is ALL:\n+            pass\n+        elif options.get('members'):\n+            for member in options['special-members']:\n+                if member not in options['members']:\n+                    options['members'].append(member)\n+        else:\n+            options['members'] = options['special-members']\n+\n+\n+def merge_members_option(options: Dict) -> None:\n+    \"\"\"Merge :*-members: option to the :members: option.\"\"\"\n+    if options.get('members') is ALL:\n+        # merging is not needed when members: ALL\n+        return\n+\n+    members = options.setdefault('members', [])\n+    for key in {'private-members', 'special-members'}:\n+        if key in options and options[key] not in (ALL, None):\n+            for member in options[key]:\n+                if member not in members:\n+                    members.append(member)\n+\n+\n+# Some useful event listener factories for autodoc-process-docstring.\n+\n+def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n+    \"\"\"Return a listener that removes the first *pre* and last *post*\n+    lines of every docstring.  If *what* is a sequence of strings,\n+    only docstrings of a type in *what* will be processed.\n+\n+    Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n+\n+       from sphinx.ext.autodoc import cut_lines\n+       app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n+\n+    This can (and should) be used in place of :confval:`automodule_skip_lines`.\n+    \"\"\"\n+    def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n+                ) -> None:\n+        if what and what_ not in what:\n+            return\n+        del lines[:pre]\n+        if post:\n+            # remove one trailing blank line.\n+            if lines and not lines[-1]:\n+                lines.pop(-1)\n+            del lines[-post:]\n+        # make sure there is a blank line at the end\n+        if lines and lines[-1]:\n+            lines.append('')\n+    return process\n+\n+\n+def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n+            exclude: bool = False) -> Callable:\n+    \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n+    lines between lines that match the *marker* regular expression.  If no line\n+    matches, the resulting docstring would be empty, so no change will be made\n+    unless *keepempty* is true.\n+\n+    If *what* is a sequence of strings, only docstrings of a type in *what* will\n+    be processed.\n+    \"\"\"\n+    marker_re = re.compile(marker)\n+\n+    def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n+                ) -> None:\n+        if what and what_ not in what:\n+            return\n+        deleted = 0\n+        delete = not exclude\n+        orig_lines = lines[:]\n+        for i, line in enumerate(orig_lines):\n+            if delete:\n+                lines.pop(i - deleted)\n+                deleted += 1\n+            if marker_re.match(line):\n+                delete = not delete\n+                if delete:\n+                    lines.pop(i - deleted)\n+                    deleted += 1\n+        if not lines and not keepempty:\n+            lines[:] = orig_lines\n+        # make sure there is a blank line at the end\n+        if lines and lines[-1]:\n+            lines.append('')\n+    return process\n+\n+\n+# This class is used only in ``sphinx.ext.autodoc.directive``,\n+# But we define this class here to keep compatibility (see #4538)\n+class Options(dict):\n+    \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n+    def __getattr__(self, name: str) -> Any:\n+        try:\n+            return self[name.replace('_', '-')]\n+        except KeyError:\n+            return None\n+\n+\n+class ObjectMember(tuple):\n+    \"\"\"A member of object.\n+\n+    This is used for the result of `Documenter.get_object_members()` to\n+    represent each member of the object.\n+\n+    .. Note::\n+\n+       An instance of this class behaves as a tuple of (name, object)\n+       for compatibility to old Sphinx.  The behavior will be dropped\n+       in the future.  Therefore extensions should not use the tuple\n+       interface.\n+    \"\"\"\n+\n+    def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n+        return super().__new__(cls, (name, obj))  # type: ignore\n+\n+    def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,\n+                 class_: Any = None, skipped: bool = False) -> None:\n+        self.__name__ = name\n+        self.object = obj\n+        self.docstring = docstring\n+        self.skipped = skipped\n+        self.class_ = class_\n+\n+\n+ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n+\n+\n+class Documenter:\n+    \"\"\"\n+    A Documenter knows how to autodocument a single object type.  When\n+    registered with the AutoDirective, it will be used to document objects\n+    of that type when needed by autodoc.\n+\n+    Its *objtype* attribute selects what auto directive it is assigned to\n+    (the directive name is 'auto' + objtype), and what directive it generates\n+    by default, though that can be overridden by an attribute called\n+    *directivetype*.\n+\n+    A Documenter has an *option_spec* that works like a docutils directive's;\n+    in fact, it will be used to parse an auto directive's options that matches\n+    the documenter.\n+    \"\"\"\n+    #: name by which the directive is called (auto...) and the default\n+    #: generated directive name\n+    objtype = 'object'\n+    #: indentation by which to indent the directive content\n+    content_indent = '   '\n+    #: priority if multiple documenters return True from can_document_member\n+    priority = 0\n+    #: order if autodoc_member_order is set to 'groupwise'\n+    member_order = 0\n+    #: true if the generated content may contain titles\n+    titles_allowed = False\n+\n+    option_spec: OptionSpec = {\n+        'noindex': bool_option\n+    }\n+\n+    def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n+        \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n+        return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n+        raise NotImplementedError('must be implemented in subclasses')\n+\n+    def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n+        self.directive = directive\n+        self.config: Config = directive.env.config\n+        self.env: BuildEnvironment = directive.env\n+        self.options = directive.genopt\n+        self.name = name\n+        self.indent = indent\n+        # the module and object path within the module, and the fully\n+        # qualified name (all set after resolve_name succeeds)\n+        self.modname: str = None\n+        self.module: ModuleType = None\n+        self.objpath: List[str] = None\n+        self.fullname: str = None\n+        # extra signature items (arguments and return annotation,\n+        # also set after resolve_name succeeds)\n+        self.args: str = None\n+        self.retann: str = None\n+        # the object to document (set after import_object succeeds)\n+        self.object: Any = None\n+        self.object_name: str = None\n+        # the parent/owner of the object to document\n+        self.parent: Any = None\n+        # the module analyzer to get at attribute docs, or None\n+        self.analyzer: ModuleAnalyzer = None\n+\n+    @property\n+    def documenters(self) -> Dict[str, Type[\"Documenter\"]]:\n+        \"\"\"Returns registered Documenter classes\"\"\"\n+        return self.env.app.registry.documenters\n+\n+    def add_line(self, line: str, source: str, *lineno: int) -> None:\n+        \"\"\"Append one line of generated reST to the output.\"\"\"\n+        if line.strip():  # not a blank line\n+            self.directive.result.append(self.indent + line, source, *lineno)\n+        else:\n+            self.directive.result.append('', source, *lineno)\n+\n+    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n+                     ) -> Tuple[str, List[str]]:\n+        \"\"\"Resolve the module and name of the object to document given by the\n+        arguments and the current module/class.\n+\n+        Must return a pair of the module name and a chain of attributes; for\n+        example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n+        ``zipfile.ZipFile.open`` method.\n+        \"\"\"\n+        raise NotImplementedError('must be implemented in subclasses')\n+\n+    def parse_name(self) -> bool:\n+        \"\"\"Determine what module to import and what attribute to document.\n+\n+        Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n+        *self.args* and *self.retann* if parsing and resolving was successful.\n+        \"\"\"\n+        # first, parse the definition -- auto directives for classes and\n+        # functions can contain a signature which is then used instead of\n+        # an autogenerated one\n+        try:\n+            matched = py_ext_sig_re.match(self.name)\n+            explicit_modname, path, base, args, retann = matched.groups()\n+        except AttributeError:\n+            logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n+                           type='autodoc')\n+            return False\n+\n+        # support explicit module and class name separation via ::\n+        if explicit_modname is not None:\n+            modname = explicit_modname[:-2]\n+            parents = path.rstrip('.').split('.') if path else []\n+        else:\n+            modname = None\n+            parents = []\n+\n+        with mock(self.config.autodoc_mock_imports):\n+            self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n+\n+        if not self.modname:\n+            return False\n+\n+        self.args = args\n+        self.retann = retann\n+        self.fullname = ((self.modname or '') +\n+                         ('.' + '.'.join(self.objpath) if self.objpath else ''))\n+        return True\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n+        it as *self.object*.\n+\n+        Returns True if successful, False if an error occurred.\n+        \"\"\"\n+        with mock(self.config.autodoc_mock_imports):\n+            try:\n+                ret = import_object(self.modname, self.objpath, self.objtype,\n+                                    attrgetter=self.get_attr,\n+                                    warningiserror=self.config.autodoc_warningiserror)\n+                self.module, self.parent, self.object_name, self.object = ret\n+                if ismock(self.object):\n+                    self.object = undecorate(self.object)\n+                return True\n+            except ImportError as exc:\n+                if raiseerror:\n+                    raise\n+                else:\n+                    logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n+                    self.env.note_reread()\n+                    return False\n+\n+    def get_real_modname(self) -> str:\n+        \"\"\"Get the real module name of an object to document.\n+\n+        It can differ from the name of the module through which the object was\n+        imported.\n+        \"\"\"\n+        return self.get_attr(self.object, '__module__', None) or self.modname\n+\n+    def check_module(self) -> bool:\n+        \"\"\"Check if *self.object* is really defined in the module given by\n+        *self.modname*.\n+        \"\"\"\n+        if self.options.imported_members:\n+            return True\n+\n+        subject = inspect.unpartial(self.object)\n+        modname = self.get_attr(subject, '__module__', None)\n+        if modname and modname != self.modname:\n+            return False\n+        return True\n+\n+    def format_args(self, **kwargs: Any) -> str:\n+        \"\"\"Format the argument signature of *self.object*.\n+\n+        Should return None if the object does not have a signature.\n+        \"\"\"\n+        return None\n+\n+    def format_name(self) -> str:\n+        \"\"\"Format the name of *self.object*.\n+\n+        This normally should be something that can be parsed by the generated\n+        directive, but doesn't need to be (Sphinx will display it unparsed\n+        then).\n+        \"\"\"\n+        # normally the name doesn't contain the module (except for module\n+        # directives of course)\n+        return '.'.join(self.objpath) or self.modname\n+\n+    def _call_format_args(self, **kwargs: Any) -> str:\n+        if kwargs:\n+            try:\n+                return self.format_args(**kwargs)\n+            except TypeError:\n+                # avoid chaining exceptions, by putting nothing here\n+                pass\n+\n+        # retry without arguments for old documenters\n+        return self.format_args()\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        \"\"\"Format the signature (arguments and return annotation) of the object.\n+\n+        Let the user process it via the ``autodoc-process-signature`` event.\n+        \"\"\"\n+        if self.args is not None:\n+            # signature given explicitly\n+            args = \"(%s)\" % self.args\n+            retann = self.retann\n+        else:\n+            # try to introspect the signature\n+            try:\n+                retann = None\n+                args = self._call_format_args(**kwargs)\n+                if args:\n+                    matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n+                    if matched:\n+                        args = matched.group(1)\n+                        retann = matched.group(2)\n+            except Exception as exc:\n+                logger.warning(__('error while formatting arguments for %s: %s'),\n+                               self.fullname, exc, type='autodoc')\n+                args = None\n+\n+        result = self.env.events.emit_firstresult('autodoc-process-signature',\n+                                                  self.objtype, self.fullname,\n+                                                  self.object, self.options, args, retann)\n+        if result:\n+            args, retann = result\n+\n+        if args is not None:\n+            return args + ((' -> %s' % retann) if retann else '')\n+        else:\n+            return ''\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        \"\"\"Add the directive header and options to the generated content.\"\"\"\n+        domain = getattr(self, 'domain', 'py')\n+        directive = getattr(self, 'directivetype', self.objtype)\n+        name = self.format_name()\n+        sourcename = self.get_sourcename()\n+\n+        # one signature per line, indented by column\n+        prefix = '.. %s:%s:: ' % (domain, directive)\n+        for i, sig_line in enumerate(sig.split(\"\\n\")):\n+            self.add_line('%s%s%s' % (prefix, name, sig_line),\n+                          sourcename)\n+            if i == 0:\n+                prefix = \" \" * len(prefix)\n+\n+        if self.options.noindex:\n+            self.add_line('   :noindex:', sourcename)\n+        if self.objpath:\n+            # Be explicit about the module, this is necessary since .. class::\n+            # etc. don't support a prepended module name\n+            self.add_line('   :module: %s' % self.modname, sourcename)\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        \"\"\"Decode and return lines of the docstring(s) for the object.\n+\n+        When it returns None value, autodoc-process-docstring will not be called for this\n+        object.\n+        \"\"\"\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n+                           self.parent, self.object_name)\n+        if docstring:\n+            tab_width = self.directive.state.document.settings.tab_width\n+            return [prepare_docstring(docstring, ignore, tab_width)]\n+        return []\n+\n+    def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n+        \"\"\"Let the user process the docstrings before adding them.\"\"\"\n+        for docstringlines in docstrings:\n+            if self.env.app:\n+                # let extensions preprocess docstrings\n+                self.env.app.emit('autodoc-process-docstring',\n+                                  self.objtype, self.fullname, self.object,\n+                                  self.options, docstringlines)\n+\n+                if docstringlines and docstringlines[-1] != '':\n+                    # append a blank line to the end of the docstring\n+                    docstringlines.append('')\n+\n+            yield from docstringlines\n+\n+    def get_sourcename(self) -> str:\n+        if (getattr(self.object, '__module__', None) and\n+                getattr(self.object, '__qualname__', None)):\n+            # Get the correct location of docstring from self.object\n+            # to support inherited methods\n+            fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)\n+        else:\n+            fullname = self.fullname\n+\n+        if self.analyzer:\n+            return '%s:docstring of %s' % (self.analyzer.srcname, fullname)\n+        else:\n+            return 'docstring of %s' % fullname\n+\n+    def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n+                    ) -> None:\n+        \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n+        if no_docstring:\n+            warnings.warn(\"The 'no_docstring' argument to %s.add_content() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+        # set sourcename and add content from attribute documentation\n+        sourcename = self.get_sourcename()\n+        if self.analyzer:\n+            attr_docs = self.analyzer.find_attr_docs()\n+            if self.objpath:\n+                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n+                if key in attr_docs:\n+                    no_docstring = True\n+                    # make a copy of docstring for attributes to avoid cache\n+                    # the change of autodoc-process-docstring event.\n+                    docstrings = [list(attr_docs[key])]\n+\n+                    for i, line in enumerate(self.process_doc(docstrings)):\n+                        self.add_line(line, sourcename, i)\n+\n+        # add content from docstrings\n+        if not no_docstring:\n+            docstrings = self.get_doc()\n+            if docstrings is None:\n+                # Do not call autodoc-process-docstring on get_doc() returns None.\n+                pass\n+            else:\n+                if not docstrings:\n+                    # append at least a dummy docstring, so that the event\n+                    # autodoc-process-docstring is fired and can add some\n+                    # content if desired\n+                    docstrings.append([])\n+                for i, line in enumerate(self.process_doc(docstrings)):\n+                    self.add_line(line, sourcename, i)\n+\n+        # add additional content (e.g. from document), if present\n+        if more_content:\n+            for line, src in zip(more_content.data, more_content.items):\n+                self.add_line(line, src[0], src[1])\n+\n+    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n+        \"\"\"Return `(members_check_module, members)` where `members` is a\n+        list of `(membername, member)` pairs of the members of *self.object*.\n+\n+        If *want_all* is True, return all members.  Else, only return those\n+        members given by *self.options.members* (which may also be none).\n+        \"\"\"\n+        warnings.warn('The implementation of Documenter.get_object_members() will be '\n+                      'removed from Sphinx-6.0.', RemovedInSphinx60Warning)\n+        members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n+        if not want_all:\n+            if not self.options.members:\n+                return False, []  # type: ignore\n+            # specific members given\n+            selected = []\n+            for name in self.options.members:  # type: str\n+                if name in members:\n+                    selected.append((name, members[name].value))\n+                else:\n+                    logger.warning(__('missing attribute %s in object %s') %\n+                                   (name, self.fullname), type='autodoc')\n+            return False, selected\n+        elif self.options.inherited_members:\n+            return False, [(m.name, m.value) for m in members.values()]\n+        else:\n+            return False, [(m.name, m.value) for m in members.values()\n+                           if m.directly_defined]\n+\n+    def filter_members(self, members: ObjectMembers, want_all: bool\n+                       ) -> List[Tuple[str, Any, bool]]:\n+        \"\"\"Filter the given member list.\n+\n+        Members are skipped if\n+\n+        - they are private (except if given explicitly or the private-members\n+          option is set)\n+        - they are special methods (except if given explicitly or the\n+          special-members option is set)\n+        - they are undocumented (except if the undoc-members option is set)\n+\n+        The user can override the skipping decision by connecting to the\n+        ``autodoc-skip-member`` event.\n+        \"\"\"\n+        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+            if inspect.isclass(self.object):\n+                for cls in self.object.__mro__:\n+                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                        # given member is a member of specified *super class*\n+                        return True\n+                    elif name in cls.__dict__:\n+                        return False\n+                    elif name in self.get_attr(cls, '__annotations__', {}):\n+                        return False\n+                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                        return False\n+\n+            return False\n+\n+        ret = []\n+\n+        # search for members in source code too\n+        namespace = '.'.join(self.objpath)  # will be empty for modules\n+\n+        if self.analyzer:\n+            attr_docs = self.analyzer.find_attr_docs()\n+        else:\n+            attr_docs = {}\n+\n+        # process members and determine which to skip\n+        for obj in members:\n+            membername, member = obj\n+            # if isattr is True, the member is documented as an attribute\n+            if member is INSTANCEATTR:\n+                isattr = True\n+            elif (namespace, membername) in attr_docs:\n+                isattr = True\n+            else:\n+                isattr = False\n+\n+            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n+                         self.parent, self.object_name)\n+            if not isinstance(doc, str):\n+                # Ignore non-string __doc__\n+                doc = None\n+\n+            # if the member __doc__ is the same as self's __doc__, it's just\n+            # inherited and therefore not the member's doc\n+            cls = self.get_attr(member, '__class__', None)\n+            if cls:\n+                cls_doc = self.get_attr(cls, '__doc__', None)\n+                if cls_doc == doc:\n+                    doc = None\n+\n+            if isinstance(obj, ObjectMember) and obj.docstring:\n+                # hack for ClassDocumenter to inject docstring via ObjectMember\n+                doc = obj.docstring\n+\n+            doc, metadata = separate_metadata(doc)\n+            has_doc = bool(doc)\n+\n+            if 'private' in metadata:\n+                # consider a member private if docstring has \"private\" metadata\n+                isprivate = True\n+            elif 'public' in metadata:\n+                # consider a member public if docstring has \"public\" metadata\n+                isprivate = False\n+            else:\n+                isprivate = membername.startswith('_')\n+\n+            keep = False\n+            if ismock(member):\n+                # mocked module or object\n+                pass\n+            elif self.options.exclude_members and membername in self.options.exclude_members:\n+                # remove members given by exclude-members\n+                keep = False\n+            elif want_all and special_member_re.match(membername):\n+                # special __methods__\n+                if self.options.special_members and membername in self.options.special_members:\n+                    if membername == '__doc__':\n+                        keep = False\n+                    elif is_filtered_inherited_member(membername, obj):\n+                        keep = False\n+                    else:\n+                        keep = has_doc or self.options.undoc_members\n+                else:\n+                    keep = False\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+            elif want_all and isprivate:\n+                if has_doc or self.options.undoc_members:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    elif is_filtered_inherited_member(membername, obj):\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    keep = False\n+            else:\n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    keep = has_doc or self.options.undoc_members\n+\n+            if isinstance(obj, ObjectMember) and obj.skipped:\n+                # forcedly skipped member (ex. a module attribute not defined in __all__)\n+                keep = False\n+\n+            # give the user a chance to decide whether this member\n+            # should be skipped\n+            if self.env.app:\n+                # let extensions preprocess docstrings\n+                try:\n+                    skip_user = self.env.app.emit_firstresult(\n+                        'autodoc-skip-member', self.objtype, membername, member,\n+                        not keep, self.options)\n+                    if skip_user is not None:\n+                        keep = not skip_user\n+                except Exception as exc:\n+                    logger.warning(__('autodoc: failed to determine %r to be documented, '\n+                                      'the following exception was raised:\\n%s'),\n+                                   member, exc, type='autodoc')\n+                    keep = False\n+\n+            if keep:\n+                ret.append((membername, member, isattr))\n+\n+        return ret\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        \"\"\"Generate reST for member documentation.\n+\n+        If *all_members* is True, do all members, else those given by\n+        *self.options.members*.\n+        \"\"\"\n+        # set current namespace for finding members\n+        self.env.temp_data['autodoc:module'] = self.modname\n+        if self.objpath:\n+            self.env.temp_data['autodoc:class'] = self.objpath[0]\n+\n+        want_all = (all_members or\n+                    self.options.inherited_members or\n+                    self.options.members is ALL)\n+        # find out which members are documentable\n+        members_check_module, members = self.get_object_members(want_all)\n+\n+        # document non-skipped members\n+        memberdocumenters: List[Tuple[Documenter, bool]] = []\n+        for (mname, member, isattr) in self.filter_members(members, want_all):\n+            classes = [cls for cls in self.documenters.values()\n+                       if cls.can_document_member(member, mname, isattr, self)]\n+            if not classes:\n+                # don't know how to document this member\n+                continue\n+            # prefer the documenter with the highest priority\n+            classes.sort(key=lambda cls: cls.priority)\n+            # give explicitly separated module name, so that members\n+            # of inner classes can be documented\n+            full_mname = self.modname + '::' + '.'.join(self.objpath + [mname])\n+            documenter = classes[-1](self.directive, full_mname, self.indent)\n+            memberdocumenters.append((documenter, isattr))\n+\n+        member_order = self.options.member_order or self.config.autodoc_member_order\n+        memberdocumenters = self.sort_members(memberdocumenters, member_order)\n+\n+        for documenter, isattr in memberdocumenters:\n+            documenter.generate(\n+                all_members=True, real_modname=self.real_modname,\n+                check_module=members_check_module and not isattr)\n+\n+        # reset current objects\n+        self.env.temp_data['autodoc:module'] = None\n+        self.env.temp_data['autodoc:class'] = None\n+\n+    def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n+                     order: str) -> List[Tuple[\"Documenter\", bool]]:\n+        \"\"\"Sort the given member list.\"\"\"\n+        if order == 'groupwise':\n+            # sort by group; alphabetically within groups\n+            documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n+        elif order == 'bysource':\n+            if self.analyzer:\n+                # sort by source order, by virtue of the module analyzer\n+                tagorder = self.analyzer.tagorder\n+\n+                def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n+                    fullname = entry[0].name.split('::')[1]\n+                    return tagorder.get(fullname, len(tagorder))\n+                documenters.sort(key=keyfunc)\n+            else:\n+                # Assume that member discovery order matches source order.\n+                # This is a reasonable assumption in Python 3.6 and up, where\n+                # module.__dict__ is insertion-ordered.\n+                pass\n+        else:  # alphabetical\n+            documenters.sort(key=lambda e: e[0].name)\n+\n+        return documenters\n+\n+    def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n+                 check_module: bool = False, all_members: bool = False) -> None:\n+        \"\"\"Generate reST for the object given by *self.name*, and possibly for\n+        its members.\n+\n+        If *more_content* is given, include that content. If *real_modname* is\n+        given, use that module name to find attribute docs. If *check_module* is\n+        True, only generate if the object is defined in the module name it is\n+        imported from. If *all_members* is True, document all members.\n+        \"\"\"\n+        if not self.parse_name():\n+            # need a module to import\n+            logger.warning(\n+                __('don\\'t know which module to import for autodocumenting '\n+                   '%r (try placing a \"module\" or \"currentmodule\" directive '\n+                   'in the document, or giving an explicit module name)') %\n+                self.name, type='autodoc')\n+            return\n+\n+        # now, import the module and get object to document\n+        if not self.import_object():\n+            return\n+\n+        # If there is no real module defined, figure out which to use.\n+        # The real module is used in the module analyzer to look up the module\n+        # where the attribute documentation would actually be found in.\n+        # This is used for situations where you have a module that collects the\n+        # functions and classes of internal submodules.\n+        guess_modname = self.get_real_modname()\n+        self.real_modname: str = real_modname or guess_modname\n+\n+        # try to also get a source code analyzer for attribute docs\n+        try:\n+            self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n+            # parse right now, to get PycodeErrors on parsing (results will\n+            # be cached anyway)\n+            self.analyzer.find_attr_docs()\n+        except PycodeError as exc:\n+            logger.debug('[autodoc] module analyzer failed: %s', exc)\n+            # no source file -- e.g. for builtin and C modules\n+            self.analyzer = None\n+            # at least add the module.__file__ as a dependency\n+            if hasattr(self.module, '__file__') and self.module.__file__:\n+                self.directive.record_dependencies.add(self.module.__file__)\n+        else:\n+            self.directive.record_dependencies.add(self.analyzer.srcname)\n+\n+        if self.real_modname != guess_modname:\n+            # Add module to dependency list if target object is defined in other module.\n+            try:\n+                analyzer = ModuleAnalyzer.for_module(guess_modname)\n+                self.directive.record_dependencies.add(analyzer.srcname)\n+            except PycodeError:\n+                pass\n+\n+        # check __module__ of object (for members not given explicitly)\n+        if check_module:\n+            if not self.check_module():\n+                return\n+\n+        sourcename = self.get_sourcename()\n+\n+        # make sure that the result starts with an empty line.  This is\n+        # necessary for some situations where another directive preprocesses\n+        # reST and no starting newline is present\n+        self.add_line('', sourcename)\n+\n+        # format the object's signature, if any\n+        try:\n+            sig = self.format_signature()\n+        except Exception as exc:\n+            logger.warning(__('error while formatting signature for %s: %s'),\n+                           self.fullname, exc, type='autodoc')\n+            return\n+\n+        # generate the directive header and options, if applicable\n+        self.add_directive_header(sig)\n+        self.add_line('', sourcename)\n+\n+        # e.g. the module directive doesn't have content\n+        self.indent += self.content_indent\n+\n+        # add all content (from docstrings, attribute docs etc.)\n+        self.add_content(more_content)\n+\n+        # document members, if possible\n+        self.document_members(all_members)\n+\n+\n+class ModuleDocumenter(Documenter):\n+    \"\"\"\n+    Specialized Documenter subclass for modules.\n+    \"\"\"\n+    objtype = 'module'\n+    content_indent = ''\n+    titles_allowed = True\n+\n+    option_spec: OptionSpec = {\n+        'members': members_option, 'undoc-members': bool_option,\n+        'noindex': bool_option, 'inherited-members': inherited_members_option,\n+        'show-inheritance': bool_option, 'synopsis': identity,\n+        'platform': identity, 'deprecated': bool_option,\n+        'member-order': member_order_option, 'exclude-members': exclude_members_option,\n+        'private-members': members_option, 'special-members': members_option,\n+        'imported-members': bool_option, 'ignore-module-all': bool_option\n+    }\n+\n+    def __init__(self, *args: Any) -> None:\n+        super().__init__(*args)\n+        merge_members_option(self.options)\n+        self.__all__: Optional[Sequence[str]] = None\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        # don't document submodules automatically\n+        return False\n+\n+    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n+                     ) -> Tuple[str, List[str]]:\n+        if modname is not None:\n+            logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n+                           type='autodoc')\n+        return (path or '') + base, []\n+\n+    def parse_name(self) -> bool:\n+        ret = super().parse_name()\n+        if self.args or self.retann:\n+            logger.warning(__('signature arguments or return annotation '\n+                              'given for automodule %s') % self.fullname,\n+                           type='autodoc')\n+        return ret\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+\n+        try:\n+            if not self.options.ignore_module_all:\n+                self.__all__ = inspect.getall(self.object)\n+        except ValueError as exc:\n+            # invalid __all__ found.\n+            logger.warning(__('__all__ should be a list of strings, not %r '\n+                              '(in module %s) -- ignoring __all__') %\n+                           (exc.args[0], self.fullname), type='autodoc')\n+\n+        return ret\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        Documenter.add_directive_header(self, sig)\n+\n+        sourcename = self.get_sourcename()\n+\n+        # add some module-specific options\n+        if self.options.synopsis:\n+            self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n+        if self.options.platform:\n+            self.add_line('   :platform: ' + self.options.platform, sourcename)\n+        if self.options.deprecated:\n+            self.add_line('   :deprecated:', sourcename)\n+\n+    def get_module_members(self) -> Dict[str, ObjectMember]:\n+        \"\"\"Get members of target module.\"\"\"\n+        if self.analyzer:\n+            attr_docs = self.analyzer.attr_docs\n+        else:\n+            attr_docs = {}\n+\n+        members: Dict[str, ObjectMember] = {}\n+        for name in dir(self.object):\n+            try:\n+                value = safe_getattr(self.object, name, None)\n+                if ismock(value):\n+                    value = undecorate(value)\n+                docstring = attr_docs.get(('', name), [])\n+                members[name] = ObjectMember(name, value, docstring=\"\\n\".join(docstring))\n+            except AttributeError:\n+                continue\n+\n+        # annotation only member (ex. attr: int)\n+        for name in inspect.getannotations(self.object):\n+            if name not in members:\n+                docstring = attr_docs.get(('', name), [])\n+                members[name] = ObjectMember(name, INSTANCEATTR,\n+                                             docstring=\"\\n\".join(docstring))\n+\n+        return members\n+\n+    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n+        members = self.get_module_members()\n+        if want_all:\n+            if self.__all__ is None:\n+                # for implicit module members, check __module__ to avoid\n+                # documenting imported objects\n+                return True, list(members.values())\n+            else:\n+                for member in members.values():\n+                    if member.__name__ not in self.__all__:\n+                        member.skipped = True\n+\n+                return False, list(members.values())\n+        else:\n+            memberlist = self.options.members or []\n+            ret = []\n+            for name in memberlist:\n+                if name in members:\n+                    ret.append(members[name])\n+                else:\n+                    logger.warning(__('missing attribute mentioned in :members: option: '\n+                                      'module %s, attribute %s') %\n+                                   (safe_getattr(self.object, '__name__', '???'), name),\n+                                   type='autodoc')\n+            return False, ret\n+\n+    def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n+                     order: str) -> List[Tuple[\"Documenter\", bool]]:\n+        if order == 'bysource' and self.__all__:\n+            # Sort alphabetically first (for members not listed on the __all__)\n+            documenters.sort(key=lambda e: e[0].name)\n+\n+            # Sort by __all__\n+            def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n+                name = entry[0].name.split('::')[1]\n+                if self.__all__ and name in self.__all__:\n+                    return self.__all__.index(name)\n+                else:\n+                    return len(self.__all__)\n+            documenters.sort(key=keyfunc)\n+\n+            return documenters\n+        else:\n+            return super().sort_members(documenters, order)\n+\n+\n+class ModuleLevelDocumenter(Documenter):\n+    \"\"\"\n+    Specialized Documenter subclass for objects on module level (functions,\n+    classes, data/constants).\n+    \"\"\"\n+    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n+                     ) -> Tuple[str, List[str]]:\n+        if modname is None:\n+            if path:\n+                modname = path.rstrip('.')\n+            else:\n+                # if documenting a toplevel object without explicit module,\n+                # it can be contained in another auto directive ...\n+                modname = self.env.temp_data.get('autodoc:module')\n+                # ... or in the scope of a module directive\n+                if not modname:\n+                    modname = self.env.ref_context.get('py:module')\n+                # ... else, it stays None, which means invalid\n+        return modname, parents + [base]\n+\n+\n+class ClassLevelDocumenter(Documenter):\n+    \"\"\"\n+    Specialized Documenter subclass for objects on class level (methods,\n+    attributes).\n+    \"\"\"\n+    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n+                     ) -> Tuple[str, List[str]]:\n+        if modname is None:\n+            if path:\n+                mod_cls = path.rstrip('.')\n+            else:\n+                mod_cls = None\n+                # if documenting a class-level object without path,\n+                # there must be a current class, either from a parent\n+                # auto directive ...\n+                mod_cls = self.env.temp_data.get('autodoc:class')\n+                # ... or from a class directive\n+                if mod_cls is None:\n+                    mod_cls = self.env.ref_context.get('py:class')\n+                # ... if still None, there's no way to know\n+                if mod_cls is None:\n+                    return None, []\n+            modname, sep, cls = mod_cls.rpartition('.')\n+            parents = [cls]\n+            # if the module name is still missing, get it like above\n+            if not modname:\n+                modname = self.env.temp_data.get('autodoc:module')\n+            if not modname:\n+                modname = self.env.ref_context.get('py:module')\n+            # ... else, it stays None, which means invalid\n+        return modname, parents + [base]\n+\n+\n+class DocstringSignatureMixin:\n+    \"\"\"\n+    Mixin for FunctionDocumenter and MethodDocumenter to provide the\n+    feature of reading the signature from the docstring.\n+    \"\"\"\n+    _new_docstrings: List[List[str]] = None\n+    _signatures: List[str] = None\n+\n+    def _find_signature(self) -> Tuple[str, str]:\n+        # candidates of the object name\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+\n+        docstrings = self.get_doc()\n+        if docstrings is None:\n+            return None, None\n+        self._new_docstrings = docstrings[:]\n+        self._signatures = []\n+        result = None\n+        for i, doclines in enumerate(docstrings):\n+            for j, line in enumerate(doclines):\n+                if not line:\n+                    # no lines in docstring, no match\n+                    break\n+\n+                if line.endswith('\\\\'):\n+                    line = line.rstrip('\\\\').rstrip()\n+\n+                # match first line of docstring against signature RE\n+                match = py_ext_sig_re.match(line)\n+                if not match:\n+                    break\n+                exmod, path, base, args, retann = match.groups()\n+\n+                # the base name must match ours\n+                if base not in valid_names:\n+                    break\n+\n+                # re-prepare docstring to ignore more leading indentation\n+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n+                                                            tabsize=tab_width)\n+\n+                if result is None:\n+                    # first signature\n+                    result = args, retann\n+                else:\n+                    # subsequent signatures\n+                    self._signatures.append(\"(%s) -> %s\" % (args, retann))\n+\n+            if result:\n+                # finish the loop when signature found\n+                break\n+\n+        return result\n+\n+    def get_doc(self, ignore: int = None) -> List[List[str]]:\n+        if self._new_docstrings is not None:\n+            return self._new_docstrings\n+        return super().get_doc(ignore)  # type: ignore\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n+            # only act if a signature is not explicitly given already, and if\n+            # the feature is enabled\n+            result = self._find_signature()\n+            if result is not None:\n+                self.args, self.retann = result\n+        sig = super().format_signature(**kwargs)  # type: ignore\n+        if self._signatures:\n+            return \"\\n\".join([sig] + self._signatures)\n+        else:\n+            return sig\n+\n+\n+class DocstringStripSignatureMixin(DocstringSignatureMixin):\n+    \"\"\"\n+    Mixin for AttributeDocumenter to provide the\n+    feature of stripping any function signature from the docstring.\n+    \"\"\"\n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n+            # only act if a signature is not explicitly given already, and if\n+            # the feature is enabled\n+            result = self._find_signature()\n+            if result is not None:\n+                # Discarding _args is a only difference with\n+                # DocstringSignatureMixin.format_signature.\n+                # Documenter.format_signature use self.args value to format.\n+                _args, self.retann = result\n+        return super().format_signature(**kwargs)\n+\n+\n+class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n+    \"\"\"\n+    Specialized Documenter subclass for functions.\n+    \"\"\"\n+    objtype = 'function'\n+    member_order = 30\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        # supports functions, builtins and bound methods exported at the module level\n+        return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n+                (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n+\n+    def format_args(self, **kwargs: Any) -> str:\n+        if self.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+\n+        try:\n+            self.env.app.emit('autodoc-before-process-signature', self.object, False)\n+            sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n+            args = stringify_signature(sig, **kwargs)\n+        except TypeError as exc:\n+            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                           self.fullname, exc)\n+            return None\n+        except ValueError:\n+            args = ''\n+\n+        if self.config.strip_signature_backslash:\n+            # escape backslashes for reST\n+            args = args.replace('\\\\', '\\\\\\\\')\n+        return args\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        sourcename = self.get_sourcename()\n+        super().add_directive_header(sig)\n+\n+        if inspect.iscoroutinefunction(self.object):\n+            self.add_line('   :async:', sourcename)\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        sigs = []\n+        if (self.analyzer and\n+                '.'.join(self.objpath) in self.analyzer.overloads and\n+                self.config.autodoc_typehints != 'none'):\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded = True\n+        else:\n+            overloaded = False\n+            sig = super().format_signature(**kwargs)\n+            sigs.append(sig)\n+\n+        if inspect.is_singledispatch_function(self.object):\n+            # append signature of singledispatch'ed functions\n+            for typ, func in self.object.registry.items():\n+                if typ is object:\n+                    pass  # default implementation. skipped.\n+                else:\n+                    dispatchfunc = self.annotate_to_first_argument(func, typ)\n+                    if dispatchfunc:\n+                        documenter = FunctionDocumenter(self.directive, '')\n+                        documenter.object = dispatchfunc\n+                        documenter.objpath = [None]\n+                        sigs.append(documenter.format_signature())\n+        if overloaded:\n+            actual = inspect.signature(self.object,\n+                                       type_aliases=self.config.autodoc_type_aliases)\n+            __globals__ = safe_getattr(self.object, '__globals__', {})\n+            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n+                overload = self.merge_default_value(actual, overload)\n+                overload = evaluate_signature(overload, __globals__,\n+                                              self.config.autodoc_type_aliases)\n+\n+                sig = stringify_signature(overload, **kwargs)\n+                sigs.append(sig)\n+\n+        return \"\\n\".join(sigs)\n+\n+    def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n+        \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n+        parameters = list(overload.parameters.values())\n+        for i, param in enumerate(parameters):\n+            actual_param = actual.parameters.get(param.name)\n+            if actual_param and param.default == '...':\n+                parameters[i] = param.replace(default=actual_param.default)\n+\n+        return overload.replace(parameters=parameters)\n+\n+    def annotate_to_first_argument(self, func: Callable, typ: Type) -> Optional[Callable]:\n+        \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n+        try:\n+            sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n+        except TypeError as exc:\n+            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                           self.fullname, exc)\n+            return None\n+        except ValueError:\n+            return None\n+\n+        if len(sig.parameters) == 0:\n+            return None\n+\n+        def dummy():\n+            pass\n+\n+        params = list(sig.parameters.values())\n+        if params[0].annotation is Parameter.empty:\n+            params[0] = params[0].replace(annotation=typ)\n+            try:\n+                dummy.__signature__ = sig.replace(parameters=params)  # type: ignore\n+                return dummy\n+            except (AttributeError, TypeError):\n+                # failed to update signature (ex. built-in or extension types)\n+                return None\n+        else:\n+            return None\n+\n+\n+class DecoratorDocumenter(FunctionDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for decorator functions.\n+    \"\"\"\n+    objtype = 'decorator'\n+\n+    # must be lower than FunctionDocumenter\n+    priority = -1\n+\n+    def format_args(self, **kwargs: Any) -> Any:\n+        args = super().format_args(**kwargs)\n+        if ',' in args:\n+            return args\n+        else:\n+            return None\n+\n+\n+# Types which have confusing metaclass signatures it would be best not to show.\n+# These are listed by name, rather than storing the objects themselves, to avoid\n+# needing to import the modules.\n+_METACLASS_CALL_BLACKLIST = [\n+    'enum.EnumMeta.__call__',\n+]\n+\n+\n+# Types whose __new__ signature is a pass-thru.\n+_CLASS_NEW_BLACKLIST = [\n+    'typing.Generic.__new__',\n+]\n+\n+\n+class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n+    \"\"\"\n+    Specialized Documenter subclass for classes.\n+    \"\"\"\n+    objtype = 'class'\n+    member_order = 20\n+    option_spec: OptionSpec = {\n+        'members': members_option, 'undoc-members': bool_option,\n+        'noindex': bool_option, 'inherited-members': inherited_members_option,\n+        'show-inheritance': bool_option, 'member-order': member_order_option,\n+        'exclude-members': exclude_members_option,\n+        'private-members': members_option, 'special-members': members_option,\n+        'class-doc-from': class_doc_from_option,\n+    }\n+\n+    _signature_class: Any = None\n+    _signature_method_name: str = None\n+\n+    def __init__(self, *args: Any) -> None:\n+        super().__init__(*args)\n+\n+        if self.config.autodoc_class_signature == 'separated':\n+            # show __init__() method\n+            if self.options.special_members is None:\n+                self.options['special-members'] = {'__new__', '__init__'}\n+            else:\n+                self.options.special_members.append('__new__')\n+                self.options.special_members.append('__init__')\n+\n+        merge_members_option(self.options)\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return isinstance(member, type)\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        # if the class is documented under another name, document it\n+        # as data/attribute\n+        if ret:\n+            if hasattr(self.object, '__name__'):\n+                self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n+            else:\n+                self.doc_as_attr = True\n+        return ret\n+\n+    def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n+        def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n+            \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n+            if inspect.is_builtin_class_method(obj, attr):\n+                return None\n+            attr = self.get_attr(obj, attr, None)\n+            if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n+                return None\n+            return attr\n+\n+        # This sequence is copied from inspect._signature_from_callable.\n+        # ValueError means that no signature could be found, so we keep going.\n+\n+        # First, we check the obj has a __signature__ attribute\n+        if (hasattr(self.object, '__signature__') and\n+                isinstance(self.object.__signature__, Signature)):\n+            return None, None, self.object.__signature__\n+\n+        # Next, let's see if it has an overloaded __call__ defined\n+        # in its metaclass\n+        call = get_user_defined_function_or_method(type(self.object), '__call__')\n+\n+        if call is not None:\n+            if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n+                call = None\n+\n+        if call is not None:\n+            self.env.app.emit('autodoc-before-process-signature', call, True)\n+            try:\n+                sig = inspect.signature(call, bound_method=True,\n+                                        type_aliases=self.config.autodoc_type_aliases)\n+                return type(self.object), '__call__', sig\n+            except ValueError:\n+                pass\n+\n+        # Now we check if the 'obj' class has a '__new__' method\n+        new = get_user_defined_function_or_method(self.object, '__new__')\n+\n+        if new is not None:\n+            if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n+                new = None\n+\n+        if new is not None:\n+            self.env.app.emit('autodoc-before-process-signature', new, True)\n+            try:\n+                sig = inspect.signature(new, bound_method=True,\n+                                        type_aliases=self.config.autodoc_type_aliases)\n+                return self.object, '__new__', sig\n+            except ValueError:\n+                pass\n+\n+        # Finally, we should have at least __init__ implemented\n+        init = get_user_defined_function_or_method(self.object, '__init__')\n+        if init is not None:\n+            self.env.app.emit('autodoc-before-process-signature', init, True)\n+            try:\n+                sig = inspect.signature(init, bound_method=True,\n+                                        type_aliases=self.config.autodoc_type_aliases)\n+                return self.object, '__init__', sig\n+            except ValueError:\n+                pass\n+\n+        # None of the attributes are user-defined, so fall back to let inspect\n+        # handle it.\n+        # We don't know the exact method that inspect.signature will read\n+        # the signature from, so just pass the object itself to our hook.\n+        self.env.app.emit('autodoc-before-process-signature', self.object, False)\n+        try:\n+            sig = inspect.signature(self.object, bound_method=False,\n+                                    type_aliases=self.config.autodoc_type_aliases)\n+            return None, None, sig\n+        except ValueError:\n+            pass\n+\n+        # Still no signature: happens e.g. for old-style classes\n+        # with __init__ in C and no `__text_signature__`.\n+        return None, None, None\n+\n+    def format_args(self, **kwargs: Any) -> str:\n+        if self.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+\n+        try:\n+            self._signature_class, self._signature_method_name, sig = self._get_signature()\n+        except TypeError as exc:\n+            # __signature__ attribute contained junk\n+            logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n+                           self.fullname, exc)\n+            return None\n+\n+        if sig is None:\n+            return None\n+\n+        return stringify_signature(sig, show_return_annotation=False, **kwargs)\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+        if self.config.autodoc_class_signature == 'separated':\n+            # do not show signatures\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads and self.config.autodoc_typehints != 'none':\n+            # Use signatures for overloaded methods instead of the implementation method.\n+            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n+            __globals__ = safe_getattr(method, '__globals__', {})\n+            for overload in overloads:\n+                overload = evaluate_signature(overload, __globals__,\n+                                              self.config.autodoc_type_aliases)\n+\n+                parameters = list(overload.parameters.values())\n+                overload = overload.replace(parameters=parameters[1:],\n+                                            return_annotation=Parameter.empty)\n+                sig = stringify_signature(overload, **kwargs)\n+                sigs.append(sig)\n+        else:\n+            sigs.append(sig)\n+\n+        return \"\\n\".join(sigs)\n+\n+    def get_overloaded_signatures(self) -> List[Signature]:\n+        if self._signature_class and self._signature_method_name:\n+            for cls in self._signature_class.__mro__:\n+                try:\n+                    analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                    analyzer.analyze()\n+                    qualname = '.'.join([cls.__qualname__, self._signature_method_name])\n+                    if qualname in analyzer.overloads:\n+                        return analyzer.overloads.get(qualname)\n+                    elif qualname in analyzer.tagorder:\n+                        # the constructor is defined in the class, but not overrided.\n+                        return []\n+                except PycodeError:\n+                    pass\n+\n+        return []\n+\n+    def get_canonical_fullname(self) -> Optional[str]:\n+        __modname__ = safe_getattr(self.object, '__module__', self.modname)\n+        __qualname__ = safe_getattr(self.object, '__qualname__', None)\n+        if __qualname__ is None:\n+            __qualname__ = safe_getattr(self.object, '__name__', None)\n+        if __qualname__ and '<locals>' in __qualname__:\n+            # No valid qualname found if the object is defined as locals\n+            __qualname__ = None\n+\n+        if __modname__ and __qualname__:\n+            return '.'.join([__modname__, __qualname__])\n+        else:\n+            return None\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        sourcename = self.get_sourcename()\n+\n+        if self.doc_as_attr:\n+            self.directivetype = 'attribute'\n+        super().add_directive_header(sig)\n+\n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n+            self.add_line('   :final:', sourcename)\n+\n+        canonical_fullname = self.get_canonical_fullname()\n+        if not self.doc_as_attr and canonical_fullname and self.fullname != canonical_fullname:\n+            self.add_line('   :canonical: %s' % canonical_fullname, sourcename)\n+\n+        # add inheritance info, if wanted\n+        if not self.doc_as_attr and self.options.show_inheritance:\n+            sourcename = self.get_sourcename()\n+            self.add_line('', sourcename)\n+\n+            if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):\n+                # A subclass of generic types\n+                # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>\n+                bases = [restify(cls) for cls in self.object.__orig_bases__]\n+                self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n+            elif hasattr(self.object, '__bases__') and len(self.object.__bases__):\n+                # A normal class\n+                bases = [restify(cls) for cls in self.object.__bases__]\n+                self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n+\n+    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n+        members = get_class_members(self.object, self.objpath, self.get_attr)\n+        if not want_all:\n+            if not self.options.members:\n+                return False, []  # type: ignore\n+            # specific members given\n+            selected = []\n+            for name in self.options.members:  # type: str\n+                if name in members:\n+                    selected.append(members[name])\n+                else:\n+                    logger.warning(__('missing attribute %s in object %s') %\n+                                   (name, self.fullname), type='autodoc')\n+            return False, selected\n+        elif self.options.inherited_members:\n+            return False, list(members.values())\n+        else:\n+            return False, [m for m in members.values() if m.class_ == self.object]\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if self.doc_as_attr:\n+            # Don't show the docstring of the class when it is an alias.\n+            return None\n+\n+        lines = getattr(self, '_new_docstrings', None)\n+        if lines is not None:\n+            return lines\n+\n+        classdoc_from = self.options.get('class-doc-from', self.config.autoclass_content)\n+\n+        docstrings = []\n+        attrdocstring = self.get_attr(self.object, '__doc__', None)\n+        if attrdocstring:\n+            docstrings.append(attrdocstring)\n+\n+        # for classes, what the \"docstring\" is can be controlled via a\n+        # config value; the default is only the class docstring\n+        if classdoc_from in ('both', 'init'):\n+            __init__ = self.get_attr(self.object, '__init__', None)\n+            initdocstring = getdoc(__init__, self.get_attr,\n+                                   self.config.autodoc_inherit_docstrings,\n+                                   self.parent, self.object_name)\n+            # for new-style classes, no __init__ means default __init__\n+            if (initdocstring is not None and\n+                (initdocstring == object.__init__.__doc__ or  # for pypy\n+                 initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n+                initdocstring = None\n+            if not initdocstring:\n+                # try __new__\n+                __new__ = self.get_attr(self.object, '__new__', None)\n+                initdocstring = getdoc(__new__, self.get_attr,\n+                                       self.config.autodoc_inherit_docstrings,\n+                                       self.parent, self.object_name)\n+                # for new-style classes, no __new__ means default __new__\n+                if (initdocstring is not None and\n+                    (initdocstring == object.__new__.__doc__ or  # for pypy\n+                     initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n+                    initdocstring = None\n+            if initdocstring:\n+                if classdoc_from == 'init':\n+                    docstrings = [initdocstring]\n+                else:\n+                    docstrings.append(initdocstring)\n+\n+        tab_width = self.directive.state.document.settings.tab_width\n+        return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n+\n+    def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n+                    ) -> None:\n+        if self.doc_as_attr:\n+            try:\n+                more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n+            except AttributeError:\n+                pass  # Invalid class object is passed.\n+\n+        super().add_content(more_content)\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        if self.doc_as_attr:\n+            return\n+        super().document_members(all_members)\n+\n+    def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n+                 check_module: bool = False, all_members: bool = False) -> None:\n+        # Do not pass real_modname and use the name from the __module__\n+        # attribute of the class.\n+        # If a class gets imported into the module real_modname\n+        # the analyzer won't find the source of the class, if\n+        # it looks in real_modname.\n+        return super().generate(more_content=more_content,\n+                                check_module=check_module,\n+                                all_members=all_members)\n+\n+\n+class ExceptionDocumenter(ClassDocumenter):\n+    \"\"\"\n+    Specialized ClassDocumenter subclass for exceptions.\n+    \"\"\"\n+    objtype = 'exception'\n+    member_order = 10\n+\n+    # needs a higher priority than ClassDocumenter\n+    priority = 10\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return isinstance(member, type) and issubclass(member, BaseException)\n+\n+\n+class DataDocumenterMixinBase:\n+    # define types of instance variables\n+    config: Config = None\n+    env: BuildEnvironment = None\n+    modname: str = None\n+    parent: Any = None\n+    object: Any = None\n+    objpath: List[str] = None\n+\n+    def should_suppress_directive_header(self) -> bool:\n+        \"\"\"Check directive header should be suppressed.\"\"\"\n+        return False\n+\n+    def should_suppress_value_header(self) -> bool:\n+        \"\"\"Check :value: header should be suppressed.\"\"\"\n+        return False\n+\n+    def update_content(self, more_content: StringList) -> None:\n+        \"\"\"Update docstring for the NewType object.\"\"\"\n+        pass\n+\n+\n+class GenericAliasMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n+    supporting GenericAliases.\n+    \"\"\"\n+\n+    def should_suppress_directive_header(self) -> bool:\n+        return (inspect.isgenericalias(self.object) or\n+                super().should_suppress_directive_header())\n+\n+    def update_content(self, more_content: StringList) -> None:\n+        if inspect.isgenericalias(self.object):\n+            more_content.append(_('alias of %s') % restify(self.object), '')\n+            more_content.append('', '')\n+\n+        super().update_content(more_content)\n+\n+\n+class NewTypeMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n+    supporting NewTypes.\n+    \"\"\"\n+\n+    def should_suppress_directive_header(self) -> bool:\n+        return (inspect.isNewType(self.object) or\n+                super().should_suppress_directive_header())\n+\n+    def update_content(self, more_content: StringList) -> None:\n+        if inspect.isNewType(self.object):\n+            supertype = restify(self.object.__supertype__)\n+            more_content.append(_('alias of %s') % supertype, '')\n+            more_content.append('', '')\n+\n+        super().update_content(more_content)\n+\n+\n+class TypeVarMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n+    supporting TypeVars.\n+    \"\"\"\n+\n+    def should_suppress_directive_header(self) -> bool:\n+        return (isinstance(self.object, TypeVar) or\n+                super().should_suppress_directive_header())\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+        if isinstance(self.object, TypeVar):\n+            if self.object.__doc__ != TypeVar.__doc__:\n+                return super().get_doc()  # type: ignore\n+            else:\n+                return []\n+        else:\n+            return super().get_doc()  # type: ignore\n+\n+    def update_content(self, more_content: StringList) -> None:\n+        if isinstance(self.object, TypeVar):\n+            attrs = [repr(self.object.__name__)]\n+            for constraint in self.object.__constraints__:\n+                attrs.append(stringify_typehint(constraint))\n+            if self.object.__bound__:\n+                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+            if self.object.__covariant__:\n+                attrs.append(\"covariant=True\")\n+            if self.object.__contravariant__:\n+                attrs.append(\"contravariant=True\")\n+\n+            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+            more_content.append('', '')\n+\n+        super().update_content(more_content)\n+\n+\n+class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for DataDocumenter to provide the feature for supporting uninitialized\n+    (type annotation only) global variables.\n+    \"\"\"\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        try:\n+            return super().import_object(raiseerror=True)  # type: ignore\n+        except ImportError as exc:\n+            # annotation only instance variable (PEP-526)\n+            try:\n+                with mock(self.config.autodoc_mock_imports):\n+                    parent = import_module(self.modname, self.config.autodoc_warningiserror)\n+                    annotations = get_type_hints(parent, None,\n+                                                 self.config.autodoc_type_aliases)\n+                    if self.objpath[-1] in annotations:\n+                        self.object = UNINITIALIZED_ATTR\n+                        self.parent = parent\n+                        return True\n+            except ImportError:\n+                pass\n+\n+            if raiseerror:\n+                raise\n+            else:\n+                logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n+                self.env.note_reread()\n+                return False\n+\n+    def should_suppress_value_header(self) -> bool:\n+        return (self.object is UNINITIALIZED_ATTR or\n+                super().should_suppress_value_header())\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if self.object is UNINITIALIZED_ATTR:\n+            return []\n+        else:\n+            return super().get_doc(ignore)  # type: ignore\n+\n+\n+class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,\n+                     UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for data items.\n+    \"\"\"\n+    objtype = 'data'\n+    member_order = 40\n+    priority = -10\n+    option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)\n+    option_spec[\"annotation\"] = annotation_option\n+    option_spec[\"no-value\"] = bool_option\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return isinstance(parent, ModuleDocumenter) and isattr\n+\n+    def update_annotations(self, parent: Any) -> None:\n+        \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n+        annotations = dict(inspect.getannotations(parent))\n+        parent.__annotations__ = annotations\n+\n+        try:\n+            analyzer = ModuleAnalyzer.for_module(self.modname)\n+            analyzer.analyze()\n+            for (classname, attrname), annotation in analyzer.annotations.items():\n+                if classname == '' and attrname not in annotations:\n+                    annotations[attrname] = annotation\n+        except PycodeError:\n+            pass\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if self.parent:\n+            self.update_annotations(self.parent)\n+\n+        return ret\n+\n+    def should_suppress_value_header(self) -> bool:\n+        if super().should_suppress_value_header():\n+            return True\n+        else:\n+            doc = self.get_doc()\n+            docstring, metadata = separate_metadata('\\n'.join(sum(doc, [])))\n+            if 'hide-value' in metadata:\n+                return True\n+\n+        return False\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n+            pass\n+        elif self.options.annotation:\n+            self.add_line('   :annotation: %s' % self.options.annotation,\n+                          sourcename)\n+        else:\n+            # obtain annotation for this data\n+            annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n+            if self.objpath[-1] in annotations:\n+                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n+                self.add_line('   :type: ' + objrepr, sourcename)\n+\n+            try:\n+                if self.options.no_value or self.should_suppress_value_header():\n+                    pass\n+                else:\n+                    objrepr = object_description(self.object)\n+                    self.add_line('   :value: ' + objrepr, sourcename)\n+            except ValueError:\n+                pass\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def get_real_modname(self) -> str:\n+        real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n+        return real_modname or self.modname\n+\n+    def get_module_comment(self, attrname: str) -> Optional[List[str]]:\n+        try:\n+            analyzer = ModuleAnalyzer.for_module(self.modname)\n+            analyzer.analyze()\n+            key = ('', attrname)\n+            if key in analyzer.attr_docs:\n+                return list(analyzer.attr_docs[key])\n+        except PycodeError:\n+            pass\n+\n+        return None\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        # Check the variable has a docstring-comment\n+        comment = self.get_module_comment(self.objpath[-1])\n+        if comment:\n+            return [comment]\n+        else:\n+            return super().get_doc(ignore)\n+\n+    def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n+                    ) -> None:\n+        # Disable analyzing variable comment on Documenter.add_content() to control it on\n+        # DataDocumenter.add_content()\n+        self.analyzer = None\n+\n+        if not more_content:\n+            more_content = StringList()\n+\n+        self.update_content(more_content)\n+        super().add_content(more_content, no_docstring=no_docstring)\n+\n+\n+class NewTypeDataDocumenter(DataDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for NewTypes.\n+\n+    Note: This must be invoked before FunctionDocumenter because NewType is a kind of\n+    function object.\n+    \"\"\"\n+\n+    objtype = 'newtypedata'\n+    directivetype = 'data'\n+    priority = FunctionDocumenter.priority + 1\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return inspect.isNewType(member) and isattr\n+\n+\n+class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n+    \"\"\"\n+    Specialized Documenter subclass for methods (normal, static and class).\n+    \"\"\"\n+    objtype = 'method'\n+    directivetype = 'method'\n+    member_order = 50\n+    priority = 1  # must be more than FunctionDocumenter\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return inspect.isroutine(member) and not isinstance(parent, ModuleDocumenter)\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if not ret:\n+            return ret\n+\n+        # to distinguish classmethod/staticmethod\n+        obj = self.parent.__dict__.get(self.object_name)\n+        if obj is None:\n+            obj = self.object\n+\n+        if (inspect.isclassmethod(obj) or\n+                inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n+            # document class and static members before ordinary ones\n+            self.member_order = self.member_order - 1\n+\n+        return ret\n+\n+    def format_args(self, **kwargs: Any) -> str:\n+        if self.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+\n+        try:\n+            if self.object == object.__init__ and self.parent != object:\n+                # Classes not having own __init__() method are shown as no arguments.\n+                #\n+                # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n+                #       But it makes users confused.\n+                args = '()'\n+            else:\n+                if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n+                    self.env.app.emit('autodoc-before-process-signature', self.object, False)\n+                    sig = inspect.signature(self.object, bound_method=False,\n+                                            type_aliases=self.config.autodoc_type_aliases)\n+                else:\n+                    self.env.app.emit('autodoc-before-process-signature', self.object, True)\n+                    sig = inspect.signature(self.object, bound_method=True,\n+                                            type_aliases=self.config.autodoc_type_aliases)\n+                args = stringify_signature(sig, **kwargs)\n+        except TypeError as exc:\n+            logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n+                           self.fullname, exc)\n+            return None\n+        except ValueError:\n+            args = ''\n+\n+        if self.config.strip_signature_backslash:\n+            # escape backslashes for reST\n+            args = args.replace('\\\\', '\\\\\\\\')\n+        return args\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+\n+        sourcename = self.get_sourcename()\n+        obj = self.parent.__dict__.get(self.object_name, self.object)\n+        if inspect.isabstractmethod(obj):\n+            self.add_line('   :abstractmethod:', sourcename)\n+        if inspect.iscoroutinefunction(obj):\n+            self.add_line('   :async:', sourcename)\n+        if inspect.isclassmethod(obj):\n+            self.add_line('   :classmethod:', sourcename)\n+        if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n+            self.add_line('   :staticmethod:', sourcename)\n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n+            self.add_line('   :final:', sourcename)\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        sigs = []\n+        if (self.analyzer and\n+                '.'.join(self.objpath) in self.analyzer.overloads and\n+                self.config.autodoc_typehints != 'none'):\n+            # Use signatures for overloaded methods instead of the implementation method.\n+            overloaded = True\n+        else:\n+            overloaded = False\n+            sig = super().format_signature(**kwargs)\n+            sigs.append(sig)\n+\n+        meth = self.parent.__dict__.get(self.objpath[-1])\n+        if inspect.is_singledispatch_method(meth):\n+            # append signature of singledispatch'ed functions\n+            for typ, func in meth.dispatcher.registry.items():\n+                if typ is object:\n+                    pass  # default implementation. skipped.\n+                else:\n+                    dispatchmeth = self.annotate_to_first_argument(func, typ)\n+                    if dispatchmeth:\n+                        documenter = MethodDocumenter(self.directive, '')\n+                        documenter.parent = self.parent\n+                        documenter.object = dispatchmeth\n+                        documenter.objpath = [None]\n+                        sigs.append(documenter.format_signature())\n+        if overloaded:\n+            if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n+                actual = inspect.signature(self.object, bound_method=False,\n+                                           type_aliases=self.config.autodoc_type_aliases)\n+            else:\n+                actual = inspect.signature(self.object, bound_method=True,\n+                                           type_aliases=self.config.autodoc_type_aliases)\n+\n+            __globals__ = safe_getattr(self.object, '__globals__', {})\n+            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n+                overload = self.merge_default_value(actual, overload)\n+                overload = evaluate_signature(overload, __globals__,\n+                                              self.config.autodoc_type_aliases)\n+\n+                if not inspect.isstaticmethod(self.object, cls=self.parent,\n+                                              name=self.object_name):\n+                    parameters = list(overload.parameters.values())\n+                    overload = overload.replace(parameters=parameters[1:])\n+                sig = stringify_signature(overload, **kwargs)\n+                sigs.append(sig)\n+\n+        return \"\\n\".join(sigs)\n+\n+    def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n+        \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n+        parameters = list(overload.parameters.values())\n+        for i, param in enumerate(parameters):\n+            actual_param = actual.parameters.get(param.name)\n+            if actual_param and param.default == '...':\n+                parameters[i] = param.replace(default=actual_param.default)\n+\n+        return overload.replace(parameters=parameters)\n+\n+    def annotate_to_first_argument(self, func: Callable, typ: Type) -> Optional[Callable]:\n+        \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n+        try:\n+            sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n+        except TypeError as exc:\n+            logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n+                           self.fullname, exc)\n+            return None\n+        except ValueError:\n+            return None\n+\n+        if len(sig.parameters) == 1:\n+            return None\n+\n+        def dummy():\n+            pass\n+\n+        params = list(sig.parameters.values())\n+        if params[1].annotation is Parameter.empty:\n+            params[1] = params[1].replace(annotation=typ)\n+            try:\n+                dummy.__signature__ = sig.replace(parameters=params)  # type: ignore\n+                return dummy\n+            except (AttributeError, TypeError):\n+                # failed to update signature (ex. built-in or extension types)\n+                return None\n+        else:\n+            return None\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if self.objpath[-1] == '__init__':\n+            docstring = getdoc(self.object, self.get_attr,\n+                               self.config.autodoc_inherit_docstrings,\n+                               self.parent, self.object_name)\n+            if (docstring is not None and\n+                (docstring == object.__init__.__doc__ or  # for pypy\n+                 docstring.strip() == object.__init__.__doc__)):  # for !pypy\n+                docstring = None\n+            if docstring:\n+                tab_width = self.directive.state.document.settings.tab_width\n+                return [prepare_docstring(docstring, tabsize=tab_width)]\n+            else:\n+                return []\n+        elif self.objpath[-1] == '__new__':\n+            __new__ = self.get_attr(self.object, '__new__', None)\n+            if __new__:\n+                docstring = getdoc(__new__, self.get_attr,\n+                                   self.config.autodoc_inherit_docstrings,\n+                                   self.parent, self.object_name)\n+                if (docstring is not None and\n+                    (docstring == object.__new__.__doc__ or  # for pypy\n+                     docstring.strip() == object.__new__.__doc__)):  # for !pypy\n+                    docstring = None\n+            if docstring:\n+                tab_width = self.directive.state.document.settings.tab_width\n+                return [prepare_docstring(docstring, tabsize=tab_width)]\n+            else:\n+                return []\n+        else:\n+            return super().get_doc()\n+\n+\n+class NonDataDescriptorMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for AttributeDocumenter to provide the feature for supporting non\n+    data-descriptors.\n+\n+    .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring\n+              and :value: header will be suppressed unexpectedly.\n+    \"\"\"\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)  # type: ignore\n+        if ret and not inspect.isattributedescriptor(self.object):\n+            self.non_data_descriptor = True\n+        else:\n+            self.non_data_descriptor = False\n+\n+        return ret\n+\n+    def should_suppress_value_header(self) -> bool:\n+        return (not getattr(self, 'non_data_descriptor', False) or\n+                super().should_suppress_directive_header())\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if getattr(self, 'non_data_descriptor', False):\n+            # the docstring of non datadescriptor is very probably the wrong thing\n+            # to display\n+            return None\n+        else:\n+            return super().get_doc(ignore)  # type: ignore\n+\n+\n+class SlotsMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for AttributeDocumenter to provide the feature for supporting __slots__.\n+    \"\"\"\n+\n+    def isslotsattribute(self) -> bool:\n+        \"\"\"Check the subject is an attribute in __slots__.\"\"\"\n+        try:\n+            __slots__ = inspect.getslots(self.parent)\n+            if __slots__ and self.objpath[-1] in __slots__:\n+                return True\n+            else:\n+                return False\n+        except (ValueError, TypeError):\n+            return False\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)  # type: ignore\n+        if self.isslotsattribute():\n+            self.object = SLOTSATTR\n+\n+        return ret\n+\n+    def should_suppress_directive_header(self) -> bool:\n+        if self.object is SLOTSATTR:\n+            self._datadescriptor = True\n+            return True\n+        else:\n+            return super().should_suppress_directive_header()\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if self.object is SLOTSATTR:\n+            try:\n+                __slots__ = inspect.getslots(self.parent)\n+                if __slots__ and __slots__.get(self.objpath[-1]):\n+                    docstring = prepare_docstring(__slots__[self.objpath[-1]])\n+                    return [docstring]\n+                else:\n+                    return []\n+            except ValueError as exc:\n+                logger.warning(__('Invalid __slots__ found on %s. Ignored.'),\n+                               (self.parent.__qualname__, exc), type='autodoc')\n+                return []\n+        else:\n+            return super().get_doc(ignore)  # type: ignore\n+\n+\n+class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for AttributeDocumenter to provide the feature for supporting runtime\n+    instance attributes (that are defined in __init__() methods with doc-comments).\n+\n+    Example:\n+\n+        class Foo:\n+            def __init__(self):\n+                self.attr = None  #: This is a target of this mix-in.\n+    \"\"\"\n+\n+    RUNTIME_INSTANCE_ATTRIBUTE = object()\n+\n+    def is_runtime_instance_attribute(self, parent: Any) -> bool:\n+        \"\"\"Check the subject is an attribute defined in __init__().\"\"\"\n+        # An instance variable defined in __init__().\n+        if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore\n+            return True\n+        else:\n+            return False\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        \"\"\"Check the existence of runtime instance attribute when failed to import the\n+        attribute.\"\"\"\n+        try:\n+            return super().import_object(raiseerror=True)  # type: ignore\n+        except ImportError as exc:\n+            try:\n+                with mock(self.config.autodoc_mock_imports):\n+                    ret = import_object(self.modname, self.objpath[:-1], 'class',\n+                                        attrgetter=self.get_attr,  # type: ignore\n+                                        warningiserror=self.config.autodoc_warningiserror)\n+                    parent = ret[3]\n+                    if self.is_runtime_instance_attribute(parent):\n+                        self.object = self.RUNTIME_INSTANCE_ATTRIBUTE\n+                        self.parent = parent\n+                        return True\n+            except ImportError:\n+                pass\n+\n+            if raiseerror:\n+                raise\n+            else:\n+                logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n+                self.env.note_reread()\n+                return False\n+\n+    def should_suppress_value_header(self) -> bool:\n+        return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or\n+                super().should_suppress_value_header())\n+\n+\n+class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\n+    \"\"\"\n+    Mixin for AttributeDocumenter to provide the feature for supporting uninitialized\n+    instance attributes (PEP-526 styled, annotation only attributes).\n+\n+    Example:\n+\n+        class Foo:\n+            attr: int  #: This is a target of this mix-in.\n+    \"\"\"\n+\n+    def is_uninitialized_instance_attribute(self, parent: Any) -> bool:\n+        \"\"\"Check the subject is an annotation only attribute.\"\"\"\n+        annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)\n+        if self.objpath[-1] in annotations:\n+            return True\n+        else:\n+            return False\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        \"\"\"Check the exisitence of uninitialized instance attribute when failed to import\n+        the attribute.\"\"\"\n+        try:\n+            return super().import_object(raiseerror=True)  # type: ignore\n+        except ImportError as exc:\n+            try:\n+                ret = import_object(self.modname, self.objpath[:-1], 'class',\n+                                    attrgetter=self.get_attr,  # type: ignore\n+                                    warningiserror=self.config.autodoc_warningiserror)\n+                parent = ret[3]\n+                if self.is_uninitialized_instance_attribute(parent):\n+                    self.object = UNINITIALIZED_ATTR\n+                    self.parent = parent\n+                    return True\n+            except ImportError:\n+                pass\n+\n+            if raiseerror:\n+                raise\n+            else:\n+                logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n+                self.env.note_reread()\n+                return False\n+\n+    def should_suppress_value_header(self) -> bool:\n+        return (self.object is UNINITIALIZED_ATTR or\n+                super().should_suppress_value_header())\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if self.object is UNINITIALIZED_ATTR:\n+            return None\n+        else:\n+            return super().get_doc(ignore)  # type: ignore\n+\n+\n+class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore\n+                          TypeVarMixin, RuntimeInstanceAttributeMixin,\n+                          UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,\n+                          DocstringStripSignatureMixin, ClassLevelDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for attributes.\n+    \"\"\"\n+    objtype = 'attribute'\n+    member_order = 60\n+    option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)\n+    option_spec[\"annotation\"] = annotation_option\n+    option_spec[\"no-value\"] = bool_option\n+\n+    # must be higher than the MethodDocumenter, else it will recognize\n+    # some non-data descriptors as methods\n+    priority = 10\n+\n+    @staticmethod\n+    def is_function_or_method(obj: Any) -> bool:\n+        return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        if inspect.isattributedescriptor(member):\n+            return True\n+        elif (not isinstance(parent, ModuleDocumenter) and\n+              not inspect.isroutine(member) and\n+              not isinstance(member, type)):\n+            return True\n+        else:\n+            return False\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def isinstanceattribute(self) -> bool:\n+        \"\"\"Check the subject is an instance attribute.\"\"\"\n+        warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',\n+                      RemovedInSphinx50Warning)\n+        # uninitialized instance variable (PEP-526)\n+        with mock(self.config.autodoc_mock_imports):\n+            try:\n+                ret = import_object(self.modname, self.objpath[:-1], 'class',\n+                                    attrgetter=self.get_attr,\n+                                    warningiserror=self.config.autodoc_warningiserror)\n+                self.parent = ret[3]\n+                annotations = get_type_hints(self.parent, None,\n+                                             self.config.autodoc_type_aliases)\n+                if self.objpath[-1] in annotations:\n+                    self.object = UNINITIALIZED_ATTR\n+                    return True\n+            except ImportError:\n+                pass\n+\n+        return False\n+\n+    def update_annotations(self, parent: Any) -> None:\n+        \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n+        try:\n+            annotations = dict(inspect.getannotations(parent))\n+            parent.__annotations__ = annotations\n+\n+            for cls in inspect.getmro(parent):\n+                try:\n+                    module = safe_getattr(cls, '__module__')\n+                    qualname = safe_getattr(cls, '__qualname__')\n+\n+                    analyzer = ModuleAnalyzer.for_module(module)\n+                    analyzer.analyze()\n+                    for (classname, attrname), annotation in analyzer.annotations.items():\n+                        if classname == qualname and attrname not in annotations:\n+                            annotations[attrname] = annotation\n+                except (AttributeError, PycodeError):\n+                    pass\n+        except (AttributeError, TypeError):\n+            # Failed to set __annotations__ (built-in, extensions, etc.)\n+            pass\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if inspect.isenumattribute(self.object):\n+            self.object = self.object.value\n+        if self.parent:\n+            self.update_annotations(self.parent)\n+\n+        return ret\n+\n+    def get_real_modname(self) -> str:\n+        real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n+        return real_modname or self.modname\n+\n+    def should_suppress_value_header(self) -> bool:\n+        if super().should_suppress_value_header():\n+            return True\n+        else:\n+            doc = self.get_doc()\n+            if doc:\n+                docstring, metadata = separate_metadata('\\n'.join(sum(doc, [])))\n+                if 'hide-value' in metadata:\n+                    return True\n+\n+        return False\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n+            pass\n+        elif self.options.annotation:\n+            self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n+        else:\n+            # obtain type annotation for this attribute\n+            annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n+            if self.objpath[-1] in annotations:\n+                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n+                self.add_line('   :type: ' + objrepr, sourcename)\n+\n+            try:\n+                if self.options.no_value or self.should_suppress_value_header():\n+                    pass\n+                else:\n+                    objrepr = object_description(self.object)\n+                    self.add_line('   :value: ' + objrepr, sourcename)\n+            except ValueError:\n+                pass\n+\n+    def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:\n+        for cls in inspect.getmro(parent):\n+            try:\n+                module = safe_getattr(cls, '__module__')\n+                qualname = safe_getattr(cls, '__qualname__')\n+\n+                analyzer = ModuleAnalyzer.for_module(module)\n+                analyzer.analyze()\n+                if qualname and self.objpath:\n+                    key = (qualname, attrname)\n+                    if key in analyzer.attr_docs:\n+                        return list(analyzer.attr_docs[key])\n+            except (AttributeError, PycodeError):\n+                pass\n+\n+        return None\n+\n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        # Check the attribute has a docstring-comment\n+        comment = self.get_attribute_comment(self.parent, self.objpath[-1])\n+        if comment:\n+            return [comment]\n+\n+        try:\n+            # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n+            # a docstring from the value which descriptor returns unexpectedly.\n+            # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n+            orig = self.config.autodoc_inherit_docstrings\n+            self.config.autodoc_inherit_docstrings = False  # type: ignore\n+            return super().get_doc(ignore)\n+        finally:\n+            self.config.autodoc_inherit_docstrings = orig  # type: ignore\n+\n+    def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n+                    ) -> None:\n+        # Disable analyzing attribute comment on Documenter.add_content() to control it on\n+        # AttributeDocumenter.add_content()\n+        self.analyzer = None\n+\n+        if more_content is None:\n+            more_content = StringList()\n+        self.update_content(more_content)\n+        super().add_content(more_content, no_docstring)\n+\n+\n+class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n+    \"\"\"\n+    Specialized Documenter subclass for properties.\n+    \"\"\"\n+    objtype = 'property'\n+    member_order = 60\n+\n+    # before AttributeDocumenter\n+    priority = AttributeDocumenter.priority + 1\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def get_real_modname(self) -> str:\n+        real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n+        return real_modname or self.modname\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        super().add_directive_header(sig)\n+        sourcename = self.get_sourcename()\n+        if inspect.isabstractmethod(self.object):\n+            self.add_line('   :abstractmethod:', sourcename)\n+\n+        if safe_getattr(self.object, 'fget', None):\n+            try:\n+                signature = inspect.signature(self.object.fget,\n+                                              type_aliases=self.config.autodoc_type_aliases)\n+                if signature.return_annotation is not Parameter.empty:\n+                    objrepr = stringify_typehint(signature.return_annotation)\n+                    self.add_line('   :type: ' + objrepr, sourcename)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+            except ValueError:\n+                return None\n+\n+\n+class NewTypeAttributeDocumenter(AttributeDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for NewTypes.\n+\n+    Note: This must be invoked before MethodDocumenter because NewType is a kind of\n+    function object.\n+    \"\"\"\n+\n+    objtype = 'newvarattribute'\n+    directivetype = 'attribute'\n+    priority = MethodDocumenter.priority + 1\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)\n+\n+\n+def get_documenters(app: Sphinx) -> Dict[str, Type[Documenter]]:\n+    \"\"\"Returns registered Documenter classes\"\"\"\n+    warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n+    return app.registry.documenters\n+\n+\n+def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n+    \"\"\"Alternative getattr() for types\"\"\"\n+    for typ, func in app.registry.autodoc_attrgettrs.items():\n+        if isinstance(obj, typ):\n+            return func(obj, name, *defargs)\n+\n+    return safe_getattr(obj, name, *defargs)\n+\n+\n+def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n+    if config.autodoc_member_order == 'alphabetic':\n+        # RemovedInSphinx50Warning\n+        logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n+                          'instead of \"alphabetic\". Please update your setting.'))\n+        config.autodoc_member_order = 'alphabetical'  # type: ignore\n+\n+\n+# for compatibility\n+from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n+from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n+from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n+from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n+from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n+from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n+from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n+\n+\n+def setup(app: Sphinx) -> Dict[str, Any]:\n+    app.add_autodocumenter(ModuleDocumenter)\n+    app.add_autodocumenter(ClassDocumenter)\n+    app.add_autodocumenter(ExceptionDocumenter)\n+    app.add_autodocumenter(DataDocumenter)\n+    app.add_autodocumenter(NewTypeDataDocumenter)\n+    app.add_autodocumenter(FunctionDocumenter)\n+    app.add_autodocumenter(DecoratorDocumenter)\n+    app.add_autodocumenter(MethodDocumenter)\n+    app.add_autodocumenter(AttributeDocumenter)\n+    app.add_autodocumenter(PropertyDocumenter)\n+    app.add_autodocumenter(NewTypeAttributeDocumenter)\n+\n+    app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n+    app.add_config_value('autodoc_member_order', 'alphabetical', True,\n+                         ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n+    app.add_config_value('autodoc_class_signature', 'mixed', True, ENUM('mixed', 'separated'))\n+    app.add_config_value('autodoc_default_options', {}, True)\n+    app.add_config_value('autodoc_docstring_signature', True, True)\n+    app.add_config_value('autodoc_mock_imports', [], True)\n+    app.add_config_value('autodoc_typehints', \"signature\", True,\n+                         ENUM(\"signature\", \"description\", \"none\", \"both\"))\n+    app.add_config_value('autodoc_typehints_description_target', 'all', True,\n+                         ENUM('all', 'documented'))\n+    app.add_config_value('autodoc_type_aliases', {}, True)\n+    app.add_config_value('autodoc_warningiserror', True, True)\n+    app.add_config_value('autodoc_inherit_docstrings', True, True)\n+    app.add_event('autodoc-before-process-signature')\n+    app.add_event('autodoc-process-docstring')\n+    app.add_event('autodoc-process-signature')\n+    app.add_event('autodoc-skip-member')\n+\n+    app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n+\n+    app.setup_extension('sphinx.ext.autodoc.preserve_defaults')\n+    app.setup_extension('sphinx.ext.autodoc.type_comment')\n+    app.setup_extension('sphinx.ext.autodoc.typehints')\n+\n+    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n"
  },
  "sphinx-doc__sphinx-9281": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9281",
    "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex a415a7074..c8b2cfc61 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -457,6 +457,10 @@ def object_description(object: Any) -> str:\n         else:\n             return \"frozenset({%s})\" % \", \".join(object_description(x)\n                                                  for x in sorted_values)\n+    if isinstance(object, enum.Enum):\n+        # Format enum members as ClassName.MemberName instead of <ClassName.MemberName: value>\n+        return '%s.%s' % (object.__class__.__name__, object.name)\n+\n     try:\n         s = repr(object)\n     except Exception as exc:\n"
  },
  "sphinx-doc__sphinx-9320": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9320",
    "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex a40a21073..393772c22 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -146,8 +146,10 @@ def do_prompt(text: str, default: str = None, validator: Callable[[str], Any] =\n         else:\n             prompt = colorize(COLOR_QUESTION, prompt, input_mode=False)\n         x = term_input(prompt).strip()\n-        if default and not x:\n+        if default is not None and not x:\n             x = default\n+            if x == '':\n+                return x\n         try:\n             x = validator(x)\n         except ValidationError as err:\n"
  },
  "sphinx-doc__sphinx-9367": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9367",
    "model_patch": "diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex f541ec0a9..713f4426e 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -214,7 +214,10 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n         if node.elts:\n-            return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n+            if len(node.elts) == 1:\n+                return \"(\" + self.visit(node.elts[0]) + \",)\"\n+            else:\n+                return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n         else:\n             return \"()\"\n \n"
  },
  "sphinx-doc__sphinx-9461": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9461",
    "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1cecb1f79..2cb6c6238 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2069,7 +2069,18 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n     @classmethod\n     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                             ) -> bool:\n-        return inspect.isroutine(member) and not isinstance(parent, ModuleDocumenter)\n+        if inspect.isroutine(member) and not isinstance(parent, ModuleDocumenter):\n+            return True\n+        # Support for descriptors wrapped by classmethod (e.g. @classmethod @property)\n+        try:\n+            if inspect.isclass(parent):\n+                for base in getattr(parent, '__mro__', [parent]):\n+                    val = base.__dict__.get(membername)\n+                    if val is not None and isinstance(val, classmethod):\n+                        return True\n+        except Exception:\n+            pass\n+        return False\n \n     def import_object(self, raiseerror: bool = False) -> bool:\n         ret = super().import_object(raiseerror)\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 23dd9e930..751282071 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -838,6 +838,23 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     * inherited decorated methods\n     \"\"\"\n     doc = attrgetter(obj, '__doc__', None)\n+    # Prefer the underlying wrapped object's docstring for descriptors such as\n+    # classmethod(property(...)). If the object has __func__, try its __doc__,\n+    # and if that is a property, try its fget.__doc__ as well.\n+    try:\n+        func = getattr(obj, '__func__', None)\n+        if func is not None:\n+            try:\n+                if isproperty(func):\n+                    doc = attrgetter(func, '__doc__', None) or attrgetter(getattr(func, 'fget', None), '__doc__', None)\n+                else:\n+                    funcdoc = attrgetter(func, '__doc__', None)\n+                    if funcdoc and (doc is None or doc == classmethod.__doc__):\n+                        doc = funcdoc\n+            except Exception:\n+                pass\n+    except Exception:\n+        pass\n     if ispartial(obj) and doc == obj.__class__.__doc__:\n         return getdoc(obj.func)\n     elif doc is None and allow_inherited:\n"
  },
  "sphinx-doc__sphinx-9698": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9698",
    "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex cd02eaad5..1a3bd60c7 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"
  },
  "django__django-11999": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-11999",
    "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..36ad0b2190 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,10 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, method_name):\n+                setattr(cls, method_name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n"
  },
  "django__django-12193": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12193",
    "model_patch": "diff --git a/django/contrib/postgres/forms/array.py b/django/contrib/postgres/forms/array.py\nindex 2e19cd574a..223cceed57 100644\n--- a/django/contrib/postgres/forms/array.py\n+++ b/django/contrib/postgres/forms/array.py\n@@ -144,10 +144,14 @@ class SplitArrayWidget(forms.Widget):\n                 widget_value = value[i]\n             except IndexError:\n                 widget_value = None\n+            # Use a copy of final_attrs for each subwidget so that widgets\n+            # (e.g. CheckboxInput.get_context) can't mutate a shared dict and\n+            # affect subsequent widgets.\n+            attrs_i = final_attrs.copy()\n             if id_:\n-                final_attrs = {**final_attrs, 'id': '%s_%s' % (id_, i)}\n+                attrs_i['id'] = '%s_%s' % (id_, i)\n             context['widget']['subwidgets'].append(\n-                self.widget.get_context(name + '_%s' % i, widget_value, final_attrs)['widget']\n+                self.widget.get_context(name + '_%s' % i, widget_value, attrs_i)['widget']\n             )\n         return context\n \n"
  },
  "django__django-12304": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12304",
    "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex f48143ddaf..1944121520 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -60,6 +60,7 @@ class ChoicesMeta(enum.EnumMeta):\n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated choices.\"\"\"\n+    do_not_call_in_templates = True\n \n     def __str__(self):\n         \"\"\"\n"
  },
  "django__django-12308": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12308",
    "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex e4ddc8f017..0c8ee6e586 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -398,6 +398,14 @@ def display_for_field(value, field, empty_value_display):\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    elif isinstance(field, models.JSONField):\n+        # Use the model field's form field to prepare the JSON value for display.\n+        form_field = field.formfield()\n+        try:\n+            prepared = form_field.prepare_value(value)\n+        except Exception:\n+            prepared = value\n+        return display_for_value(prepared, empty_value_display)\n     else:\n         return display_for_value(value, empty_value_display)\n \n"
  },
  "django__django-12774": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "django__django-12774",
    "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex d9c9b0db04..7d4a926463 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -689,8 +689,37 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\n-        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n-            raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n+        if field_name != 'pk':\n+            field = self.model._meta.get_field(field_name)\n+            # Accept fields that are unique=True, or made unique by a\n+            # UniqueConstraint in the model's Meta (or legacy unique_together).\n+            is_unique_field = field.unique\n+            if not is_unique_field:\n+                meta = self.model._meta\n+                # Check UniqueConstraint objects in Meta.constraints\n+                constraints = getattr(meta, \"constraints\", []) or []\n+                for constraint in constraints:\n+                    try:\n+                        fields = getattr(constraint, \"fields\", None)\n+                    except Exception:\n+                        fields = None\n+                    if fields and len(fields) == 1 and fields[0] == field_name:\n+                        # This UniqueConstraint makes the field unique.\n+                        is_unique_field = True\n+                        break\n+                # Also consider legacy unique_together\n+                if not is_unique_field:\n+                    ut = getattr(meta, \"unique_together\", None) or ()\n+                    # unique_together can be a tuple of tuples or a single tuple.\n+                    for ut_item in ut:\n+                        # normalize single-field tuples\n+                        if isinstance(ut_item, str):\n+                            ut_item = (ut_item,)\n+                        if len(ut_item) == 1 and ut_item[0] == field_name:\n+                            is_unique_field = True\n+                            break\n+            if not is_unique_field:\n+                raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\ndiff --git a/test_settings.py b/test_settings.py\nnew file mode 100644\nindex 0000000000..e976b2d6b2\n--- /dev/null\n+++ b/test_settings.py\n@@ -0,0 +1,12 @@\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+INSTALLED_APPS = [\n+    'django.contrib.auth',\n+    'django.contrib.contenttypes',\n+    'testapp.apps.TestappConfig',\n+]\n+SECRET_KEY = 'test'\ndiff --git a/testapp/__init__.py b/testapp/__init__.py\nnew file mode 100644\nindex 0000000000..3af93b9289\n--- /dev/null\n+++ b/testapp/__init__.py\n@@ -0,0 +1 @@\n+# testapp package\ndiff --git a/testapp/apps.py b/testapp/apps.py\nnew file mode 100644\nindex 0000000000..5de0eb198b\n--- /dev/null\n+++ b/testapp/apps.py\n@@ -0,0 +1,4 @@\n+from django.apps import AppConfig\n+\n+class TestappConfig(AppConfig):\n+    name = 'testapp'\ndiff --git a/testapp/models.py b/testapp/models.py\nnew file mode 100644\nindex 0000000000..53e8efecfe\n--- /dev/null\n+++ b/testapp/models.py\n@@ -0,0 +1,7 @@\n+from django.db import models\n+\n+class Article(models.Model):\n+    slug = models.CharField(max_length=255)\n+    class Meta:\n+        app_label = 'testapp'\n+        constraints = [models.UniqueConstraint(fields=['slug'], name='testapp_article_slug_unq')]\n"
  },
  "sphinx-doc__sphinx-10673": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-10673",
    "model_patch": "diff --git a/sphinx/environment/adapters/toctree.py b/sphinx/environment/adapters/toctree.py\nindex 9678e3c7c..6df4dd9ea 100644\n--- a/sphinx/environment/adapters/toctree.py\n+++ b/sphinx/environment/adapters/toctree.py\n@@ -164,6 +164,17 @@ class TocTree:\n                                           'doesn\\'t have a title: no link will be generated'),\n                                        ref, location=toctreenode)\n                 except KeyError:\n+                    # treat built-in generated indices/search as existing documents\n+                    if ref in (\"genindex\", \"modindex\", \"search\"):\n+                        if not title:\n+                            title = ref\n+                        reference = nodes.reference('', '', internal=True,\n+                                                    refuri=ref,\n+                                                    anchorname='',\n+                                                    *[nodes.Text(title)])\n+                        para = addnodes.compact_paragraph('', '', reference)\n+                        item = nodes.list_item('', para)\n+                        toc = nodes.bullet_list('', item)\n                     # this is raised if the included file does not exist\n                     if excluded(self.env.doc2path(ref, False)):\n                         message = __('toctree contains reference to excluded document %r')\n"
  },
  "sphinx-doc__sphinx-8269": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8269",
    "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 9b54afc7c..1083e82ec 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -166,6 +166,7 @@ class CheckExternalLinksBuilder(Builder):\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n+                    response.raise_for_status()\n                     found = check_anchor(response, unquote(anchor))\n \n                     if not found:\n"
  },
  "sphinx-doc__sphinx-8721": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-8721",
    "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..7ed052ada 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -133,7 +133,6 @@ def env_merge_info(app: Sphinx, env: BuildEnvironment, docnames: Iterable[str],\n     # now merge in the information from the subprocess\n     env._viewcode_modules.update(other._viewcode_modules)  # type: ignore\n \n-\n def missing_reference(app: Sphinx, env: BuildEnvironment, node: Element, contnode: Node\n                       ) -> Optional[Node]:\n     # resolve our \"viewcode\" reference nodes -- they need special treatment\n@@ -224,6 +223,11 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n                 'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                 lines[start])\n             lines[min(end, maxindex)] += '</div>'\n+        # normalize pygments output: remove pure-whitespace <span> before docstring spans\n+        import re\n+        for i, line in enumerate(lines):\n+            # remove spans that only wrap whitespace when followed by a span starting a docstring\n+            lines[i] = re.sub(r'(<span[^>]*>)(\\s*)(</span>)(?=\\s*<span[^>]*>&quot;)', r'\\2', lines[i])\n         # try to find parents (for submodules)\n         parents = []\n         parent = modname\n"
  },
  "sphinx-doc__sphinx-9230": {
    "model_name_or_path": "openai/gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9230",
    "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex d8cb75a5f..390d83b4f 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -268,6 +268,12 @@ class GoogleDocstring:\n             if match:\n                 _name = match.group(1).strip()\n                 _type = match.group(2)\n+            else:\n+                # Also accept \"type name\" (e.g. \"dict(str, str) opc_meta\")\n+                alt = re.match(r'^\\s*(\\S+\\([^)]*\\))\\s+(.+)$', before)\n+                if alt:\n+                    _type = alt.group(1)\n+                    _name = alt.group(2).strip()\n \n         _name = self._escape_args_and_kwargs(_name)\n \n"
  }
}